{"task_id": "ruby/0", "entry_point": "below_zero", "test": "\n\narg00 = []\nx0 = below_zero(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 2, -3, 1, 2, -3]\nx1 = below_zero(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 2, -4, 5, 6]\nx2 = below_zero(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1, -1, 2, -2, 5, -5, 4, -4]\nx3 = below_zero(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, -1, 2, -2, 5, -5, 4, -5]\nx4 = below_zero(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [1, -2, 2, -2, 5, -5, 4, -4]\nx5 = below_zero(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "آپ کو بینک اکاؤنٹ میں جمع اور نکلوانے کی کارروائیوں کی ایک فہرست دی جاتی ہے جو اس سے شروع ہوتی ہے \nصفر بیلنس۔ آپ کا کام یہ معلوم کرنا ہے کہ آیا کسی بھی وقت اکاؤنٹ کا بیلنس صفر سے نیچے آتا ہے، اور \nاس وقت فنکشن کو درست واپس کرنا چاہیے۔ بصورت دیگر اسے غلط واپس کرنا چاہیے۔ \n>>> نیچے _ صفر ([1، 2، 3]) \nجھوٹا۔ \n>>> نیچے _ صفر ([1، 2،-4، 5]) \nسچ ہے۔", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/1", "entry_point": "sum_product", "test": "\n\narg00 = []\nx0 = sum_product(arg00)\nv0 = [0, 1]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 1, 1]\nx1 = sum_product(arg10)\nv1 = [3, 1]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [100, 0]\nx2 = sum_product(arg20)\nv2 = [100, 0]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [3, 5, 7]\nx3 = sum_product(arg30)\nv3 = [15, 105]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [10]\nx4 = sum_product(arg40)\nv4 = [10, 10]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "انٹیجرز کی دی گئی فہرست کے لیے، ایک ٹپل واپس کریں جس میں ایک مجموعہ اور فہرست میں موجود تمام انٹیجرز کا پروڈکٹ ہو۔ \nخالی رقم 0 کے برابر ہونی چاہیے اور خالی پروڈکٹ 1 کے برابر ہونا چاہیے۔ \n>>> sum _ product ([]) \n(0، 1) \n>>> sum _ product ([1، 2، 3، 4]) \n(10، 24)", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/2", "entry_point": "string_xor", "test": "\n\narg00 = \"111000\"\narg01 = \"101010\"\nx0 = string_xor(arg00, arg01)\nv0 = \"010010\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"1\"\narg11 = \"1\"\nx1 = string_xor(arg10, arg11)\nv1 = \"0\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"0101\"\narg21 = \"0000\"\nx2 = string_xor(arg20, arg21)\nv2 = \"0101\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\n", "description": "ان پٹ دو تار a اور b ہیں جو صرف 1s اور 0s پر مشتمل ہیں۔ \nان ان پٹ پر بائنری XOR انجام دیں اور نتیجہ بھی ایک سٹرنگ کے طور پر واپس کریں۔ \n>>> سٹرنگ _ xor ('010'،'110') \n'100'", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/3", "entry_point": "longest", "test": "\n\narg00 = []\nx0 = longest(arg00)\nv0 = nil\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [\"x\", \"y\", \"z\"]\nx1 = longest(arg10)\nv1 = \"x\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]\nx2 = longest(arg20)\nv2 = \"zzzz\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\n", "description": "سٹرنگ کی فہرست میں سے سب سے لمبا واپس کریں۔ متعدد ہونے کی صورت میں پہلا واپس کریں۔ \nایک ہی لمبائی کے تار۔ اگر ان پٹ فہرست خالی ہے تو کالعدم واپس کریں۔ \n>>> طویل ترین ([]) \n\n>>> طویل ترین (['a'،'b'،'c']) \n\"اے\" \n>>> طویل ترین (['a'،'bb'،'ccc']) \n'سی سی سی'", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/4", "entry_point": "greatest_common_divisor", "test": "\n\narg00 = 3\narg01 = 7\nx0 = greatest_common_divisor(arg00, arg01)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 10\narg11 = 15\nx1 = greatest_common_divisor(arg10, arg11)\nv1 = 5\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 49\narg21 = 14\nx2 = greatest_common_divisor(arg20, arg21)\nv2 = 7\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 144\narg31 = 60\nx3 = greatest_common_divisor(arg30, arg31)\nv3 = 12\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "دو عدد a اور b کا سب سے بڑا مشترکہ تقسیم کار واپس کریں \n>>> سب سے بڑا _ عام _ تقسیم کنندہ (3, 5) \n1. \n>>> سب سے بڑا _ عام _ تقسیم کنندہ (25، 15) \n5.", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/5", "entry_point": "sort_numbers", "test": "\n\narg00 = \"\"\nx0 = sort_numbers(arg00)\nv0 = \"\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"three\"\nx1 = sort_numbers(arg10)\nv1 = \"three\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"three five nine\"\nx2 = sort_numbers(arg20)\nv2 = \"three five nine\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"five zero four seven nine eight\"\nx3 = sort_numbers(arg30)\nv3 = \"zero four five seven eight nine\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"six five four three two one zero\"\nx4 = sort_numbers(arg40)\nv4 = \"zero one two three four five six\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "ان پٹ'صفر'سے'نو'تک کے اعداد کی ایک جگہ کی حد بند تار ہے۔ \nدرست انتخاب'صفر'،'ایک'،'دو'،'تین'،'چار'،'پانچ'،'چھ'،'سات'،'آٹھ'اور'نو'ہیں۔ \nسب سے چھوٹے سے لے کر سب سے بڑے تک ترتیب شدہ نمبروں کے ساتھ سٹرنگ واپس کریں \n>>> نمبر ترتیب دیں ('تین ایک پانچ') \n'ایک تین پانچ'", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/6", "entry_point": "rescale_to_unit", "test": "\n\narg00 = [2.0, 49.9]\nx0 = rescale_to_unit(arg00)\nv0 = [0.0, 1.0]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [100.0, 49.9]\nx1 = rescale_to_unit(arg10)\nv1 = [1.0, 0.0]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1.0, 2.0, 3.0, 4.0, 5.0]\nx2 = rescale_to_unit(arg20)\nv2 = [0.0, 0.25, 0.5, 0.75, 1.0]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [2.0, 1.0, 5.0, 3.0, 4.0]\nx3 = rescale_to_unit(arg30)\nv3 = [0.25, 0.0, 1.0, 0.5, 0.75]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [12.0, 11.0, 15.0, 13.0, 14.0]\nx4 = rescale_to_unit(arg40)\nv4 = [0.25, 0.0, 1.0, 0.5, 0.75]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "اعداد کی فہرست (کم از کم دو عناصر کی) کو دیکھتے ہوئے، اس فہرست میں لکیری تبدیلی لاگو کریں، \nاس طرح کہ سب سے چھوٹا عدد 0 ہو جائے گا اور سب سے بڑا عدد 1 ہو جائے گا۔ \n>>> ری سیل _ ٹو _ یونٹ ([1. 0, 2. 0, 3. 0, 4. 0, 5. 0]) \n[0. 0, 0. 25, 0. 0, 0. 75, 1. 0]", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/7", "entry_point": "flip_case", "test": "\n\narg00 = \"\"\nx0 = flip_case(arg00)\nv0 = \"\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Hello!\"\nx1 = flip_case(arg10)\nv1 = \"hELLO!\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"These violent delights have violent ends\"\nx2 = flip_case(arg20)\nv2 = \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\n", "description": "دی گئی سٹرنگ کے لیے، چھوٹے حروف کو بڑے حروف میں اور بڑے حروف کو چھوٹے حروف میں پلٹائیں۔ \n>>> فلپ _ کیس ('ہیلو') \n\"ہیلو\"", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/8", "entry_point": "get_positive", "test": "\n\narg00 = [-1, -2, 4, 5, 6]\nx0 = get_positive(arg00)\nv0 = [4, 5, 6]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]\nx1 = get_positive(arg10)\nv1 = [5, 3, 2, 3, 3, 9, 123, 1]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [-1, -2]\nx2 = get_positive(arg20)\nv2 = []\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = []\nx3 = get_positive(arg30)\nv3 = []\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "فہرست میں صرف مثبت نمبر واپس کریں۔ \n>>> مثبت حاصل کریں ([-1, 2,-4, 5, 6]) \n[2، 5، 6] \n>>> مثبت حاصل کریں ([5، 3،-5، 2،-3، 3، 9، 0، 123، 1،-10]) \n[5، 3، 2، 3، 9، 123، 1]", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/9", "entry_point": "is_prime", "test": "\n\narg00 = 6\nx0 = is_prime(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 101\nx1 = is_prime(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 11\nx2 = is_prime(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 13441\nx3 = is_prime(arg30)\nv3 = true\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 61\nx4 = is_prime(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 4\nx5 = is_prime(arg50)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 1\nx6 = is_prime(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 5\nx7 = is_prime(arg70)\nv7 = true\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 11\nx8 = is_prime(arg80)\nv8 = true\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 17\nx9 = is_prime(arg90)\nv9 = true\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = 85\nx10 = is_prime(arg100)\nv10 = false\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = 77\nx11 = is_prime(arg110)\nv11 = false\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = 255379\nx12 = is_prime(arg120)\nv12 = false\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\n", "description": "اگر دیا ہوا نمبر پرائم ہے تو سچ واپس کریں، اور بصورت دیگر غلط۔ \n>>> is _ Prime (6) \nجھوٹا۔ \n>>> is _ Prime (101) \nسچ ہے۔ \n>>> is _ Prime (11) \nسچ ہے۔ \n>>> is _ Prime (13441) \nسچ ہے۔ \n>>> is _ Prime (61) \nسچ ہے۔ \n>>> is _ پرائم ہے (4) \nجھوٹا۔ \n>>> is _ Prime (1) \nجھوٹا۔", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/10", "entry_point": "unique", "test": "\n\narg00 = [5, 3, 5, 2, 3, 3, 9, 0, 123]\nx0 = unique(arg00)\nv0 = [0, 2, 3, 5, 9, 123]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\n", "description": "فہرست میں ترتیب شدہ منفرد عناصر کو واپس کریں \n>>> منفرد ([5، 3، 5، 2، 3، 3، 9، 0، 123]) \n[0، 2، 3، 5، 9، 123]", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/11", "entry_point": "prime_fib", "test": "\n\narg00 = 1\nx0 = prime_fib(arg00)\nv0 = 2\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 2\nx1 = prime_fib(arg10)\nv1 = 3\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 3\nx2 = prime_fib(arg20)\nv2 = 5\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 4\nx3 = prime_fib(arg30)\nv3 = 13\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 5\nx4 = prime_fib(arg40)\nv4 = 89\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 6\nx5 = prime_fib(arg50)\nv5 = 233\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 7\nx6 = prime_fib(arg60)\nv6 = 1597\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 8\nx7 = prime_fib(arg70)\nv7 = 28657\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 9\nx8 = prime_fib(arg80)\nv8 = 514229\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 10\nx9 = prime_fib(arg90)\nv9 = 433494437\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\n", "description": "پرائم _ فائب n-th نمبر واپس کرتا ہے جو کہ فبونیکی نمبر ہے اور یہ بھی پرائم ہے۔ \n>>> پرائم _ فائب (1) \n2. \n>>> پرائم _ فائب (2) \n3 \n>>> پرائم _ فائب (3) \n5. \n>>> پرائم _ فائب (4) \n13 \n>>> پرائم _ فائب (5) \n89", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/12", "entry_point": "triples_sum_to_zero", "test": "\n\narg00 = [1, 3, 5, 0]\nx0 = triples_sum_to_zero(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 3, 5, -1]\nx1 = triples_sum_to_zero(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 3, -2, 1]\nx2 = triples_sum_to_zero(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1, 2, 3, 7]\nx3 = triples_sum_to_zero(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 2, 5, 7]\nx4 = triples_sum_to_zero(arg40)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [2, 4, -5, 3, 9, 7]\nx5 = triples_sum_to_zero(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [1]\nx6 = triples_sum_to_zero(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [1, 3, 5, -100]\nx7 = triples_sum_to_zero(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [100, 3, 5, -100]\nx8 = triples_sum_to_zero(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "ٹرپل _ سم _ ٹو _ زیرو انٹیجرز کی فہرست کو ان پٹ کے طور پر لیتا ہے۔ \nیہ سچ واپس کرتا ہے اگر فہرست میں تین الگ الگ عناصر ہیں \nصفر کا مجموعہ، اور بصورت دیگر غلط۔ \n\n>>> ٹرپل _ سم _ ٹو _ زیرو ([1، 3، 5، 0]) \nجھوٹا۔ \n>>> ٹرپل _ سم _ ٹو _ زیرو ([1، 3،-2، 1]) \nسچ ہے۔ \n>>> ٹرپل _ سم _ ٹو _ زیرو ([1، 2، 3، 7]) \nجھوٹا۔ \n>>> ٹرپل _ سم _ ٹو _ زیرو ([2، 4،-5، 3، 9، 7]) \nسچ ہے۔ \n>>> ٹرپل _ سم _ سے _ صفر ([1]) \nجھوٹا۔", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/13", "entry_point": "pairs_sum_to_zero", "test": "\n\narg00 = [1, 3, 5, 0]\nx0 = pairs_sum_to_zero(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 3, -2, 1]\nx1 = pairs_sum_to_zero(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 2, 3, 7]\nx2 = pairs_sum_to_zero(arg20)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [2, 4, -5, 3, 5, 7]\nx3 = pairs_sum_to_zero(arg30)\nv3 = true\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1]\nx4 = pairs_sum_to_zero(arg40)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [-3, 9, -1, 3, 2, 30]\nx5 = pairs_sum_to_zero(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [-3, 9, -1, 3, 2, 31]\nx6 = pairs_sum_to_zero(arg60)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [-3, 9, -1, 4, 2, 30]\nx7 = pairs_sum_to_zero(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [-3, 9, -1, 4, 2, 31]\nx8 = pairs_sum_to_zero(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "pair _ sum _ to _ zero ان پٹ کے طور پر انٹیجرز کی فہرست لیتا ہے۔ \nاگر فہرست میں دو الگ الگ عناصر ہیں تو یہ سچ واپس کرتا ہے \nصفر کا مجموعہ، اور بصورت دیگر غلط۔ \n>>> جوڑے _ سم _ سے _ صفر ([1، 3، 5، 0]) \nجھوٹا۔ \n>>> جوڑے _ سم _ سے _ صفر ([1، 3،-2، 1]) \nجھوٹا۔ \n>>> جوڑے _ سم _ سے _ صفر ([1، 2، 3، 7]) \nجھوٹا۔ \n>>> جوڑے _ سم _ سے _ صفر ([2، 4،-5، 3، 5، 7]) \nسچ ہے۔ \n>>> جوڑے _ سم _ سے _ صفر ([1]) \nجھوٹا۔", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/14", "entry_point": "fib4", "test": "\n\narg00 = 5\nx0 = fib4(arg00)\nv0 = 4\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 8\nx1 = fib4(arg10)\nv1 = 28\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 10\nx2 = fib4(arg20)\nv2 = 104\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 12\nx3 = fib4(arg30)\nv3 = 386\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "فب 4 نمبر کی ترتیب فبونیکی سیکونیس سے ملتی جلتی ایک ترتیب ہے جس کی تعریف اس طرح کی گئی ہے: \nfib4 (0)-> 0 \nfib4 (1)-> 0 \nفائبر 4 (2)-> 2 \nfib4 (3)-> 0 \nfib4 (n)-> fib4 (n-1) + fib4 (n-2) + fib4 (n-3) + fib4 (n-4)۔ \nبراہ کرم فائب 4 نمبر کی ترتیب کے n-th عنصر کو مؤثر طریقے سے شمار کرنے کے لیے فنکشن لکھیں۔ ریکرشن کا استعمال نہ کریں۔ \n>>> فب 4 (5) \n4. \n>>> فب 4 (6) \n8. \n>>> فب 4 (7) \n14", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/15", "entry_point": "median", "test": "\n\narg00 = [3, 1, 2, 4, 5]\nx0 = median(arg00)\nv0 = 3\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [-10, 4, 6, 1000, 10, 20]\nx1 = median(arg10)\nv1 = 8.0\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [5]\nx2 = median(arg20)\nv2 = 5\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [6, 5]\nx3 = median(arg30)\nv3 = 5.5\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [8, 1, 3, 9, 9, 2, 7]\nx4 = median(arg40)\nv4 = 7\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "فہرست ایل میں عناصر کا میڈین واپس کریں۔ \n>>> میڈین ([3، 1، 2، 4، 5]) \n3 \n>>> میڈین ([-10، 4، 6، 1000، 10، 20]) \n15. 0", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/16", "entry_point": "is_palindrome", "test": "\n\narg00 = \"\"\nx0 = is_palindrome(arg00)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"aba\"\nx1 = is_palindrome(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"aaaaa\"\nx2 = is_palindrome(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"zbcd\"\nx3 = is_palindrome(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"xywyx\"\nx4 = is_palindrome(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"xywyz\"\nx5 = is_palindrome(arg50)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"xywzx\"\nx6 = is_palindrome(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "چیک کرتا ہے کہ آیا دی گئی سٹرنگ پیلینڈروم ہے \n>>> is _ palindrom (\") ہے \nسچ ہے۔ \n>>> is _ palindrom ('ابا') ہے \nسچ ہے۔ \n>>> is _ palindrom ('aaaaa') ہے \nسچ ہے۔ \n>>> is _ palindrom ('zbcd') ہے \nجھوٹا۔", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/17", "entry_point": "remove_vowels", "test": "\n\narg00 = \"\"\nx0 = remove_vowels(arg00)\nv0 = \"\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"abcdef\\nghijklm\"\nx1 = remove_vowels(arg10)\nv1 = \"bcdf\\nghjklm\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"fedcba\"\nx2 = remove_vowels(arg20)\nv2 = \"fdcb\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"eeeee\"\nx3 = remove_vowels(arg30)\nv3 = \"\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"acBAA\"\nx4 = remove_vowels(arg40)\nv4 = \"cB\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"EcBOO\"\nx5 = remove_vowels(arg50)\nv5 = \"cB\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"ybcd\"\nx6 = remove_vowels(arg60)\nv6 = \"ybcd\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "ہٹائیں _ سر ایک فنکشن ہے جو سٹرنگ لیتا ہے اور بغیر سروں کے سٹرنگ واپس کرتا ہے۔ \n>>> سروں کو ہٹا دیں (\") \n\"\n>>> سروں کو ہٹائیں (\"abcdef\\nghijklm\") \n'بی سی ڈی ایف\\این جی ایچ کے ایل ایم'\n>>> سروں کو ہٹا دیں ('اے بی سی ڈی ایف') \n'بی سی ڈی ایف'\n>>> سروں کو ہٹائیں ('aaaaaa') \n\"\n>>> سر ہٹائیں ('آبا') \n'بی'\n>>> سر ہٹائیں ('zbcd') \n'زیز بی سی ڈی'", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/18", "entry_point": "below_threshold", "test": "\n\narg00 = [1, 2, 4, 10]\narg01 = 100\nx0 = below_threshold(arg00, arg01)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 20, 4, 10]\narg11 = 5\nx1 = below_threshold(arg10, arg11)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 20, 4, 10]\narg21 = 21\nx2 = below_threshold(arg20, arg21)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1, 20, 4, 10]\narg31 = 22\nx3 = below_threshold(arg30, arg31)\nv3 = true\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 8, 4, 10]\narg41 = 11\nx4 = below_threshold(arg40, arg41)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [1, 8, 4, 10]\narg51 = 10\nx5 = below_threshold(arg50, arg51)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "اگر فہرست l میں موجود تمام اعداد حد t سے نیچے ہیں تو درست واپس کریں۔ \n>>> نیچے _ حد ([1، 2، 4، 10]، 100) \nسچ ہے۔ \n>>> نیچے _ حد ([1، 20، 4، 10]، 5) \nجھوٹا۔", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/19", "entry_point": "add", "test": "\n\narg00 = 0\narg01 = 1\nx0 = add(arg00, arg01)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 1\narg11 = 0\nx1 = add(arg10, arg11)\nv1 = 1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 2\narg21 = 3\nx2 = add(arg20, arg21)\nv2 = 5\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 5\narg31 = 7\nx3 = add(arg30, arg31)\nv3 = 12\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 7\narg41 = 5\nx4 = add(arg40, arg41)\nv4 = 12\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 572\narg51 = 725\nx5 = add(arg50, arg51)\nv5 = 1297\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 51\narg61 = 804\nx6 = add(arg60, arg61)\nv6 = 855\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 645\narg71 = 96\nx7 = add(arg70, arg71)\nv7 = 741\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 712\narg81 = 853\nx8 = add(arg80, arg81)\nv8 = 1565\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 223\narg91 = 101\nx9 = add(arg90, arg91)\nv9 = 324\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = 76\narg101 = 29\nx10 = add(arg100, arg101)\nv10 = 105\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = 416\narg111 = 149\nx11 = add(arg110, arg111)\nv11 = 565\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = 145\narg121 = 409\nx12 = add(arg120, arg121)\nv12 = 554\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\narg130 = 535\narg131 = 430\nx13 = add(arg130, arg131)\nv13 = 965\nif x13 != v13\n    raise StandardError, \"Error at test case 14\"\nend\n\narg140 = 118\narg141 = 303\nx14 = add(arg140, arg141)\nv14 = 421\nif x14 != v14\n    raise StandardError, \"Error at test case 15\"\nend\n\narg150 = 287\narg151 = 94\nx15 = add(arg150, arg151)\nv15 = 381\nif x15 != v15\n    raise StandardError, \"Error at test case 16\"\nend\n\narg160 = 768\narg161 = 257\nx16 = add(arg160, arg161)\nv16 = 1025\nif x16 != v16\n    raise StandardError, \"Error at test case 17\"\nend\n\narg170 = 421\narg171 = 677\nx17 = add(arg170, arg171)\nv17 = 1098\nif x17 != v17\n    raise StandardError, \"Error at test case 18\"\nend\n\narg180 = 802\narg181 = 814\nx18 = add(arg180, arg181)\nv18 = 1616\nif x18 != v18\n    raise StandardError, \"Error at test case 19\"\nend\n\narg190 = 510\narg191 = 922\nx19 = add(arg190, arg191)\nv19 = 1432\nif x19 != v19\n    raise StandardError, \"Error at test case 20\"\nend\n\narg200 = 345\narg201 = 819\nx20 = add(arg200, arg201)\nv20 = 1164\nif x20 != v20\n    raise StandardError, \"Error at test case 21\"\nend\n\narg210 = 895\narg211 = 436\nx21 = add(arg210, arg211)\nv21 = 1331\nif x21 != v21\n    raise StandardError, \"Error at test case 22\"\nend\n\narg220 = 123\narg221 = 424\nx22 = add(arg220, arg221)\nv22 = 547\nif x22 != v22\n    raise StandardError, \"Error at test case 23\"\nend\n\narg230 = 923\narg231 = 245\nx23 = add(arg230, arg231)\nv23 = 1168\nif x23 != v23\n    raise StandardError, \"Error at test case 24\"\nend\n\narg240 = 23\narg241 = 438\nx24 = add(arg240, arg241)\nv24 = 461\nif x24 != v24\n    raise StandardError, \"Error at test case 25\"\nend\n\narg250 = 565\narg251 = 133\nx25 = add(arg250, arg251)\nv25 = 698\nif x25 != v25\n    raise StandardError, \"Error at test case 26\"\nend\n\narg260 = 945\narg261 = 925\nx26 = add(arg260, arg261)\nv26 = 1870\nif x26 != v26\n    raise StandardError, \"Error at test case 27\"\nend\n\narg270 = 261\narg271 = 983\nx27 = add(arg270, arg271)\nv27 = 1244\nif x27 != v27\n    raise StandardError, \"Error at test case 28\"\nend\n\narg280 = 139\narg281 = 577\nx28 = add(arg280, arg281)\nv28 = 716\nif x28 != v28\n    raise StandardError, \"Error at test case 29\"\nend\n\narg290 = 763\narg291 = 178\nx29 = add(arg290, arg291)\nv29 = 941\nif x29 != v29\n    raise StandardError, \"Error at test case 30\"\nend\n\narg300 = 147\narg301 = 892\nx30 = add(arg300, arg301)\nv30 = 1039\nif x30 != v30\n    raise StandardError, \"Error at test case 31\"\nend\n\narg310 = 436\narg311 = 402\nx31 = add(arg310, arg311)\nv31 = 838\nif x31 != v31\n    raise StandardError, \"Error at test case 32\"\nend\n\narg320 = 610\narg321 = 581\nx32 = add(arg320, arg321)\nv32 = 1191\nif x32 != v32\n    raise StandardError, \"Error at test case 33\"\nend\n\narg330 = 103\narg331 = 416\nx33 = add(arg330, arg331)\nv33 = 519\nif x33 != v33\n    raise StandardError, \"Error at test case 34\"\nend\n\narg340 = 339\narg341 = 990\nx34 = add(arg340, arg341)\nv34 = 1329\nif x34 != v34\n    raise StandardError, \"Error at test case 35\"\nend\n\narg350 = 130\narg351 = 504\nx35 = add(arg350, arg351)\nv35 = 634\nif x35 != v35\n    raise StandardError, \"Error at test case 36\"\nend\n\narg360 = 242\narg361 = 717\nx36 = add(arg360, arg361)\nv36 = 959\nif x36 != v36\n    raise StandardError, \"Error at test case 37\"\nend\n\narg370 = 562\narg371 = 110\nx37 = add(arg370, arg371)\nv37 = 672\nif x37 != v37\n    raise StandardError, \"Error at test case 38\"\nend\n\narg380 = 396\narg381 = 909\nx38 = add(arg380, arg381)\nv38 = 1305\nif x38 != v38\n    raise StandardError, \"Error at test case 39\"\nend\n\narg390 = 887\narg391 = 703\nx39 = add(arg390, arg391)\nv39 = 1590\nif x39 != v39\n    raise StandardError, \"Error at test case 40\"\nend\n\narg400 = 870\narg401 = 551\nx40 = add(arg400, arg401)\nv40 = 1421\nif x40 != v40\n    raise StandardError, \"Error at test case 41\"\nend\n\narg410 = 422\narg411 = 391\nx41 = add(arg410, arg411)\nv41 = 813\nif x41 != v41\n    raise StandardError, \"Error at test case 42\"\nend\n\narg420 = 299\narg421 = 505\nx42 = add(arg420, arg421)\nv42 = 804\nif x42 != v42\n    raise StandardError, \"Error at test case 43\"\nend\n\narg430 = 346\narg431 = 56\nx43 = add(arg430, arg431)\nv43 = 402\nif x43 != v43\n    raise StandardError, \"Error at test case 44\"\nend\n\narg440 = 36\narg441 = 706\nx44 = add(arg440, arg441)\nv44 = 742\nif x44 != v44\n    raise StandardError, \"Error at test case 45\"\nend\n\narg450 = 738\narg451 = 411\nx45 = add(arg450, arg451)\nv45 = 1149\nif x45 != v45\n    raise StandardError, \"Error at test case 46\"\nend\n\narg460 = 679\narg461 = 87\nx46 = add(arg460, arg461)\nv46 = 766\nif x46 != v46\n    raise StandardError, \"Error at test case 47\"\nend\n\narg470 = 25\narg471 = 303\nx47 = add(arg470, arg471)\nv47 = 328\nif x47 != v47\n    raise StandardError, \"Error at test case 48\"\nend\n\narg480 = 161\narg481 = 612\nx48 = add(arg480, arg481)\nv48 = 773\nif x48 != v48\n    raise StandardError, \"Error at test case 49\"\nend\n\narg490 = 306\narg491 = 841\nx49 = add(arg490, arg491)\nv49 = 1147\nif x49 != v49\n    raise StandardError, \"Error at test case 50\"\nend\n\narg500 = 973\narg501 = 411\nx50 = add(arg500, arg501)\nv50 = 1384\nif x50 != v50\n    raise StandardError, \"Error at test case 51\"\nend\n\narg510 = 711\narg511 = 157\nx51 = add(arg510, arg511)\nv51 = 868\nif x51 != v51\n    raise StandardError, \"Error at test case 52\"\nend\n\narg520 = 471\narg521 = 27\nx52 = add(arg520, arg521)\nv52 = 498\nif x52 != v52\n    raise StandardError, \"Error at test case 53\"\nend\n\narg530 = 714\narg531 = 792\nx53 = add(arg530, arg531)\nv53 = 1506\nif x53 != v53\n    raise StandardError, \"Error at test case 54\"\nend\n\narg540 = 38\narg541 = 206\nx54 = add(arg540, arg541)\nv54 = 244\nif x54 != v54\n    raise StandardError, \"Error at test case 55\"\nend\n\narg550 = 907\narg551 = 343\nx55 = add(arg550, arg551)\nv55 = 1250\nif x55 != v55\n    raise StandardError, \"Error at test case 56\"\nend\n\narg560 = 23\narg561 = 760\nx56 = add(arg560, arg561)\nv56 = 783\nif x56 != v56\n    raise StandardError, \"Error at test case 57\"\nend\n\narg570 = 524\narg571 = 859\nx57 = add(arg570, arg571)\nv57 = 1383\nif x57 != v57\n    raise StandardError, \"Error at test case 58\"\nend\n\narg580 = 30\narg581 = 529\nx58 = add(arg580, arg581)\nv58 = 559\nif x58 != v58\n    raise StandardError, \"Error at test case 59\"\nend\n\narg590 = 341\narg591 = 691\nx59 = add(arg590, arg591)\nv59 = 1032\nif x59 != v59\n    raise StandardError, \"Error at test case 60\"\nend\n\narg600 = 167\narg601 = 729\nx60 = add(arg600, arg601)\nv60 = 896\nif x60 != v60\n    raise StandardError, \"Error at test case 61\"\nend\n\narg610 = 636\narg611 = 289\nx61 = add(arg610, arg611)\nv61 = 925\nif x61 != v61\n    raise StandardError, \"Error at test case 62\"\nend\n\narg620 = 503\narg621 = 144\nx62 = add(arg620, arg621)\nv62 = 647\nif x62 != v62\n    raise StandardError, \"Error at test case 63\"\nend\n\narg630 = 51\narg631 = 985\nx63 = add(arg630, arg631)\nv63 = 1036\nif x63 != v63\n    raise StandardError, \"Error at test case 64\"\nend\n\narg640 = 287\narg641 = 149\nx64 = add(arg640, arg641)\nv64 = 436\nif x64 != v64\n    raise StandardError, \"Error at test case 65\"\nend\n\narg650 = 659\narg651 = 75\nx65 = add(arg650, arg651)\nv65 = 734\nif x65 != v65\n    raise StandardError, \"Error at test case 66\"\nend\n\narg660 = 462\narg661 = 797\nx66 = add(arg660, arg661)\nv66 = 1259\nif x66 != v66\n    raise StandardError, \"Error at test case 67\"\nend\n\narg670 = 406\narg671 = 141\nx67 = add(arg670, arg671)\nv67 = 547\nif x67 != v67\n    raise StandardError, \"Error at test case 68\"\nend\n\narg680 = 106\narg681 = 44\nx68 = add(arg680, arg681)\nv68 = 150\nif x68 != v68\n    raise StandardError, \"Error at test case 69\"\nend\n\narg690 = 300\narg691 = 934\nx69 = add(arg690, arg691)\nv69 = 1234\nif x69 != v69\n    raise StandardError, \"Error at test case 70\"\nend\n\narg700 = 471\narg701 = 524\nx70 = add(arg700, arg701)\nv70 = 995\nif x70 != v70\n    raise StandardError, \"Error at test case 71\"\nend\n\narg710 = 122\narg711 = 429\nx71 = add(arg710, arg711)\nv71 = 551\nif x71 != v71\n    raise StandardError, \"Error at test case 72\"\nend\n\narg720 = 735\narg721 = 195\nx72 = add(arg720, arg721)\nv72 = 930\nif x72 != v72\n    raise StandardError, \"Error at test case 73\"\nend\n\narg730 = 335\narg731 = 484\nx73 = add(arg730, arg731)\nv73 = 819\nif x73 != v73\n    raise StandardError, \"Error at test case 74\"\nend\n\narg740 = 28\narg741 = 809\nx74 = add(arg740, arg741)\nv74 = 837\nif x74 != v74\n    raise StandardError, \"Error at test case 75\"\nend\n\narg750 = 430\narg751 = 20\nx75 = add(arg750, arg751)\nv75 = 450\nif x75 != v75\n    raise StandardError, \"Error at test case 76\"\nend\n\narg760 = 916\narg761 = 635\nx76 = add(arg760, arg761)\nv76 = 1551\nif x76 != v76\n    raise StandardError, \"Error at test case 77\"\nend\n\narg770 = 301\narg771 = 999\nx77 = add(arg770, arg771)\nv77 = 1300\nif x77 != v77\n    raise StandardError, \"Error at test case 78\"\nend\n\narg780 = 454\narg781 = 466\nx78 = add(arg780, arg781)\nv78 = 920\nif x78 != v78\n    raise StandardError, \"Error at test case 79\"\nend\n\narg790 = 905\narg791 = 259\nx79 = add(arg790, arg791)\nv79 = 1164\nif x79 != v79\n    raise StandardError, \"Error at test case 80\"\nend\n\narg800 = 168\narg801 = 205\nx80 = add(arg800, arg801)\nv80 = 373\nif x80 != v80\n    raise StandardError, \"Error at test case 81\"\nend\n\narg810 = 570\narg811 = 434\nx81 = add(arg810, arg811)\nv81 = 1004\nif x81 != v81\n    raise StandardError, \"Error at test case 82\"\nend\n\narg820 = 64\narg821 = 959\nx82 = add(arg820, arg821)\nv82 = 1023\nif x82 != v82\n    raise StandardError, \"Error at test case 83\"\nend\n\narg830 = 957\narg831 = 510\nx83 = add(arg830, arg831)\nv83 = 1467\nif x83 != v83\n    raise StandardError, \"Error at test case 84\"\nend\n\narg840 = 722\narg841 = 598\nx84 = add(arg840, arg841)\nv84 = 1320\nif x84 != v84\n    raise StandardError, \"Error at test case 85\"\nend\n\narg850 = 770\narg851 = 226\nx85 = add(arg850, arg851)\nv85 = 996\nif x85 != v85\n    raise StandardError, \"Error at test case 86\"\nend\n\narg860 = 579\narg861 = 66\nx86 = add(arg860, arg861)\nv86 = 645\nif x86 != v86\n    raise StandardError, \"Error at test case 87\"\nend\n\narg870 = 117\narg871 = 674\nx87 = add(arg870, arg871)\nv87 = 791\nif x87 != v87\n    raise StandardError, \"Error at test case 88\"\nend\n\narg880 = 530\narg881 = 30\nx88 = add(arg880, arg881)\nv88 = 560\nif x88 != v88\n    raise StandardError, \"Error at test case 89\"\nend\n\narg890 = 776\narg891 = 345\nx89 = add(arg890, arg891)\nv89 = 1121\nif x89 != v89\n    raise StandardError, \"Error at test case 90\"\nend\n\narg900 = 327\narg901 = 389\nx90 = add(arg900, arg901)\nv90 = 716\nif x90 != v90\n    raise StandardError, \"Error at test case 91\"\nend\n\narg910 = 596\narg911 = 12\nx91 = add(arg910, arg911)\nv91 = 608\nif x91 != v91\n    raise StandardError, \"Error at test case 92\"\nend\n\narg920 = 599\narg921 = 511\nx92 = add(arg920, arg921)\nv92 = 1110\nif x92 != v92\n    raise StandardError, \"Error at test case 93\"\nend\n\narg930 = 936\narg931 = 476\nx93 = add(arg930, arg931)\nv93 = 1412\nif x93 != v93\n    raise StandardError, \"Error at test case 94\"\nend\n\narg940 = 461\narg941 = 14\nx94 = add(arg940, arg941)\nv94 = 475\nif x94 != v94\n    raise StandardError, \"Error at test case 95\"\nend\n\narg950 = 966\narg951 = 157\nx95 = add(arg950, arg951)\nv95 = 1123\nif x95 != v95\n    raise StandardError, \"Error at test case 96\"\nend\n\narg960 = 326\narg961 = 91\nx96 = add(arg960, arg961)\nv96 = 417\nif x96 != v96\n    raise StandardError, \"Error at test case 97\"\nend\n\narg970 = 392\narg971 = 455\nx97 = add(arg970, arg971)\nv97 = 847\nif x97 != v97\n    raise StandardError, \"Error at test case 98\"\nend\n\narg980 = 446\narg981 = 477\nx98 = add(arg980, arg981)\nv98 = 923\nif x98 != v98\n    raise StandardError, \"Error at test case 99\"\nend\n\narg990 = 324\narg991 = 860\nx99 = add(arg990, arg991)\nv99 = 1184\nif x99 != v99\n    raise StandardError, \"Error at test case 100\"\nend\n\narg1000 = 945\narg1001 = 85\nx100 = add(arg1000, arg1001)\nv100 = 1030\nif x100 != v100\n    raise StandardError, \"Error at test case 101\"\nend\n\narg1010 = 886\narg1011 = 582\nx101 = add(arg1010, arg1011)\nv101 = 1468\nif x101 != v101\n    raise StandardError, \"Error at test case 102\"\nend\n\narg1020 = 886\narg1021 = 712\nx102 = add(arg1020, arg1021)\nv102 = 1598\nif x102 != v102\n    raise StandardError, \"Error at test case 103\"\nend\n\narg1030 = 842\narg1031 = 953\nx103 = add(arg1030, arg1031)\nv103 = 1795\nif x103 != v103\n    raise StandardError, \"Error at test case 104\"\nend\n\n", "description": "دو اعداد x اور y شامل کریں \n>>> شامل کریں (2، 3) \n5. \n>>> شامل کریں (5، 7) \n12", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/20", "entry_point": "same_chars", "test": "\n\narg00 = \"eabcdzzzz\"\narg01 = \"dddzzzzzzzddeddabc\"\nx0 = same_chars(arg00, arg01)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"abcd\"\narg11 = \"dddddddabc\"\nx1 = same_chars(arg10, arg11)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"dddddddabc\"\narg21 = \"abcd\"\nx2 = same_chars(arg20, arg21)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"eabcd\"\narg31 = \"dddddddabc\"\nx3 = same_chars(arg30, arg31)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"abcd\"\narg41 = \"dddddddabcf\"\nx4 = same_chars(arg40, arg41)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"eabcdzzzz\"\narg51 = \"dddzzzzzzzddddabc\"\nx5 = same_chars(arg50, arg51)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"aabb\"\narg61 = \"aaccc\"\nx6 = same_chars(arg60, arg61)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "چیک کریں کہ آیا دو الفاظ میں ایک جیسے حروف ہیں۔ \n>>> وہی _ چارز ('eabcdzzzz'،'dddzzzzzuddeddabc') \nسچ ہے۔ \n>>> ایک جیسے حروف ('اے بی سی ڈی'،'ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی \nسچ ہے۔ \n>>> وہی _ چارس ('ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی اے بی سی'،'اے بی سی ڈی') \nسچ ہے۔ \n>>> ایک جیسے حروف ('eabcd'،'ddddddabc') \nجھوٹا۔ \n>>> ایک جیسے حروف ('اے بی سی ڈی'،'ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی \nجھوٹا۔ \n>>> وہی _ چارز ('eabcdzzzz'،'dddzzzzzdddddabc') \nجھوٹا۔", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/21", "entry_point": "fib", "test": "\n\narg00 = 10\nx0 = fib(arg00)\nv0 = 55\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 1\nx1 = fib(arg10)\nv1 = 1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 8\nx2 = fib(arg20)\nv2 = 21\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 11\nx3 = fib(arg30)\nv3 = 89\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 12\nx4 = fib(arg40)\nv4 = 144\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "n-th فبونیکی نمبر واپس کریں۔ \n>>> فائبر (10) \n55 \n>>> فائبر (1) \n1. \n>>> فائبر (8) \n21", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/22", "entry_point": "common", "test": "\n\narg00 = [1, 4, 3, 34, 653, 2, 5]\narg01 = [5, 7, 1, 5, 9, 653, 121]\nx0 = common(arg00, arg01)\nv0 = [1, 5, 653]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [5, 3, 2, 8]\narg11 = [3, 2]\nx1 = common(arg10, arg11)\nv1 = [2, 3]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [4, 3, 2, 8]\narg21 = [3, 2, 4]\nx2 = common(arg20, arg21)\nv2 = [2, 3, 4]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [4, 3, 2, 8]\narg31 = []\nx3 = common(arg30, arg31)\nv3 = []\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "واپسی نے دو فہرستوں کے لیے منفرد مشترکہ عناصر کو ترتیب دیا۔ \n>>> عام ([1، 4، 3، 34، 653، 2، 5]، [5، 7، 1، 5، 9، 653، 121]) \n[1، 5، 653] \n>>> عام ([5، 3، 2، 8]، [3، 2]) \n[2، 3]", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/23", "entry_point": "largest_prime_factor", "test": "\n\narg00 = 15\nx0 = largest_prime_factor(arg00)\nv0 = 5\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 27\nx1 = largest_prime_factor(arg10)\nv1 = 3\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 63\nx2 = largest_prime_factor(arg20)\nv2 = 7\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 330\nx3 = largest_prime_factor(arg30)\nv3 = 11\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 13195\nx4 = largest_prime_factor(arg40)\nv4 = 29\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "n کا سب سے بڑا پرائم فیکٹر واپس کریں۔ فرض کریں کہ n> 1 ہے اور یہ پرائم نہیں ہے۔ \n>>> سب سے بڑا _ پرائم _ فیکٹر (13195) \n29 \n>>> سب سے بڑا _ پرائم _ فیکٹر (2048) \n2.", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/24", "entry_point": "sum_to_n", "test": "\n\narg00 = 1\nx0 = sum_to_n(arg00)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 6\nx1 = sum_to_n(arg10)\nv1 = 21\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 11\nx2 = sum_to_n(arg20)\nv2 = 66\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 30\nx3 = sum_to_n(arg30)\nv3 = 465\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 100\nx4 = sum_to_n(arg40)\nv4 = 5050\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "sum _ to _ n ایک فنکشن ہے جو 1 سے n تک کے نمبروں کا مجموعہ ہے۔ \n>>> sum _ to _ n (30) \n465 \n>>> sum _ to _ n (100) \n5050 \n>>> sum _ to _ n (5) \n15 \n>>> sum _ to _ n (10) \n55 \n>>> sum _ to _ n (1) \n1.", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/25", "entry_point": "derivative", "test": "\n\narg00 = [3, 1, 2, 4, 5]\nx0 = derivative(arg00)\nv0 = [1, 4, 12, 20]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 2, 3]\nx1 = derivative(arg10)\nv1 = [2, 6]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [3, 2, 1]\nx2 = derivative(arg20)\nv2 = [2, 2]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [3, 2, 1, 0, 4]\nx3 = derivative(arg30)\nv3 = [2, 2, 0, 16]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1]\nx4 = derivative(arg40)\nv4 = []\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "xs کسی کثیر الجہتی کے کوفشنٹس کی نمائندگی کرتا ہے۔ \nxs [0] + xs [1] * x + xs [2] * x ^ 2 +.... \nاس کثیر الجہتی کا اسی شکل میں مشتق واپس کریں۔ \n>>> مشتق ([3، 1، 2، 4، 5]) \n[1، 4، 12، 20] \n>>> مشتق ([1، 2، 3]) \n[2، 6]", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/26", "entry_point": "fibfib", "test": "\n\narg00 = 2\nx0 = fibfib(arg00)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 1\nx1 = fibfib(arg10)\nv1 = 0\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 5\nx2 = fibfib(arg20)\nv2 = 4\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 8\nx3 = fibfib(arg30)\nv3 = 24\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 10\nx4 = fibfib(arg40)\nv4 = 81\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 12\nx5 = fibfib(arg50)\nv5 = 274\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 14\nx6 = fibfib(arg60)\nv6 = 927\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "فب فب نمبر سیکوینس فبونیکی سیکوینس سے ملتی جلتی ترتیب ہے جس کی تعریف اس طرح کی گئی ہے: \nfibfib (0) = = 0 \nfibfib (1) = = 0 \nفبفب (2) = = 1 \nfibfib (n) = = fibfib (n-1) + fibfib (n-2) + fibfib (n-3)۔ \nبراہ کرم فائب فائیب نمبر کی ترتیب کے n-th عنصر کو مؤثر طریقے سے شمار کرنے کے لیے ایک فنکشن لکھیں۔ \n>>> فبفب (1) \n0 \n>>> فبفب (5) \n4. \n>>> فبفب (8) \n24", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/27", "entry_point": "vowels_count", "test": "\n\narg00 = \"abcde\"\nx0 = vowels_count(arg00)\nv0 = 2\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Alone\"\nx1 = vowels_count(arg10)\nv1 = 3\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"key\"\nx2 = vowels_count(arg20)\nv2 = 2\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"bye\"\nx3 = vowels_count(arg30)\nv3 = 1\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"keY\"\nx4 = vowels_count(arg40)\nv4 = 2\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"bYe\"\nx5 = vowels_count(arg50)\nv5 = 1\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"ACEDY\"\nx6 = vowels_count(arg60)\nv6 = 3\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "ایک فنکشن ویولز _ کاؤنٹ لکھیں جو ایک سٹرنگ کی نمائندگی کرتا ہے \nایک لفظ بطور ان پٹ اور سٹرنگ میں سروں کی تعداد واپس کرتا ہے۔ \nاس صورت میں آوازیں'a'،'e'،'i'،'o'،'u'ہیں۔ یہاں،'y'بھی a ہے۔ \nسر، لیکن صرف اس صورت میں جب یہ دیئے گئے لفظ کے آخر میں ہو۔ \n\nمثال: \n>>> ویولز _ کاؤنٹ (\"اے بی سی ڈی ای\") \n2. \n>>> ویولز _ کاؤنٹ (\"ACEDY\") \n3", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/28", "entry_point": "search", "test": "\n\narg00 = [5, 5, 5, 5, 1]\nx0 = search(arg00)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [4, 1, 4, 1, 4, 4]\nx1 = search(arg10)\nv1 = 4\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [3, 3]\nx2 = search(arg20)\nv2 = -1\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [8, 8, 8, 8, 8, 8, 8, 8]\nx3 = search(arg30)\nv3 = 8\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [2, 3, 3, 2, 2]\nx4 = search(arg40)\nv4 = 2\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]\nx5 = search(arg50)\nv5 = 1\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [3, 2, 8, 2]\nx6 = search(arg60)\nv6 = 2\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]\nx7 = search(arg70)\nv7 = 1\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [8, 8, 3, 6, 5, 6, 4]\nx8 = search(arg80)\nv8 = -1\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = [6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]\nx9 = search(arg90)\nv9 = 1\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = [1, 9, 10, 1, 3]\nx10 = search(arg100)\nv10 = 1\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = [6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]\nx11 = search(arg110)\nv11 = 5\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = [1]\nx12 = search(arg120)\nv12 = 1\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\narg130 = [8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]\nx13 = search(arg130)\nv13 = 4\nif x13 != v13\n    raise StandardError, \"Error at test case 14\"\nend\n\narg140 = [2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]\nx14 = search(arg140)\nv14 = 2\nif x14 != v14\n    raise StandardError, \"Error at test case 15\"\nend\n\narg150 = [1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]\nx15 = search(arg150)\nv15 = 1\nif x15 != v15\n    raise StandardError, \"Error at test case 16\"\nend\n\narg160 = [9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]\nx16 = search(arg160)\nv16 = 4\nif x16 != v16\n    raise StandardError, \"Error at test case 17\"\nend\n\narg170 = [2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]\nx17 = search(arg170)\nv17 = 4\nif x17 != v17\n    raise StandardError, \"Error at test case 18\"\nend\n\narg180 = [9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]\nx18 = search(arg180)\nv18 = 2\nif x18 != v18\n    raise StandardError, \"Error at test case 19\"\nend\n\narg190 = [5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]\nx19 = search(arg190)\nv19 = -1\nif x19 != v19\n    raise StandardError, \"Error at test case 20\"\nend\n\narg200 = [10]\nx20 = search(arg200)\nv20 = -1\nif x20 != v20\n    raise StandardError, \"Error at test case 21\"\nend\n\narg210 = [9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]\nx21 = search(arg210)\nv21 = 2\nif x21 != v21\n    raise StandardError, \"Error at test case 22\"\nend\n\narg220 = [5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]\nx22 = search(arg220)\nv22 = 1\nif x22 != v22\n    raise StandardError, \"Error at test case 23\"\nend\n\narg230 = [7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]\nx23 = search(arg230)\nv23 = 1\nif x23 != v23\n    raise StandardError, \"Error at test case 24\"\nend\n\narg240 = [3, 10, 10, 9, 2]\nx24 = search(arg240)\nv24 = -1\nif x24 != v24\n    raise StandardError, \"Error at test case 25\"\nend\n\n", "description": "آپ کو مثبت انٹیجرز کی ایک خالی فہرست دی جاتی ہے۔ سب سے بڑا انٹیجر واپس کریں جو اس سے بڑا ہے۔ \nصفر، اور اس کی تعدد خود عدد کی قدر سے زیادہ یا اس کے برابر ہوتی ہے۔ \nکسی عدد کی تعدد وہ تعداد ہے جو فہرست میں ظاہر ہوتی ہے۔ \nاگر ایسی کوئی قیمت موجود نہیں ہے تو-1 واپس کریں۔ \nمثالیں: \nتلاش ([4، 1، 2، 2، 3، 1]) = = 2 \nتلاش ([1، 2، 2، 3، 3، 4، 4]) = = 3 \nتلاش ([5، 5، 4، 4، 4]) = =-1", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/29", "entry_point": "triangle_area", "test": "\n\narg00 = 3\narg01 = 4\narg02 = 5\nx0 = triangle_area(arg00, arg01, arg02)\nv0 = 6.0\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 1\narg11 = 2\narg12 = 10\nx1 = triangle_area(arg10, arg11, arg12)\nv1 = -1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 4\narg21 = 8\narg22 = 5\nx2 = triangle_area(arg20, arg21, arg22)\nv2 = 8.18\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 2\narg31 = 2\narg32 = 2\nx3 = triangle_area(arg30, arg31, arg32)\nv3 = 1.73\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 1\narg41 = 2\narg42 = 3\nx4 = triangle_area(arg40, arg41, arg42)\nv4 = -1\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 10\narg51 = 5\narg52 = 7\nx5 = triangle_area(arg50, arg51, arg52)\nv5 = 16.25\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 2\narg61 = 6\narg62 = 3\nx6 = triangle_area(arg60, arg61, arg62)\nv6 = -1\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 1\narg71 = 1\narg72 = 1\nx7 = triangle_area(arg70, arg71, arg72)\nv7 = 0.43\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 2\narg81 = 2\narg82 = 10\nx8 = triangle_area(arg80, arg81, arg82)\nv8 = -1\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "مثلث کے تینوں اطراف کی لمبائی کو دیکھتے ہوئے۔ کا رقبہ واپس کریں \nمثلث کو 2 اعشاریہ پوائنٹس پر گول کیا جاتا ہے اگر تینوں اطراف ایک درست مثلث بناتے ہیں۔ \nورنہ واپسی-1 \nتین اطراف ایک درست مثلث بناتے ہیں جب کسی بھی دو اطراف کا مجموعہ زیادہ ہوتا ہے \nتیسری طرف سے. \nمثال: \nمثلث _ رقبہ (3، 4، 5) = = 6 \nمثلث _ رقبہ (1، 2، 10) = =-1", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/30", "entry_point": "will_it_fly", "test": "\n\narg00 = [3, 2, 3]\narg01 = 9\nx0 = will_it_fly(arg00, arg01)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 2]\narg11 = 5\nx1 = will_it_fly(arg10, arg11)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [3]\narg21 = 5\nx2 = will_it_fly(arg20, arg21)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [3, 2, 3]\narg31 = 1\nx3 = will_it_fly(arg30, arg31)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 2, 3]\narg41 = 6\nx4 = will_it_fly(arg40, arg41)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [5]\narg51 = 5\nx5 = will_it_fly(arg50, arg51)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "ایک فنکشن لکھیں جو سچ کا جواب دے اگر آبجیکٹ q اڑ جائے گا، اور دوسری صورت میں غلط۔ \nآبجیکٹ q اڑ جائے گا اگر یہ متوازن ہو (یہ ایک پیلینڈرومک لسٹ ہے) اور اس کے عناصر کا مجموعہ زیادہ سے زیادہ ممکنہ وزن ڈبلیو سے کم یا اس کے برابر ہو۔ \n\nمثال: \nول _ اٹ _ فلائی ([1، 2]، 5) غلط \n#1 + 2 زیادہ سے زیادہ ممکنہ وزن سے کم ہے، لیکن یہ غیر متوازن ہے۔ \n\nول _ اٹ _ فلائی ([3، 2، 3]، 1) غلط \n#یہ متوازن ہے، لیکن 3 + 2 + 3 زیادہ سے زیادہ ممکنہ وزن سے زیادہ ہے۔ \n\nول _ اٹ _ فلائی ([3، 2، 3]، 9) سچ ہے \n#3 + 2 + 3 زیادہ سے زیادہ ممکنہ وزن سے کم ہے، اور یہ متوازن ہے۔ \n\nول _ اٹ _ فلائی ([3]، 5) سچ ہے \n#3 زیادہ سے زیادہ ممکنہ وزن سے کم ہے، اور یہ متوازن ہے۔", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/31", "entry_point": "is_multiply_prime", "test": "\n\narg00 = 5\nx0 = is_multiply_prime(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 30\nx1 = is_multiply_prime(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 8\nx2 = is_multiply_prime(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 10\nx3 = is_multiply_prime(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 125\nx4 = is_multiply_prime(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 105\nx5 = is_multiply_prime(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 126\nx6 = is_multiply_prime(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 729\nx7 = is_multiply_prime(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 891\nx8 = is_multiply_prime(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 1001\nx9 = is_multiply_prime(arg90)\nv9 = true\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\n", "description": "ایک فنکشن لکھیں جو درست واپسی کرے اگر دیا گیا نمبر 3 پرائم نمبروں کا ضرب ہے۔ \nاور بصورت دیگر غلط۔ \nیہ جاننا کہ (a) 100 سے کم ہے۔ \nمثال: \nکیا _ ضرب _ پرائم (30) = = درست ہے \n30 = 2 * 3 * 5", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/32", "entry_point": "decimal_to_binary", "test": "\n\narg00 = 0\nx0 = decimal_to_binary(arg00)\nv0 = \"db0db\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 32\nx1 = decimal_to_binary(arg10)\nv1 = \"db100000db\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 103\nx2 = decimal_to_binary(arg20)\nv2 = \"db1100111db\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 15\nx3 = decimal_to_binary(arg30)\nv3 = \"db1111db\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "آپ کو اعشاریہ شکل میں ایک نمبر دیا جائے گا اور آپ کا کام اسے اعشاریہ میں تبدیل کرنا ہے۔ \nبائنری فارمیٹ۔ فنکشن کو ایک سٹرنگ واپس کرنی چاہیے، جس میں ہر حرف بائنری کی نمائندگی کرتا ہے۔ \nنمبر۔ سٹرنگ میں ہر حرف'0'یا'1'ہوگا۔ \n\nسٹرنگ کے شروع میں اور آخر میں چند اضافی حروف'ڈی بی'ہوں گے۔ \nفارمیٹ میں مدد کے لیے اضافی حروف موجود ہیں۔ \n\nمثالیں: \nاعشاریہ _ سے _ بائنری (15) #\"db1111db\" واپس کرتا ہے \nاعشاریہ _ سے _ بائنری (32) #\"db100000db\" واپس کرتا ہے", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/33", "entry_point": "is_happy", "test": "\n\narg00 = \"a\"\nx0 = is_happy(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"aa\"\nx1 = is_happy(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"abcd\"\nx2 = is_happy(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"aabb\"\nx3 = is_happy(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"adb\"\nx4 = is_happy(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"xyy\"\nx5 = is_happy(arg50)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"iopaxpoi\"\nx6 = is_happy(arg60)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"iopaxioi\"\nx7 = is_happy(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\n", "description": "آپ کو ایک سٹرنگ s دی گئی ہے۔ \nآپ کا کام یہ چیک کرنا ہے کہ تار خوش ہے یا نہیں۔ \nایک تار خوش ہوتا ہے اگر اس کی لمبائی کم از کم 3 ہو اور ہر 3 مسلسل حروف الگ ہوں۔ \nمثال کے طور پر: \nخوش ہے (a) => غلط ہے \nخوش ہے (اے اے) => غلط ہے \nخوش ہے (اے بی سی ڈی) => سچ ہے \nخوش ہے (اے اے بی بی) => غلط \nخوش ہے (ADB) => سچ ہے \nخوش ہے (xyy) => غلط ہے", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/34", "entry_point": "numerical_letter_grade", "test": "\n\narg00 = [4.0, 3, 1.7, 2, 3.5]\nx0 = numerical_letter_grade(arg00)\nv0 = [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1.2]\nx1 = numerical_letter_grade(arg10)\nv1 = [\"D+\"]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [0.5]\nx2 = numerical_letter_grade(arg20)\nv2 = [\"D-\"]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [0.0]\nx3 = numerical_letter_grade(arg30)\nv3 = [\"E\"]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 0.3, 1.5, 2.8, 3.3]\nx4 = numerical_letter_grade(arg40)\nv4 = [\"D\", \"D-\", \"C-\", \"B\", \"B+\"]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [0, 0.7]\nx5 = numerical_letter_grade(arg50)\nv5 = [\"E\", \"D-\"]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "یہ سمسٹر کا آخری ہفتہ ہوتا ہے اور استاد کو گریڈ دینا ہوتے ہیں۔ \nطلباء کے لیے۔ استاد درجہ بندی کے لیے اپنا الگورتھم خود بنا رہے ہیں۔ \nواحد مسئلہ یہ ہے کہ اس نے وہ کوڈ کھو دیا ہے جو اس نے گریڈنگ کے لیے استعمال کیا تھا۔ \nاس نے آپ کو کچھ طلباء کے لیے جی پی اے کی فہرست دی ہے اور آپ کو لکھنا ہے \nایک فنکشن جو درج ذیل ٹیبل کا استعمال کرتے ہوئے لیٹر گریڈ کی فہرست نکال سکتا ہے: \nجی پی اے۔ لیٹر گریڈ \n4. 0 اے + \n> 3. 7 اے \n> 3. 3 اے-\n> 3. 0 بی + \n> 2. 7 بی \n> 2. 3 بی-\n> 2. 0 سی + \n> 1. 7 سی \n> 1. 3 سی-\n> 1. 0 ڈی + \n> 0. 7 ڈی \n> 0. 0 ڈی-\n0. 0 ای \n\nمثال: \nگریڈ _ مساوات ([4. 0, 3, 1.7, 2, 3. 5]) = => ['A +','B','C-','C','A -']", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/35", "entry_point": "prime_length", "test": "\n\narg00 = \"Hello\"\nx0 = prime_length(arg00)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"abcdcba\"\nx1 = prime_length(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"kittens\"\nx2 = prime_length(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"orange\"\nx3 = prime_length(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"wow\"\nx4 = prime_length(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"world\"\nx5 = prime_length(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"MadaM\"\nx6 = prime_length(arg60)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"Wow\"\nx7 = prime_length(arg70)\nv7 = true\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"\"\nx8 = prime_length(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = \"HI\"\nx9 = prime_length(arg90)\nv9 = true\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = \"go\"\nx10 = prime_length(arg100)\nv10 = true\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = \"gogo\"\nx11 = prime_length(arg110)\nv11 = false\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = \"aaaaaaaaaaaaaaa\"\nx12 = prime_length(arg120)\nv12 = false\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\narg130 = \"Madam\"\nx13 = prime_length(arg130)\nv13 = true\nif x13 != v13\n    raise StandardError, \"Error at test case 14\"\nend\n\narg140 = \"M\"\nx14 = prime_length(arg140)\nv14 = false\nif x14 != v14\n    raise StandardError, \"Error at test case 15\"\nend\n\narg150 = \"0\"\nx15 = prime_length(arg150)\nv15 = false\nif x15 != v15\n    raise StandardError, \"Error at test case 16\"\nend\n\n", "description": "ایک فنکشن لکھیں جو سٹرنگ لے اور ٹرو واپس کرے اگر سٹرنگ \nلمبائی ایک پرائم نمبر ہے یا بصورت دیگر غلط \nمثالیں \nپرائم _ لمبائی ('ہیلو') = = درست \nپرائم _ لینتھ ('اے بی سی ڈی سی بی اے') = = درست \nپرائم _ لمبائی ('بلی کے بچے') = = درست \nپرائم _ لمبائی ('نارنجی') = = غلط", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/36", "entry_point": "solve", "test": "\n\narg00 = 1000\nx0 = solve(arg00)\nv0 = \"1\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 150\nx1 = solve(arg10)\nv1 = \"110\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 147\nx2 = solve(arg20)\nv2 = \"1100\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 333\nx3 = solve(arg30)\nv3 = \"1001\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 963\nx4 = solve(arg40)\nv4 = \"10010\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "ایک مثبت عدد N کو دیکھتے ہوئے، اس کے ہندسوں کا کل مجموعہ بائنری میں واپس کریں۔ \n\nمثال \nN = 1000 کے لیے، ہندسوں کا مجموعہ 1 ہوگا اور آؤٹ پٹ \"1\" ہونا چاہیے۔ \nN = 150 کے لیے، ہندسوں کا مجموعہ 6 ہوگا اور آؤٹ پٹ \"110\" ہونا چاہیے۔ \nN = 147 کے لیے، ہندسوں کا مجموعہ 12 ہوگا اور آؤٹ پٹ \"1100\" ہونا چاہیے۔ \n\nمتغیرات: \n@N عدد \nرکاوٹیں: 0 ≤ N ≤ 10000۔ \nآؤٹ پٹ: \nبائنری نمبر کا ایک سٹرنگ", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/37", "entry_point": "get_row", "test": "\n\narg00 = []\narg01 = 1\nx0 = get_row(arg00, arg01)\nv0 = []\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [[1]]\narg11 = 2\nx1 = get_row(arg10, arg11)\nv1 = []\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [[], [1], [1, 2, 3]]\narg21 = 3\nx2 = get_row(arg20, arg21)\nv2 = [[2, 2]]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\n", "description": "آپ کو ایک 2 جہتی ڈیٹا دیا جاتا ہے، بطور نیسٹڈ لسٹس، \nجو میٹرکس سے ملتا جلتا ہے، تاہم، میٹرکس کے برعکس، \nہر صف میں کالموں کی ایک مختلف تعداد ہو سکتی ہے۔ \nlst، اور عدد x کو دیکھتے ہوئے، فہرست میں عدد x تلاش کریں، \nاور ٹپل کی واپسی کی فہرست، [(x1, y1), (x2, y2)...] اس طرح کہ \nہر ٹپل ایک کوآرڈینیٹ ہے-(صف، کالم)، جو 0 سے شروع ہوتا ہے۔ \nکوآرڈینیٹس کو ابتدائی طور پر قطاروں کے لحاظ سے چڑھتے ہوئے ترتیب میں ترتیب دیں۔ \nنیز، قطار کے نقاط کو کالموں کے لحاظ سے نزولی ترتیب میں ترتیب دیں۔ \n\nمثالیں: \nحاصل کرو ([\n[1,2,3، 4,5,6]، \n[1,2,3، 4,1,6]، \n[1,2,3، 4,5,1] \n]، 1) = = [(0، 0)، (1، 4)، (1، 0)، (2، 5)، (2، 0)] \nحاصل کرو ([]، 1) = = [] \nحاصل کرو ([[]، [1]، [1، 2، 3]]، 3) = = [(2، 2)]", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/38", "entry_point": "next_smallest", "test": "\n\narg00 = [1, 2, 3, 4, 5]\nx0 = next_smallest(arg00)\nv0 = 2\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [5, 1, 4, 3, 2]\nx1 = next_smallest(arg10)\nv1 = 2\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = []\nx2 = next_smallest(arg20)\nv2 = nil\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1, 1]\nx3 = next_smallest(arg30)\nv3 = nil\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 1, 1, 1, 0]\nx4 = next_smallest(arg40)\nv4 = 1\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [1, 1]\nx5 = next_smallest(arg50)\nv5 = nil\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [-35, 34, 12, -45]\nx6 = next_smallest(arg60)\nv6 = -35\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "آپ کو انٹیجرز کی فہرست دی جاتی ہے۔ \nایک فنکشن نیکسٹ _ لیسٹسٹ () لکھیں جو فہرست کا دوسرا سب سے چھوٹا عنصر واپس کرے۔ \nاگر ایسا کوئی عنصر نہیں ہے تو کالعدم واپس کریں۔ \n\nاگلا _ سب سے چھوٹا ([1، 2، 3، 4، 5]) = = 2 \nاگلا _ سب سے چھوٹا ([5، 1، 4، 3، 2]) = = 2 \nاگلا _ سب سے چھوٹا ([]) = = کوئی نہیں \nاگلا _ سب سے چھوٹا ([1, 1]) = = کوئی نہیں", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/39", "entry_point": "is_bored", "test": "\n\narg00 = \"Hello world\"\nx0 = is_bored(arg00)\nv0 = 0\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Is the sky blue?\"\nx1 = is_bored(arg10)\nv1 = 0\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"I love It !\"\nx2 = is_bored(arg20)\nv2 = 1\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"bIt\"\nx3 = is_bored(arg30)\nv3 = 0\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"I feel good today. I will be productive. will kill It\"\nx4 = is_bored(arg40)\nv4 = 2\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"You and I are going for a walk\"\nx5 = is_bored(arg50)\nv5 = 0\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "آپ کو الفاظ کی ایک تار دی جائے گی، اور آپ کا کام تعداد شمار کرنا ہے \nبوریت۔ بوریت ایک جملہ ہے جو لفظ \"میں\" سے شروع ہوتا ہے۔ \nجملوں کی حد بندی '.'،'؟'یا '!'سے کی جاتی ہے۔ \n\nمثال کے طور پر: \n>>> ہے _ بور (\"ہیلو ورلڈ\") \n0 \n>>> بور ہے (\"آسمان نیلا ہے۔ سورج چمک رہا ہے۔ مجھے یہ موسم پسند ہے\") \n1.", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/40", "entry_point": "skjkasdkd", "test": "\n\narg00 = [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]\nx0 = skjkasdkd(arg00)\nv0 = 10\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]\nx1 = skjkasdkd(arg10)\nv1 = 25\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]\nx2 = skjkasdkd(arg20)\nv2 = 13\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]\nx3 = skjkasdkd(arg30)\nv3 = 11\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [0, 81, 12, 3, 1, 21]\nx4 = skjkasdkd(arg40)\nv4 = 3\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [0, 8, 1, 2, 1, 7]\nx5 = skjkasdkd(arg50)\nv5 = 7\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [8191]\nx6 = skjkasdkd(arg60)\nv6 = 19\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [8191, 123456, 127, 7]\nx7 = skjkasdkd(arg70)\nv7 = 19\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [127, 97, 8192]\nx8 = skjkasdkd(arg80)\nv8 = 10\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "آپ کو انٹیجرز کی فہرست دی جاتی ہے۔ \nآپ کو سب سے بڑی پرائم ویلیو تلاش کرنے اور اس کے ہندسوں کا مجموعہ واپس کرنے کی ضرورت ہے۔ \n\nمثالیں: \nlst = [0,3,2، 1,3,5، 7,4,5، 5,5,2، 181,32,4، 32,3,2، 32,324,4، 3] کے لیے آؤٹ پٹ 10 ہونا چاہیے۔ \nlst = [1,0,1، 8,2,4597، 2,1,3، 40,1,2، 1,2,4، 2,5,1] کے لیے آؤٹ پٹ 25 ہونا چاہیے۔ \nlst = [1,3,1، 32,5107,34، 83278,109,163، 23,2323,32، 30,1,9، 3] کے لیے آؤٹ پٹ 13 ہونا چاہیے۔ \nlst = [0,724,32، 71,99,32، 6,0,5، 91,83,0، 5, 6] کے لیے آؤٹ پٹ 11 ہونا چاہیے۔ \nlst = [0,81,12، 3,1,21] کے لیے آؤٹ پٹ 3 ہونا چاہیے۔ \nlst = [0,8,1، 2,1,7] کے لیے آؤٹ پٹ 7 ہونا چاہیے۔", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/41", "entry_point": "check_dict_case", "test": "\n\narg00 = {\"p\"=>\"pineapple\", \"b\"=>\"banana\"}\nx0 = check_dict_case(arg00)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = {\"p\"=>\"pineapple\", \"A\"=>\"banana\", \"B\"=>\"banana\"}\nx1 = check_dict_case(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = {\"p\"=>\"pineapple\", 5=>\"banana\", \"a\"=>\"apple\"}\nx2 = check_dict_case(arg20)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = {\"Name\"=>\"John\", \"Age\"=>\"36\", \"City\"=>\"Houston\"}\nx3 = check_dict_case(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = {\"STATE\"=>\"NC\", \"ZIP\"=>\"12345\"}\nx4 = check_dict_case(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = {\"fruit\"=>\"Orange\", \"taste\"=>\"Sweet\"}\nx5 = check_dict_case(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = {}\nx6 = check_dict_case(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "لغت دی گئی ہے، اگر تمام چابیاں نچلے حصے میں تار ہیں تو سچ واپس کریں \nکیس یا تمام چابیاں اپر کیس میں سٹرنگ ہیں، ورنہ فالس واپس کریں۔ \nفنکشن لوٹنا چاہیے غلط ہے کہ دی گئی لغت خالی ہے۔ \nمثالیں: \nچیک _ ڈکٹ _ کیس ({\"a\": \"سیب\"، \"b\": \"کیلا\"}) کو درست ہونا چاہیے۔ \nچیک _ ڈکٹ _ کیس ({\"a\": \"سیب\"، \"A\": \"کیلا\"، \"B\": \"کیلا\"}) کو غلط واپس کرنا چاہیے۔ \nچیک _ ڈکٹ _ کیس ({\"a\": \"سیب\"، 8: \"کیلا\"، \"a\": \"سیب\"}) کو غلط واپس کرنا چاہیے۔ \nچیک _ ڈکٹ _ کیس ({\"نام\": \"جان\"، \"ایج\": \"36\"، \"سٹی\": \"ہیوسٹن\"}) کو فالس واپس کرنا چاہیے۔ \nچیک _ ڈکٹ _ کیس ({\"اسٹیٹ\": \"این سی\"، \"زپ\": \"12345\"}) کو درست ہونا چاہیے۔", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/42", "entry_point": "closest_integer", "test": "\n\narg00 = \"10\"\nx0 = closest_integer(arg00)\nv0 = 10\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"14.5\"\nx1 = closest_integer(arg10)\nv1 = 15\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"-15.5\"\nx2 = closest_integer(arg20)\nv2 = -16\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"15.3\"\nx3 = closest_integer(arg30)\nv3 = 15\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"0\"\nx4 = closest_integer(arg40)\nv4 = 0\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "ایک فنکشن بنائیں جو ایک نمبر کی نمائندگی کرنے والی قدر (سٹرنگ) لیتا ہے \nاور اس کے قریب ترین عدد واپس کرتا ہے۔ اگر عدد مساوی فاصلے پر ہے \nدو انٹیجرز سے، اسے صفر سے دور گول کریں۔ \n\nمثالیں \n>>> قریب ترین عدد (\"10\") \n10. \n>>> قریب ترین عدد (\"15. 3\") \n15 \n\nنوٹ: \nصفر سے دور گول کرنے کا مطلب ہے کہ اگر دیا ہوا نمبر مساوی فاصلے پر ہے \nدو انٹیجرز میں سے، جو آپ کو واپس کرنا چاہیے وہ وہی ہے جو \nصفر سے سب سے دور۔ مثال کے طور پر قریب ترین عدد (\"14. 5\") ہونا چاہیے۔ \n15 واپس کریں اور قریب ترین عدد (\"-14. 5\") کو-15 واپس کرنا چاہیے۔", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/43", "entry_point": "make_a_pile", "test": "\n\narg00 = 3\nx0 = make_a_pile(arg00)\nv0 = [3, 5, 7]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 4\nx1 = make_a_pile(arg10)\nv1 = [4, 6, 8, 10]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 5\nx2 = make_a_pile(arg20)\nv2 = [5, 7, 9, 11, 13]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 6\nx3 = make_a_pile(arg30)\nv3 = [6, 8, 10, 12, 14, 16]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 8\nx4 = make_a_pile(arg40)\nv4 = [8, 10, 12, 14, 16, 18, 20, 22]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "ایک مثبت عدد n کو دیکھتے ہوئے، آپ کو پتھروں کی n سطحوں کا ڈھیر بنانا ہوگا۔ \nپہلی سطح پر این پتھر ہیں۔ \nاگلی سطح پر پتھروں کی تعداد یہ ہے: \n- اگلا عجیب عدد اگر n عجیب ہے۔ \n- اگلا یکساں عدد اگر n یکساں ہو۔ \nفہرست میں ہر سطح پر پتھروں کی تعداد واپس کریں، جہاں اشاریہ پر عنصر ہے \ni سطح میں پتھروں کی تعداد کی نمائندگی کرتا ہے (i + 1)۔ \n\nمثالیں: \n>>> بناؤ _ a _ ڈھیر (3) \n[3، 5، 7]", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/44", "entry_point": "words_string", "test": "\n\narg00 = \"Hi, my name is John\"\nx0 = words_string(arg00)\nv0 = [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"One, two, three, four, five, six\"\nx1 = words_string(arg10)\nv1 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"Hi, my name\"\nx2 = words_string(arg20)\nv2 = [\"Hi\", \"my\", \"name\"]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"One,, two, three, four, five, six,\"\nx3 = words_string(arg30)\nv3 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"\"\nx4 = words_string(arg40)\nv4 = []\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"ahmed     , gamal\"\nx5 = words_string(arg50)\nv5 = [\"ahmed\", \"gamal\"]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "آپ کو الفاظ کی ایک تار دی جائے گی جسے کوما یا خالی جگہوں سے الگ کیا جائے گا۔ آپ کا کام ہے \nسٹرنگ کو الفاظ میں تقسیم کرنا اور الفاظ کی ایک صف واپس کرنا۔ \n\nمثال کے طور پر: \nالفاظ _ سٹرنگ (\"ہیلو، میرا نام جان ہے\") = = [\"ہیلو\"، \"میرا\"، \"نام\"، \"ہے\"، \"جان\"] \nالفاظ _ سٹرنگ (\"ایک، دو، تین، چار، پانچ، چھ\") = = [\"ایک\"، \"دو\"، \"تین\"، \"چار\"، \"پانچ\"، \"چھ\"]", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/45", "entry_point": "choose_num", "test": "\n\narg00 = 12\narg01 = 15\nx0 = choose_num(arg00, arg01)\nv0 = 14\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 13\narg11 = 12\nx1 = choose_num(arg10, arg11)\nv1 = -1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 33\narg21 = 12354\nx2 = choose_num(arg20, arg21)\nv2 = 12354\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 5234\narg31 = 5233\nx3 = choose_num(arg30, arg31)\nv3 = -1\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 6\narg41 = 29\nx4 = choose_num(arg40, arg41)\nv4 = 28\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 27\narg51 = 10\nx5 = choose_num(arg50, arg51)\nv5 = -1\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 7\narg61 = 7\nx6 = choose_num(arg60, arg61)\nv6 = -1\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 546\narg71 = 546\nx7 = choose_num(arg70, arg71)\nv7 = 546\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\n", "description": "یہ فنکشن دو مثبت اعداد x اور y لیتا ہے اور واپس کرتا ہے \nسب سے بڑا یکساں عدد جو [x, y] کی حد میں ہے۔ اگر \nایسا کوئی نمبر نہیں ہے، پھر فنکشن-1 واپس آنا چاہیے۔ \n\nمثال کے طور پر: \nچنئے _ num (12، 15) = 14 \nچنئے _ num (13، 12) =-1", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/46", "entry_point": "rounded_avg", "test": "\n\narg00 = 1\narg01 = 5\nx0 = rounded_avg(arg00, arg01)\nv0 = \"0b11\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 7\narg11 = 13\nx1 = rounded_avg(arg10, arg11)\nv1 = \"0b1010\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 964\narg21 = 977\nx2 = rounded_avg(arg20, arg21)\nv2 = \"0b1111001010\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 996\narg31 = 997\nx3 = rounded_avg(arg30, arg31)\nv3 = \"0b1111100100\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 560\narg41 = 851\nx4 = rounded_avg(arg40, arg41)\nv4 = \"0b1011000010\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 185\narg51 = 546\nx5 = rounded_avg(arg50, arg51)\nv5 = \"0b101101110\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 362\narg61 = 496\nx6 = rounded_avg(arg60, arg61)\nv6 = \"0b110101101\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 350\narg71 = 902\nx7 = rounded_avg(arg70, arg71)\nv7 = \"0b1001110010\"\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 197\narg81 = 233\nx8 = rounded_avg(arg80, arg81)\nv8 = \"0b11010111\"\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 7\narg91 = 5\nx9 = rounded_avg(arg90, arg91)\nv9 = -1\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = 5\narg101 = 1\nx10 = rounded_avg(arg100, arg101)\nv10 = -1\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = 5\narg111 = 5\nx11 = rounded_avg(arg110, arg111)\nv11 = \"0b101\"\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\n", "description": "آپ کو دو مثبت عدد n اور m دیے گئے ہیں، اور آپ کا کام حساب لگانا ہے \nn سے m تک کے انٹیجرز کی اوسط (بشمول n اور m)۔ \nقریب ترین عدد کے جواب کو گول کریں اور اسے بائنری میں تبدیل کریں۔ \nاگر n، m سے بڑا ہے، تو-1 واپس کریں۔ \nمثال: \nگول _ اے وی جی (1، 5) => \"0b11\" \nگول _ اے وی جی (7، 5) =>-1 \nگول _ اے وی جی (10، 20) => \"0b1111\" \nگول _ اے وی جی (20، 33) => \"0b11010\"", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/47", "entry_point": "f", "test": "\n\narg00 = 5\nx0 = f(arg00)\nv0 = [1, 2, 6, 24, 15]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 7\nx1 = f(arg10)\nv1 = [1, 2, 6, 24, 15, 720, 28]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 1\nx2 = f(arg20)\nv2 = [1]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 3\nx3 = f(arg30)\nv3 = [1, 2, 6]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "فنکشن f کو لاگو کریں جو n کو پیرامیٹر کے طور پر لیتا ہے، \nاور سائز n کی فہرست واپس کرتا ہے، اس طرح کہ انڈیکس i پر عنصر کی قیمت i کی فیکٹوریئل ہے اگر i مساوی ہے \nیا 1 سے i تک کے اعداد کا مجموعہ۔ \nمیں 1 سے شروع کرتا ہوں۔ \ni کا فیکٹوریئل 1 سے i (1 * 2 *... * i) تک کے اعداد کا ضرب ہے۔ \nمثال: \nf (5) = = [1، 2، 6، 24، 15]", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/48", "entry_point": "even_odd_palindrome", "test": "\n\narg00 = 123\nx0 = even_odd_palindrome(arg00)\nv0 = [8, 13]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 12\nx1 = even_odd_palindrome(arg10)\nv1 = [4, 6]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 3\nx2 = even_odd_palindrome(arg20)\nv2 = [1, 2]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 63\nx3 = even_odd_palindrome(arg30)\nv3 = [6, 8]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 25\nx4 = even_odd_palindrome(arg40)\nv4 = [5, 6]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 19\nx5 = even_odd_palindrome(arg50)\nv5 = [4, 6]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 9\nx6 = even_odd_palindrome(arg60)\nv6 = [4, 5]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 1\nx7 = even_odd_palindrome(arg70)\nv7 = [0, 1]\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\n", "description": "ایک مثبت عدد n کو دیکھتے ہوئے، ایک ٹپل واپس کریں جس کی تعداد یکساں اور طاق ہو۔ \nانٹیجر پیلینڈروم جو (1، n) کی حد میں آتے ہیں، بشمول۔ \n\nمثال 1: \n\nان پٹ: 3 \nپیداوار: (1، 2) \nوضاحت: \nانٹیجر پیلینڈروم 1، 2، 3 ہیں۔ ان میں سے ایک یکساں ہے، اور ان میں سے دو عجیب ہیں۔ \n\nمثال 2: \n\nان پٹ: 12 \nپیداوار: (4، 6) \nوضاحت: \nانٹیجر پیلینڈروم 1، 2، 3، 4، 5، 6، 7، 8، 9، 11 ہیں۔ ان میں سے چار یکساں ہیں، اور ان میں سے 6 عجیب ہیں۔ \n\nنوٹ: \n1. 1 <= n <= 10 ^ 3 \n2۔ واپس آنے والے ٹپل میں بالترتیب یکساں اور عجیب عدد پیلینڈروم کی تعداد ہوتی ہے۔", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/49", "entry_point": "move_one_ball", "test": "\n\narg00 = [3, 4, 5, 1, 2]\nx0 = move_one_ball(arg00)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [3, 5, 10, 1, 2]\nx1 = move_one_ball(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [4, 3, 1, 2]\nx2 = move_one_ball(arg20)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [3, 5, 4, 1, 2]\nx3 = move_one_ball(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = []\nx4 = move_one_ball(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "ہمارے پاس N انٹیجرز arr [1]، arr [2]،...، arr [N] کی ایک صف'arr'ہے۔ \nصف میں نمبروں کو تصادفی طور پر ترتیب دیا جائے گا۔ آپ کا کام اس بات کا تعین کرنا ہے کہ آیا \nکارکردگی کا مظاہرہ کرکے غیر کم ہونے والی ترتیب میں صف بندی کرنا ممکن ہے \nدی گئی صف پر درج ذیل عمل: \nآپ کو کسی بھی وقت صحیح شفٹ آپریشن کرنے کی اجازت ہے۔ \n\nون رائٹ شفٹ آپریشن کا مطلب ہے صف کے تمام عناصر کو ایک سے منتقل کرنا۔ \nصحیح سمت میں پوزیشن۔ صف کے آخری عنصر کو منتقل کر دیا جائے گا \nصف میں ابتدائی پوزیشن یعنی 0 ویں انڈیکس۔ \n\nاگر مذکورہ بالا آپریشن انجام دے کر ترتیب شدہ صف حاصل کرنا ممکن ہے \nپھر سچ واپس کریں ورنہ غلط واپس کریں۔ \nاگر دی گئی صف خالی ہے تو ٹرو واپس کریں۔ \n\nنوٹ: دی گئی فہرست میں منفرد عناصر ہونے کی ضمانت ہے۔ \n\nمثال کے طور پر: \n\nمنتقل _ ایک _ گیند ([3، 4، 5، 1، 2]) = => درست \nوضاحت: 2 دائیں شفٹ کی کارروائیوں میں کارکردگی کا مظاہرہ کرنے سے، غیر کم ہونے والا آرڈر کر سکتا ہے \nدی گئی صف کے لیے حاصل کیا جائے۔ \nموو _ ون _ بال ([3، 5، 4، 1، 2]) = => غلط \nوضاحت: دیئے گئے آرڈر کے لیے نان ڈکریزنگ آرڈر حاصل کرنا ممکن نہیں ہے۔ \nکسی بھی تعداد میں صحیح شفٹ آپریشن انجام دے کر صف۔", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/50", "entry_point": "exchange", "test": "\n\narg00 = [1, 2, 3, 4]\narg01 = [1, 2, 3, 4]\nx0 = exchange(arg00, arg01)\nv0 = \"YES\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 2, 3, 4]\narg11 = [1, 5, 3, 4]\nx1 = exchange(arg10, arg11)\nv1 = \"NO\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 2, 3, 4]\narg21 = [2, 1, 4, 3]\nx2 = exchange(arg20, arg21)\nv2 = \"YES\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [5, 7, 3]\narg31 = [2, 6, 4]\nx3 = exchange(arg30, arg31)\nv3 = \"YES\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [5, 7, 3]\narg41 = [2, 6, 3]\nx4 = exchange(arg40, arg41)\nv4 = \"NO\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [3, 2, 6, 1, 8, 9]\narg51 = [3, 5, 5, 1, 1, 1]\nx5 = exchange(arg50, arg51)\nv5 = \"NO\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [100, 200]\narg61 = [200, 200]\nx6 = exchange(arg60, arg61)\nv6 = \"YES\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "اس مسئلے میں، آپ ایک فنکشن نافذ کریں گے جو نمبروں کی دو فہرستیں لیتا ہے، \nاور اس بات کا تعین کرتا ہے کہ آیا عناصر کا تبادلہ کرنا ممکن ہے \nان کے درمیان lst1 کو صرف یکساں اعداد کی فہرست بنانے کے لیے۔ \nlst1 اور lst2 کے درمیان تبادلے شدہ عناصر کی تعداد کی کوئی حد نہیں ہے۔ \nاگر lst1 اور lst2 کے درمیان عناصر کا تبادلہ کرنا ممکن ہے \nlst1 کے تمام عناصر کو یکساں ہونے کے لیے، \"ہاں\" واپس کریں۔ \nورنہ \"نہیں\" واپس کریں۔ \nمثال کے طور پر: \nتبادلہ ([1، 2، 3، 4]، [1، 2، 3، 4]) => \"ہاں\" \nتبادلہ ([1، 2، 3، 4]، [1، 5، 3، 4]) => \"نہیں\" \nیہ فرض کیا جاتا ہے کہ ان پٹ فہرستیں خالی نہیں ہوں گی۔", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/51", "entry_point": "reverse_delete", "test": "\n\narg00 = \"abcde\"\narg01 = \"ae\"\nx0 = reverse_delete(arg00, arg01)\nv0 = [\"bcd\", false]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"abcdef\"\narg11 = \"b\"\nx1 = reverse_delete(arg10, arg11)\nv1 = [\"acdef\", false]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"abcdedcba\"\narg21 = \"ab\"\nx2 = reverse_delete(arg20, arg21)\nv2 = [\"cdedc\", true]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"dwik\"\narg31 = \"w\"\nx3 = reverse_delete(arg30, arg31)\nv3 = [\"dik\", false]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"a\"\narg41 = \"a\"\nx4 = reverse_delete(arg40, arg41)\nv4 = [\"\", true]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"abcdedcba\"\narg51 = \"\"\nx5 = reverse_delete(arg50, arg51)\nv5 = [\"abcdedcba\", true]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"abcdedcba\"\narg61 = \"v\"\nx6 = reverse_delete(arg60, arg61)\nv6 = [\"abcdedcba\", true]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"vabba\"\narg71 = \"v\"\nx7 = reverse_delete(arg70, arg71)\nv7 = [\"abba\", true]\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"mamma\"\narg81 = \"mia\"\nx8 = reverse_delete(arg80, arg81)\nv8 = [\"\", true]\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "کام \nہمیں دو تار s اور c دیے گئے ہیں، آپ کو s کے تمام حروف کو حذف کرنا ہوگا جو c کے کسی بھی کردار کے برابر ہیں۔ \nپھر چیک کریں کہ آیا نتیجہ کا سٹرنگ پیلینڈروم ہے۔ \nایک تار کو پیلینڈروم کہا جاتا ہے اگر یہ آگے کی طرح پیچھے کی طرف پڑھتا ہے۔ \nآپ کو ایک ٹپل واپس کرنا چاہیے جس میں نتیجہ کی تار اور چیک کے لیے درست/غلط ہو۔ \nمثال \nایس = \"اے بی سی ڈی\"، سی = \"اے ای\" کے لیے نتیجہ ہونا چاہیے ('بی سی ڈی'، غلط) \ns = \"abcdef\" کے لیے، c = \"b\" نتیجہ ہونا چاہیے ('acdef'، غلط) \ns = \"abcdedcba\"، c = \"ab\" کے لیے نتیجہ ہونا چاہیے ('cdedc'، سچ)", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/52", "entry_point": "max_fill", "test": "\n\narg00 = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]]\narg01 = 1\nx0 = max_fill(arg00, arg01)\nv0 = 6\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]]\narg11 = 2\nx1 = max_fill(arg10, arg11)\nv1 = 5\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [[0, 0, 0], [0, 0, 0]]\narg21 = 5\nx2 = max_fill(arg20, arg21)\nv2 = 0\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [[1, 1, 1, 1], [1, 1, 1, 1]]\narg31 = 2\nx3 = max_fill(arg30, arg31)\nv3 = 4\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [[1, 1, 1, 1], [1, 1, 1, 1]]\narg41 = 9\nx4 = max_fill(arg40, arg41)\nv4 = 2\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "آپ کو کنوؤں کا ایک آئتاکار گرڈ دیا جاتا ہے۔ ہر قطار ایک کنویں کی نمائندگی کرتی ہے، \nاور ایک صف میں ہر 1 پانی کی ایک اکائی کی نمائندگی کرتا ہے۔ \nہر کنویں میں ایک متعلقہ بالٹی ہوتی ہے جسے اس سے پانی نکالنے کے لیے استعمال کیا جا سکتا ہے۔ \nاور تمام بالٹیوں کی صلاحیت ایک جیسی ہوتی ہے۔ \nآپ کا کام کنویں خالی کرنے کے لیے بالٹیوں کا استعمال کرنا ہے۔ \nجتنی بار آپ کو بالٹیاں کم کرنے کی ضرورت ہے اس کی تعداد کا تعین کریں۔ \n\nمثال 1: \nان پٹ: \nگرڈ: [[0,0,1، 0]، [0,1,0، 0]، [1,1,1، 1] \nبالٹی کی صلاحیت (_ c): 1 \nپیداوار: 6 \n\nمثال 2: \nان پٹ: \nگرڈ: [[0، 0,1,1]، [0,0,0، 0]، [1,1,1، 1]، [0,1,1، 1] \nبالٹی کی صلاحیت: 2 \nپیداوار: 5 \n\nمثال 3: \nان پٹ: \nگرڈ: [[0,0,0]، [0,0,0] \nبالٹی کی صلاحیت: 5 \nآؤٹ پٹ: 0 \n\nرکاوٹیں: \n* تمام کنوؤں کی لمبائی ایک جیسی ہوتی ہے \n* 1 <= grid.length <= 10 ^ 2 \n* 1 <= گرڈ [:، 1]. لمبائی <= 10 ^ 2 \nگرڈ [i] [j]-> 0 | 1 \n* 1 <= صلاحیت <= 10", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/53", "entry_point": "select_words", "test": "\n\narg00 = \"Mary had a little lamb\"\narg01 = 4\nx0 = select_words(arg00, arg01)\nv0 = [\"little\"]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Mary had a little lamb\"\narg11 = 3\nx1 = select_words(arg10, arg11)\nv1 = [\"Mary\", \"lamb\"]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"simple white space\"\narg21 = 2\nx2 = select_words(arg20, arg21)\nv2 = []\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"Hello world\"\narg31 = 4\nx3 = select_words(arg30, arg31)\nv3 = [\"world\"]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"Uncle sam\"\narg41 = 3\nx4 = select_words(arg40, arg41)\nv4 = [\"Uncle\"]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"\"\narg51 = 4\nx5 = select_words(arg50, arg51)\nv5 = []\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"a b c d e f\"\narg61 = 1\nx6 = select_words(arg60, arg61)\nv6 = [\"b\", \"c\", \"d\", \"f\"]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "سٹرنگ s اور قدرتی نمبر n کو دیکھتے ہوئے، آپ کو عمل درآمد کرنے کا کام سونپا گیا ہے۔ \nایک فنکشن جو سٹرنگ s سے تمام الفاظ کی فہرست واپس کرتا ہے جس میں بالکل \nn مخطوطات، ترتیب میں یہ الفاظ سٹرنگ s میں ظاہر ہوتے ہیں۔ \nاگر سٹرنگ s خالی ہے تو فنکشن کو ایک خالی فہرست واپس کرنی چاہیے۔ \nنوٹ: آپ فرض کر سکتے ہیں کہ ان پٹ سٹرنگ میں صرف حروف اور خالی جگہیں ہیں۔ \nمثالیں: \nسلیکٹ _ ورڈز (\"مریم کے پاس ایک چھوٹا بھیڑ تھا\"، 4) = => [\"چھوٹا\"] \nمنتخب _ الفاظ (\"مریم کا ایک چھوٹا بھیڑ تھا\"، 3) = => [\"مریم\"، \"بھیڑ\"] \nسلیکٹ _ ورڈز (\"سادہ سفید جگہ\"، 2) = => [] \nسلیکٹ _ ورڈز (\"ہیلو ورلڈ\"، 4) = => [\"ورلڈ\"] \nسلیکٹ _ ورڈز (\"انکل سیم\"، 3) = => [\"انکل\"]", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/54", "entry_point": "maximum", "test": "\n\narg00 = [-3, -4, 5]\narg01 = 3\nx0 = maximum(arg00, arg01)\nv0 = [-4, -3, 5]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [4, -4, 4]\narg11 = 2\nx1 = maximum(arg10, arg11)\nv1 = [4, 4]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [-3, 2, 1, 2, -1, -2, 1]\narg21 = 1\nx2 = maximum(arg20, arg21)\nv2 = [2]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [123, -123, 20, 0, 1, 2, -3]\narg31 = 3\nx3 = maximum(arg30, arg31)\nv3 = [2, 20, 123]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [-123, 20, 0, 1, 2, -3]\narg41 = 4\nx4 = maximum(arg40, arg41)\nv4 = [0, 1, 2, 20]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [5, 15, 0, 3, -13, -8, 0]\narg51 = 7\nx5 = maximum(arg50, arg51)\nv5 = [-13, -8, 0, 0, 3, 5, 15]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [-1, 0, 2, 5, 3, -10]\narg61 = 2\nx6 = maximum(arg60, arg61)\nv6 = [3, 5]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [1, 0, 5, -7]\narg71 = 1\nx7 = maximum(arg70, arg71)\nv7 = [5]\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [4, -4]\narg81 = 2\nx8 = maximum(arg80, arg81)\nv8 = [-4, 4]\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = [-10, 10]\narg91 = 2\nx9 = maximum(arg90, arg91)\nv9 = [-10, 10]\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = [1, 2, 3, -23, 243, -400, 0]\narg101 = 0\nx10 = maximum(arg100, arg101)\nv10 = []\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\n", "description": "انٹیجرز کی ایک صف arr اور ایک مثبت عدد k کو دیکھتے ہوئے، ایک ترتیب شدہ فہرست واپس کریں \narr میں زیادہ سے زیادہ k نمبروں کے ساتھ لمبائی k کا۔ \n\nمثال 1: \n\nان پٹ: arr = [-3،-4، 5]، k = 3 \nپیداوار: [-4،-3، 5] \n\nمثال 2: \n\nان پٹ: arr = [4،-4، 4]، k = 2 \nپیداوار: [4, 4] \n\nمثال 3: \n\nان پٹ: arr = [-3، 2، 1، 2،-1،-2، 1]، k = 1 \nپیداوار: [2] \n\nنوٹ: \nصف کی لمبائی [1, 1000] کی حد میں ہوگی۔ \nصف میں موجود عناصر [-1000, 1000] کی حد میں ہوں گے۔ \n3. 0 <= k <= لین (arr)", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/55", "entry_point": "add_elements", "test": "\n\narg00 = [1, -2, -3, 41, 57, 76, 87, 88, 99]\narg01 = 3\nx0 = add_elements(arg00, arg01)\nv0 = -4\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [111, 121, 3, 4000, 5, 6]\narg11 = 2\nx1 = add_elements(arg10, arg11)\nv1 = 0\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [11, 21, 3, 90, 5, 6, 7, 8, 9]\narg21 = 4\nx2 = add_elements(arg20, arg21)\nv2 = 125\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [111, 21, 3, 4000, 5, 6, 7, 8, 9]\narg31 = 4\nx3 = add_elements(arg30, arg31)\nv3 = 24\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1]\narg41 = 1\nx4 = add_elements(arg40, arg41)\nv4 = 1\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "انٹیجرز arr اور ایک انٹیجر k کی غیر خالی صف کو دیکھتے ہوئے، واپس کریں \narr کے پہلے k عناصر سے زیادہ سے زیادہ دو ہندسوں والے عناصر کا مجموعہ۔ \n\nمثال: \n\nان پٹ: arr = [111,21,3، 4000,5,6، 7,8,9]، k = 4 \nآؤٹ پٹ: 24 #21 + 3 کا مجموعہ \n\nرکاوٹیں: \n1. 1 <= لین (آر آر) <= 100 \n2. 1 <= k <= لین (arr)", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/56", "entry_point": "intersection", "test": "\n\narg00 = [1, 2]\narg01 = [2, 3]\nx0 = intersection(arg00, arg01)\nv0 = \"NO\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [-1, 1]\narg11 = [0, 4]\nx1 = intersection(arg10, arg11)\nv1 = \"NO\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [-3, -1]\narg21 = [-5, 5]\nx2 = intersection(arg20, arg21)\nv2 = \"YES\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [-2, 2]\narg31 = [-4, 0]\nx3 = intersection(arg30, arg31)\nv3 = \"YES\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [-11, 2]\narg41 = [-1, -1]\nx4 = intersection(arg40, arg41)\nv4 = \"NO\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [1, 2]\narg51 = [3, 5]\nx5 = intersection(arg50, arg51)\nv5 = \"NO\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [1, 2]\narg61 = [1, 2]\nx6 = intersection(arg60, arg61)\nv6 = \"NO\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [-2, -2]\narg71 = [-3, -2]\nx7 = intersection(arg70, arg71)\nv7 = \"NO\"\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\n", "description": "آپ کو دو وقفے دیے جاتے ہیں، \nجہاں ہر وقفہ عدد کا ایک جوڑا ہے۔ مثال کے طور پر، وقفہ = (آغاز، اختتام) = (1، 2)۔ \nدیئے گئے وقفے بند ہیں جس کا مطلب ہے کہ وقفہ (آغاز، اختتام) \nاس میں آغاز اور اختتام دونوں شامل ہیں۔ \nہر وقفے کے لیے یہ فرض کیا جاتا ہے کہ اس کا آغاز اس کے اختتام سے کم یا برابر ہے۔ \nآپ کا کام اس بات کا تعین کرنا ہے کہ آیا ان دونوں کے چوراہے کی لمبائی کتنی ہے \nوقفہ ایک پرائم نمبر ہے۔ \nمثال کے طور پر، وقفوں کا چوراہا (1، 3)، (2، 4) ہے (2، 3) \nجس کی لمبائی 1 ہے، جو پرائم نمبر نہیں ہے۔ \nاگر چوراہے کی لمبائی ایک پرائم نمبر ہے، تو \"ہاں\" واپس کریں، \nورنہ \"نہیں\" واپس کریں۔ \nاگر دونوں وقفے ایک دوسرے کو نہیں کاٹتے ہیں، تو \"نہیں\" واپس کریں۔ \n\n[ان پٹ/آؤٹ پٹ] نمونے: \nچوراہا ((1، 2)، (2، 3)) = => \"نہیں\" \nچوراہا ((-1، 1)، (0، 4)) = => \"نہیں\" \nچوراہا (-3،-1)، (-5، 5)) = => \"ہاں\"", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/57", "entry_point": "tri", "test": "\n\narg00 = 3\nx0 = tri(arg00)\nv0 = [1, 3, 2.0, 8.0]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 4\nx1 = tri(arg10)\nv1 = [1, 3, 2.0, 8.0, 3.0]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 5\nx2 = tri(arg20)\nv2 = [1, 3, 2.0, 8.0, 3.0, 15.0]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 6\nx3 = tri(arg30)\nv3 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 7\nx4 = tri(arg40)\nv4 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 8\nx5 = tri(arg50)\nv5 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 9\nx6 = tri(arg60)\nv6 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 20\nx7 = tri(arg70)\nv7 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 0\nx8 = tri(arg80)\nv8 = [1]\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 1\nx9 = tri(arg90)\nv9 = [1, 3]\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\n", "description": "ہر کوئی فبونیکی ترتیب کو جانتا ہے، اس کا ریاضی دانوں نے گہرائی سے مطالعہ کیا تھا \nپچھلی دو صدیوں۔ تاہم، جو لوگ نہیں جانتے وہ ٹربوناچی ترتیب ہے۔ \nٹرائبوناکسی ترتیب کی تعریف تکرار سے کی جاتی ہے: \nتری (1) = 3 \nمثلث (n) = 1 + n/2، اگر n مساوی ہو۔ \nاگر n عجیب ہے تو سہ رخی (n) = سہ رخی (n-1) + سہ رخی (n-2) + سہ رخی (n + 1)۔ \nمثال کے طور پر: \nمثلث (2) = 1 + (2/2) = 2 \nتری (4) = 3 \nٹرائی (3) = ٹرائی (2) + ٹرائی (1) + ٹرائی (4) \n= 2 + 3 + 3 = 8 \nآپ کو ایک غیر منفی عدد نمبر n دیا جاتا ہے، آپ کو اس کی فہرست واپس کرنی ہوگی \nٹربونیکی ترتیب کے پہلے n + 1 نمبر۔ \nمثالیں: \nتری (3) = [1، 3، 2، 8]", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/58", "entry_point": "digits", "test": "\n\narg00 = 5\nx0 = digits(arg00)\nv0 = 5\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 54\nx1 = digits(arg10)\nv1 = 5\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 120\nx2 = digits(arg20)\nv2 = 1\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 5014\nx3 = digits(arg30)\nv3 = 5\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 98765\nx4 = digits(arg40)\nv4 = 315\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 5576543\nx5 = digits(arg50)\nv5 = 2625\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 2468\nx6 = digits(arg60)\nv6 = 0\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "مثبت عدد n کو دیکھتے ہوئے، عجیب ہندسوں کا پروڈکٹ واپس کریں۔ \n0 واپس کریں اگر تمام ہندسے یکساں ہوں۔ \nمثال کے طور پر: \nہندسوں (1) = = 1 \nہندسوں (4) = = 0 \nہندسوں (235) = = 15", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/59", "entry_point": "is_nested", "test": "\n\narg00 = \"[[]]\"\nx0 = is_nested(arg00)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"[]]]]]]][[[[[]\"\nx1 = is_nested(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"[][]\"\nx2 = is_nested(arg20)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"[]\"\nx3 = is_nested(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"[[[[]]]]\"\nx4 = is_nested(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"[]]]]]]]]]]\"\nx5 = is_nested(arg50)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"[][][[]]\"\nx6 = is_nested(arg60)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"[[]\"\nx7 = is_nested(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"[]]\"\nx8 = is_nested(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = \"[[]][[\"\nx9 = is_nested(arg90)\nv9 = true\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = \"[[][]]\"\nx10 = is_nested(arg100)\nv10 = true\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = \"\"\nx11 = is_nested(arg110)\nv11 = false\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = \"[[[[[[[[\"\nx12 = is_nested(arg120)\nv12 = false\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\narg130 = \"]]]]]]]]\"\nx13 = is_nested(arg130)\nv13 = false\nif x13 != v13\n    raise StandardError, \"Error at test case 14\"\nend\n\n", "description": "ایک فنکشن بنائیں جو ایک سٹرنگ کو ان پٹ کے طور پر لے جس میں صرف مربع بریکٹ ہوں۔ \nفنکشن کو ٹرو واپس کرنا چاہیے اگر اور صرف اس صورت میں جب بریکٹ کا درست تسلسل ہو۔ \nجہاں بعد میں کم از کم ایک بریکٹ کو گھونسلہ بنایا جاتا ہے۔ \n\nis _ nested ('[[]]') سچ ہے \nis _ nested ('[]]]]] [[[[]') غلط ہے \nis _ nested ('[] []') غلط ہے \nis _ nested ('[]') غلط ہے \nis _ nested ('[[] []]') سچ ہے \nis _ nested ('[[]] [[') سچ ہے", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/60", "entry_point": "sum_squares", "test": "\n\narg00 = [1, 2, 3]\nx0 = sum_squares(arg00)\nv0 = 14\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1.0, 2, 3]\nx1 = sum_squares(arg10)\nv1 = 14\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 3, 5, 7]\nx2 = sum_squares(arg20)\nv2 = 84\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1.4, 4.2, 0]\nx3 = sum_squares(arg30)\nv3 = 29\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [-2.4, 1, 1]\nx4 = sum_squares(arg40)\nv4 = 6\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [100, 1, 15, 2]\nx5 = sum_squares(arg50)\nv5 = 10230\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [10000, 10000]\nx6 = sum_squares(arg60)\nv6 = 200000000\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [-1.4, 4.6, 6.3]\nx7 = sum_squares(arg70)\nv7 = 75\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [-1.4, 17.9, 18.9, 19.9]\nx8 = sum_squares(arg80)\nv8 = 1086\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = [0]\nx9 = sum_squares(arg90)\nv9 = 0\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = [-1]\nx10 = sum_squares(arg100)\nv10 = 1\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = [-1, 1, 0]\nx11 = sum_squares(arg110)\nv11 = 2\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\n", "description": "آپ کو نمبروں کی فہرست دی جاتی ہے۔ \nآپ کو دی گئی فہرست میں مربع نمبروں کا مجموعہ واپس کرنے کی ضرورت ہے، \nفہرست میں ہر عنصر کو پہلے اوپری انٹ (چھت) پر گول کریں۔ \nمثالیں: \nlst = [1,2,3] کے لیے آؤٹ پٹ 14 ہونا چاہیے۔ \nlst = [1,4,9] کے لیے آؤٹ پٹ 98 ہونا چاہیے۔ \nlst = [1,3,5، 7] کے لیے آؤٹ پٹ 84 ہونا چاہیے۔ \nlst = [1.4,4.2، 0] کے لیے آؤٹ پٹ 29 ہونا چاہیے۔ \nlst = [-2.4,1، 1] کے لیے آؤٹ پٹ 6 ہونا چاہیے۔", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/61", "entry_point": "check_if_last_char_is_a_letter", "test": "\n\narg00 = \"apple\"\nx0 = check_if_last_char_is_a_letter(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"apple pi e\"\nx1 = check_if_last_char_is_a_letter(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"eeeee\"\nx2 = check_if_last_char_is_a_letter(arg20)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"A\"\nx3 = check_if_last_char_is_a_letter(arg30)\nv3 = true\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"Pumpkin pie \"\nx4 = check_if_last_char_is_a_letter(arg40)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"Pumpkin pie 1\"\nx5 = check_if_last_char_is_a_letter(arg50)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"\"\nx6 = check_if_last_char_is_a_letter(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"eeeee e \"\nx7 = check_if_last_char_is_a_letter(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"apple pie\"\nx8 = check_if_last_char_is_a_letter(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = \"apple pi e \"\nx9 = check_if_last_char_is_a_letter(arg90)\nv9 = false\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\n", "description": "ایک فنکشن بنائیں جو آخری حرف کی صورت میں ٹرو واپس کرے \nدی گئی سٹرنگ کا حروف تہجی ہے اور نہیں ہے \nلفظ کا ایک حصہ، اور دوسری صورت میں غلط۔ \nنوٹ: \"لفظ\" حروف کا ایک مجموعہ ہے جو خلا سے الگ ہوتا ہے۔ \n\nمثالیں: \nچیک کریں _ اگر _ آخری _ چار _ ہے _ a _ حرف (\"ایپل پائی\") غلط \nچیک کریں _ اگر _ آخری _ چار _ ہے _ a _ حرف (\"ایپل پائی ای\") سچ ہے \nچیک کریں _ اگر _ آخری _ چار _ ہے _ a _ حرف (\"ایپل پائی ای\") غلط \nچیک کریں _ اگر _ آخری _ چار _ ہے _ a _ حرف (\"\") غلط", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/62", "entry_point": "can_arrange", "test": "\n\narg00 = [1, 2, 4, 3, 5]\nx0 = can_arrange(arg00)\nv0 = 3\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 2, 4, 5]\nx1 = can_arrange(arg10)\nv1 = -1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 4, 2, 5, 6, 7, 8, 9, 10]\nx2 = can_arrange(arg20)\nv2 = 2\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [4, 8, 5, 7, 3]\nx3 = can_arrange(arg30)\nv3 = 4\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = []\nx4 = can_arrange(arg40)\nv4 = -1\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "ایک فنکشن بنائیں جو کسی عنصر کا سب سے بڑا انڈیکس واپس کرے جو \nاس سے فوری طور پر پہلے والے عنصر سے بڑا یا برابر نہیں ہے۔ اگر \nایسا کوئی عنصر موجود نہیں ہے تو واپسی-1۔ دی گئی صف پر مشتمل نہیں ہوگا \nڈپلیکیٹ ویلیوز۔ \n\nمثالیں: \ncan _ अरेंज کر سکتے ہیں ([1,2,4، 3, 5]) = 3 \ncan _ अरेंज کر سکتے ہیں ([1,2,3]) =-1", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/63", "entry_point": "largest_smallest_integers", "test": "\n\narg00 = [2, 4, 1, 3, 5, 7]\nx0 = largest_smallest_integers(arg00)\nv0 = [nil, 1]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [2, 4, 1, 3, 5, 7, 0]\nx1 = largest_smallest_integers(arg10)\nv1 = [nil, 1]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 3, 2, 4, 5, 6, -2]\nx2 = largest_smallest_integers(arg20)\nv2 = [-2, 1]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [4, 5, 3, 6, 2, 7, -7]\nx3 = largest_smallest_integers(arg30)\nv3 = [-7, 2]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [7, 3, 8, 4, 9, 2, 5, -9]\nx4 = largest_smallest_integers(arg40)\nv4 = [-9, 2]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = []\nx5 = largest_smallest_integers(arg50)\nv5 = [nil, nil]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [0]\nx6 = largest_smallest_integers(arg60)\nv6 = [nil, nil]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [-1, -3, -5, -6]\nx7 = largest_smallest_integers(arg70)\nv7 = [-1, nil]\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [-1, -3, -5, -6, 0]\nx8 = largest_smallest_integers(arg80)\nv8 = [-1, nil]\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = [-6, -4, -4, -3, 1]\nx9 = largest_smallest_integers(arg90)\nv9 = [-3, 1]\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = [-6, -4, -4, -3, -100, 1]\nx10 = largest_smallest_integers(arg100)\nv10 = [-3, 1]\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\n", "description": "ایک فنکشن بنائیں جو ٹپل (a، b) واپس کرے، جہاں'a'ہے \nمنفی عددوں میں سب سے بڑا، اور'b'سب سے چھوٹا ہے \nفہرست میں مثبت عدد۔ \nاگر کوئی منفی یا مثبت عدد نہیں ہیں، تو انہیں None کے طور پر واپس کریں۔ \n\nمثالیں: \nسب سے بڑے _ چھوٹے _ عدد ([2، 4، 1، 3، 5، 7]) = = (کوئی نہیں، 1) \nسب سے بڑے _ چھوٹے _ عدد ([]) = = (کوئی نہیں، کوئی نہیں) \nسب سے بڑے _ چھوٹے _ عدد ([0]) = = (کوئی نہیں، کوئی نہیں)", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/64", "entry_point": "special_factorial", "test": "\n\narg00 = 4\nx0 = special_factorial(arg00)\nv0 = 288\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 5\nx1 = special_factorial(arg10)\nv1 = 34560\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 7\nx2 = special_factorial(arg20)\nv2 = 125411328000\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 1\nx3 = special_factorial(arg30)\nv3 = 1\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "برازیلی فیکٹوریئل کی تعریف اس طرح کی گئی ہے: \nبرازیلین _ فیکٹوریئل (n) = n! * (n-1)! * (n-2)! *... * 1! \nجہاں n> 0 \n\nمثال کے طور پر: \n>>> اسپیشل _ فیکٹوریئل (4) \n288 \n\nفنکشن کو ان پٹ کے طور پر ایک انٹیجر ملے گا اور اسے خصوصی واپس کرنا چاہیے \nاس عدد کا فیکٹوریئل۔", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/65", "entry_point": "words_in_sentence", "test": "\n\narg00 = \"This is a test\"\nx0 = words_in_sentence(arg00)\nv0 = \"is\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"lets go for swimming\"\nx1 = words_in_sentence(arg10)\nv1 = \"go for\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"there is no place available here\"\nx2 = words_in_sentence(arg20)\nv2 = \"there is no place\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"Hi I am Hussein\"\nx3 = words_in_sentence(arg30)\nv3 = \"Hi am Hussein\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"go for it\"\nx4 = words_in_sentence(arg40)\nv4 = \"go for it\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"here\"\nx5 = words_in_sentence(arg50)\nv5 = \"\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"here is\"\nx6 = words_in_sentence(arg60)\nv6 = \"is\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "آپ کو ایک سٹرنگ دی جاتی ہے جو کسی جملے کی نمائندگی کرتی ہے، \nجملے میں کچھ الفاظ ہوتے ہیں جو ایک جگہ سے الگ ہوتے ہیں، \nاور آپ کو ایک تار واپس کرنا ہوگا جس میں اصل جملے کے الفاظ شامل ہوں، \nجن کی لمبائی پرائم نمبرز ہیں، \nنئے سٹرنگ میں الفاظ کی ترتیب اصل کی طرح ہی ہونی چاہیے۔ \n\nمثال 1: \nان پٹ: جملہ = \"یہ ایک امتحان ہے\" \nآؤٹ پٹ: \"ہے\" \n\nمثال 2: \nان پٹ: جملہ = \"چلو تیراکی کے لیے چلیں\" \nآؤٹ پٹ: \"کے لیے جائیں\" \n\nرکاوٹیں: \n* 1 <= لین (جملہ) <= 100 \n* جملے میں صرف حروف ہوتے ہیں", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/66", "entry_point": "simplify", "test": "\n\narg00 = \"1/5\"\narg01 = \"5/1\"\nx0 = simplify(arg00, arg01)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"1/6\"\narg11 = \"2/1\"\nx1 = simplify(arg10, arg11)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"5/1\"\narg21 = \"3/1\"\nx2 = simplify(arg20, arg21)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"7/10\"\narg31 = \"10/2\"\nx3 = simplify(arg30, arg31)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"2/10\"\narg41 = \"50/10\"\nx4 = simplify(arg40, arg41)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"7/2\"\narg51 = \"4/2\"\nx5 = simplify(arg50, arg51)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"11/6\"\narg61 = \"6/1\"\nx6 = simplify(arg60, arg61)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"2/3\"\narg71 = \"5/2\"\nx7 = simplify(arg70, arg71)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"5/2\"\narg81 = \"3/5\"\nx8 = simplify(arg80, arg81)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = \"2/4\"\narg91 = \"8/4\"\nx9 = simplify(arg90, arg91)\nv9 = true\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = \"2/4\"\narg101 = \"4/2\"\nx10 = simplify(arg100, arg101)\nv10 = true\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = \"1/5\"\narg111 = \"5/1\"\nx11 = simplify(arg110, arg111)\nv11 = true\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = \"1/5\"\narg121 = \"1/5\"\nx12 = simplify(arg120, arg121)\nv12 = false\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\n", "description": "آپ کا کام ایک فنکشن کو نافذ کرنا ہے جو اظہار کو آسان بنائے گا \nx * n۔ فنکشن درست واپس کرتا ہے اگر x * n کسی پورے نمبر کا اندازہ کرتا ہے اور غلط \nبصورت دیگر۔ x اور n دونوں، ایک فریکشن کی سٹرنگ نمائندگی ہیں، اور ان کی شکل درج ذیل ہے، \n<numerator> <ڈینومینیٹر> جہاں numerator اور ڈینومینیٹر دونوں مثبت مکمل اعداد ہیں۔ \n\nآپ فرض کر سکتے ہیں کہ x، اور n درست فریکشن ہیں، اور ان میں ڈینومینیٹر کے طور پر صفر نہیں ہے۔ \n\nآسان بنائیں (\"1/5\"، \"5/1\") = درست \nآسان بنائیں (\"1/6\"، \"2/1\") = غلط \nآسان بنائیں (\"7/10\"، \"10/2\") = غلط", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/67", "entry_point": "order_by_points", "test": "\n\narg00 = [1, 11, -1, -11, -12]\nx0 = order_by_points(arg00)\nv0 = [-1, -11, 1, -12, 11]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]\nx1 = order_by_points(arg10)\nv1 = [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = []\nx2 = order_by_points(arg20)\nv2 = []\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1, -11, -32, 43, 54, -98, 2, -3]\nx3 = order_by_points(arg30)\nv3 = [-3, -32, -98, -11, 1, 2, 43, 54]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\nx4 = order_by_points(arg40)\nv4 = [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [0, 6, 6, -76, -21, 23, 4]\nx5 = order_by_points(arg50)\nv5 = [-76, -21, 0, 4, 23, 6, 6]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "ایک فنکشن لکھیں جو انٹیجرز کی دی گئی فہرست کو ترتیب دے \nان کے ہندسوں کے مجموعے کے مطابق چڑھتے ہوئے ترتیب میں۔ \nنوٹ: اگر کئی آئٹمز ہیں جن کے ہندسوں کا مجموعہ ایک جیسا ہے، \nاصل فہرست میں ان کے اشاریہ کی بنیاد پر انہیں آرڈر کریں۔ \n\nمثال کے طور پر: \n>>> آرڈر _ بائی _ پوائنٹس ([1، 11،-1،-11،-12]) = = [-1،-11، 1،-12، 11] \n>>> آرڈر _ بائی _ پوائنٹس ([]) = = []", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/68", "entry_point": "specialfilter", "test": "\n\narg00 = [5, -2, 1, -5]\nx0 = specialfilter(arg00)\nv0 = 0\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [15, -73, 14, -15]\nx1 = specialfilter(arg10)\nv1 = 1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [33, -2, -3, 45, 21, 109]\nx2 = specialfilter(arg20)\nv2 = 2\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [43, -12, 93, 125, 121, 109]\nx3 = specialfilter(arg30)\nv3 = 4\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [71, -2, -33, 75, 21, 19]\nx4 = specialfilter(arg40)\nv4 = 3\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [1]\nx5 = specialfilter(arg50)\nv5 = 0\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = []\nx6 = specialfilter(arg60)\nv6 = 0\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "ایک فنکشن لکھیں جو نمبروں کی صف کو ان پٹ اور ریٹرن کے طور پر لے \nصف میں عناصر کی تعداد جو 10 سے زیادہ ہے اور دونوں \nکسی عدد کے پہلے اور آخری ہندسے عجیب ہوتے ہیں (1، 3، 5، 7، 9)۔ \nمثال کے طور پر: \nاسپیشل فلٹر ([15،-73، 14،-15]) => 1 \nاسپیشل فلٹر ([33،-2،-3، 45، 21، 109]) => 2", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/69", "entry_point": "get_max_triples", "test": "\n\narg00 = 5\nx0 = get_max_triples(arg00)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 6\nx1 = get_max_triples(arg10)\nv1 = 4\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 10\nx2 = get_max_triples(arg20)\nv2 = 36\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 100\nx3 = get_max_triples(arg30)\nv3 = 53361\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "آپ کو ایک مثبت عدد n دیا جاتا ہے۔ آپ کو n لمبائی کا ایک عدد صف a بنانا ہوگا۔ \nہر ایک i (1 ≤ i ≤ n) کے لیے، a [i] = i * i-i + 1 کی قدر۔ \na کے تین گنا (a [i]، a [j]، a [k]) کی تعداد واپس کریں جہاں i <j <k، \nاور a [i] + a [j] + a [k] 3 کا ضرب ہے۔ \n\nمثال: \nان پٹ: n = 5 \nپیداوار: 1 \nوضاحت: \na = [1، 3، 7، 13، 21] \nواحد درست ٹرپل (1، 7، 13) ہے۔", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/70", "entry_point": "bf", "test": "\n\narg00 = \"Jupiter\"\narg01 = \"Neptune\"\nx0 = bf(arg00, arg01)\nv0 = [\"Saturn\", \"Uranus\"]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Earth\"\narg11 = \"Mercury\"\nx1 = bf(arg10, arg11)\nv1 = [\"Venus\"]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"Mercury\"\narg21 = \"Uranus\"\nx2 = bf(arg20, arg21)\nv2 = [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"Neptune\"\narg31 = \"Venus\"\nx3 = bf(arg30, arg31)\nv3 = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"Earth\"\narg41 = \"Earth\"\nx4 = bf(arg40, arg41)\nv4 = []\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"Mars\"\narg51 = \"Earth\"\nx5 = bf(arg50, arg51)\nv5 = []\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"Jupiter\"\narg61 = \"Makemake\"\nx6 = bf(arg60, arg61)\nv6 = []\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "ہمارے نظام شمسی میں آٹھ سیارے ہیں: سورج کے قریب ترین \nمرکری ہے، اگلا وینس ہے، پھر زمین، مریخ، مشتری، سیارہ، \nیورینس، نیپٹون۔ \nایک فنکشن لکھیں جو دو سیاروں کے ناموں کو سیارے 1 اور سیارے 2 کے طور پر لیتا ہے۔ \nفنکشن کو ایک ٹپل واپس کرنا چاہیے جس میں وہ تمام سیارے ہوں جن کے مدار ہیں \nسیارہ 1 کے مدار اور سیارہ 2 کے مدار کے درمیان واقع ہے، جس کے ذریعہ ترتیب دی گئی ہے \nسورج سے قربت۔ \nفنکشن کو خالی ٹپل واپس کرنا چاہیے اگر سیارہ 1 یا سیارہ 2 \nسیاروں کے نام درست نہیں ہیں۔ \nمثالیں \nbf (\"جپٹر\"، \"نیپٹون\") = => (\"سیٹرن\"، \"یورینس\") \nbf (\"زمین\"، \"مرکری\") = => (\"وینس\") \nbf (\"مرکری\"، \"یورینس\") = => (\"وینس\"، \"ارتھ\"، \"مارس\"، \"جپٹر\"، \"سیٹرن\")", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/71", "entry_point": "x_or_y", "test": "\n\narg00 = 7\narg01 = 34\narg02 = 12\nx0 = x_or_y(arg00, arg01, arg02)\nv0 = 34\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 15\narg11 = 8\narg12 = 5\nx1 = x_or_y(arg10, arg11, arg12)\nv1 = 5\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 3\narg21 = 33\narg22 = 5212\nx2 = x_or_y(arg20, arg21, arg22)\nv2 = 33\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 1259\narg31 = 3\narg32 = 52\nx3 = x_or_y(arg30, arg31, arg32)\nv3 = 3\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 7919\narg41 = -1\narg42 = 12\nx4 = x_or_y(arg40, arg41, arg42)\nv4 = -1\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 3609\narg51 = 1245\narg52 = 583\nx5 = x_or_y(arg50, arg51, arg52)\nv5 = 583\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 91\narg61 = 56\narg62 = 129\nx6 = x_or_y(arg60, arg61, arg62)\nv6 = 129\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 6\narg71 = 34\narg72 = 1234\nx7 = x_or_y(arg70, arg71, arg72)\nv7 = 1234\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 1\narg81 = 2\narg82 = 0\nx8 = x_or_y(arg80, arg81, arg82)\nv8 = 0\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 2\narg91 = 2\narg92 = 0\nx9 = x_or_y(arg90, arg91, arg92)\nv9 = 2\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\n", "description": "ایک سادہ پروگرام جو x کی قیمت واپس کرے اگر n ہے \nایک پرائم نمبر ہے اور اسے دوسری صورت میں y کی قیمت واپس کرنی چاہیے۔ \n\nمثالیں: \nx _ یا _ y کے لیے (7، 34، 12) = = 34 \nx _ یا _ y کے لیے (15، 8، 5) = = 5", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/72", "entry_point": "double_the_difference", "test": "\n\narg00 = []\nx0 = double_the_difference(arg00)\nv0 = 0\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [5, 4]\nx1 = double_the_difference(arg10)\nv1 = 25\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [0.1, 0.2, 0.3]\nx2 = double_the_difference(arg20)\nv2 = 0\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [-10, -20, -30]\nx3 = double_the_difference(arg30)\nv3 = 0\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [-1, -2, 8]\nx4 = double_the_difference(arg40)\nv4 = 0\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [0.2, 3, 5]\nx5 = double_the_difference(arg50)\nv5 = 34\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [-99, -97, -95, -93, -91, -89, -87, -85, -83, -81, -79, -77, -75, -73, -71, -69, -67, -65, -63, -61, -59, -57, -55, -53, -51, -49, -47, -45, -43, -41, -39, -37, -35, -33, -31, -29, -27, -25, -23, -21, -19, -17, -15, -13, -11, -9, -7, -5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99]\nx6 = double_the_difference(arg60)\nv6 = 166650\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "اعداد کی فہرست کو دیکھتے ہوئے، اعداد کے مربعوں کا مجموعہ واپس کریں \nاس فہرست میں جو عجیب ہیں۔ ان نمبروں کو نظر انداز کریں جو منفی ہیں یا انٹیجر نہیں ہیں۔ \n\nڈبل _ دی _ فرق ([1، 3، 2، 0]) = = 1 + 9 + 0 + 0 = 10 \nڈبل _ دی _ فرق ([-1،-2، 0]) = = 0 \nڈبل _ دی _ فرق ([9,-2]) = = 81 \nڈبل _ دی _ فرق ([0]) = = 0 \n\nاگر ان پٹ لسٹ خالی ہے تو 0 واپس کریں۔", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/73", "entry_point": "strongest_extension", "test": "\n\narg00 = \"Watashi\"\narg01 = [\"tEN\", \"niNE\", \"eIGHt8OKe\"]\nx0 = strongest_extension(arg00, arg01)\nv0 = \"Watashi.eIGHt8OKe\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Boku123\"\narg11 = [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]\nx1 = strongest_extension(arg10, arg11)\nv1 = \"Boku123.YEs.WeCaNe\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"__YESIMHERE\"\narg21 = [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]\nx2 = strongest_extension(arg20, arg21)\nv2 = \"__YESIMHERE.NuLl__\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"K\"\narg31 = [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]\nx3 = strongest_extension(arg30, arg31)\nv3 = \"K.TAR\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"__HAHA\"\narg41 = [\"Tab\", \"123\", \"781345\", \"-_-\"]\nx4 = strongest_extension(arg40, arg41)\nv4 = \"__HAHA.123\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"YameRore\"\narg51 = [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]\nx5 = strongest_extension(arg50, arg51)\nv5 = \"YameRore.okIWILL123\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"finNNalLLly\"\narg61 = [\"Die\", \"NowW\", \"Wow\", \"WoW\"]\nx6 = strongest_extension(arg60, arg61)\nv6 = \"finNNalLLly.WoW\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"_\"\narg71 = [\"Bb\", \"91245\"]\nx7 = strongest_extension(arg70, arg71)\nv7 = \"_.Bb\"\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"Sp\"\narg81 = [\"671235\", \"Bb\"]\nx8 = strongest_extension(arg80, arg81)\nv8 = \"Sp.671235\"\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "آپ کو ایک کلاس کا نام (ایک سٹرنگ) اور ایکسٹینشنز کی فہرست دی جائے گی۔ \nایکسٹینشنز کو کلاس میں اضافی کلاسز لوڈ کرنے کے لیے استعمال کیا جانا ہے۔ \nتوسیع کی طاقت مندرجہ ذیل ہے: سی اے پی کو بڑے حرف کا نمبر ہونے دیں۔ \nتوسیع کے نام میں حروف، اور ایس ایم کو چھوٹے حروف کی تعداد ہونے دیں \nتوسیع کے نام میں، طاقت کا حصہ CAP-एसएम کے ذریعے دیا جاتا ہے۔ \nآپ کو سب سے مضبوط ایکسٹینشن تلاش کرنی چاہیے اور اس میں ایک سٹرنگ واپس کرنی چاہیے۔ \nفارمیٹ: ClassName.StrongestExtensionName۔ \nاگر ایک ہی طاقت کے ساتھ دو یا زیادہ توسیعات ہیں، تو آپ کو چاہیے \nفہرست میں سب سے پہلے آنے والے کا انتخاب کریں۔ \nمثال کے طور پر، اگر آپ کو کلاس اور فہرست کے طور پر \"سلائسز\" دیا گیا ہے \nتوسیعات: ['SERVINGSliCes'،'چیز'،'سٹوفڈ'] پھر آپ کو کرنا چاہیے \nواپسی'Slices.SErviNGSliCes'چونکہ'SERVINGSliCes'سب سے مضبوط توسیع ہے \n(اس کی طاقت-1 ہے)۔ \nمثال: \nمضبوط ترین _ ایکسٹینشن کے لیے ('مائی _ کلاس'، ['AA'،'Be'،'CC']) = ='my_class.AA'", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/74", "entry_point": "cycpattern_check", "test": "\n\narg00 = \"xyzw\"\narg01 = \"xyw\"\nx0 = cycpattern_check(arg00, arg01)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"yello\"\narg11 = \"ell\"\nx1 = cycpattern_check(arg10, arg11)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"whattup\"\narg21 = \"ptut\"\nx2 = cycpattern_check(arg20, arg21)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"efef\"\narg31 = \"fee\"\nx3 = cycpattern_check(arg30, arg31)\nv3 = true\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"abab\"\narg41 = \"aabb\"\nx4 = cycpattern_check(arg40, arg41)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"winemtt\"\narg51 = \"tinem\"\nx5 = cycpattern_check(arg50, arg51)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "آپ کو 2 الفاظ دیے گئے ہیں۔ اگر دوسرا لفظ یا اس کی کوئی گردش پہلے لفظ میں سبسٹرنگ ہے تو آپ کو سچ واپس کرنے کی ضرورت ہے۔ \nسائیک پیٹرن _ چیک (\"اے بی سی ڈی\"، \"اے بی ڈی\") => غلط \nسائیک پیٹرن _ چیک (\"ہیلو\"، \"ایل\") => درست \nسائیک پیٹرن _ چیک (\"وس اپ\"، \"psus\") => غلط \nسائیک پیٹرن _ چیک (\"اباب\"، \"با\") => درست \nسائیک پیٹرن _ چیک (\"ایفیف\"، \"ایفیف\") => غلط \nسائیک پیٹرن _ چیک (\"ہیمینس\"، \"سیمین\") => درست", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/75", "entry_point": "int_to_mini_roman", "test": "\n\narg00 = 19\nx0 = int_to_mini_roman(arg00)\nv0 = \"xix\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 152\nx1 = int_to_mini_roman(arg10)\nv1 = \"clii\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 251\nx2 = int_to_mini_roman(arg20)\nv2 = \"ccli\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 426\nx3 = int_to_mini_roman(arg30)\nv3 = \"cdxxvi\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 500\nx4 = int_to_mini_roman(arg40)\nv4 = \"d\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 1\nx5 = int_to_mini_roman(arg50)\nv5 = \"i\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 4\nx6 = int_to_mini_roman(arg60)\nv6 = \"iv\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 43\nx7 = int_to_mini_roman(arg70)\nv7 = \"xliii\"\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 90\nx8 = int_to_mini_roman(arg80)\nv8 = \"xc\"\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 94\nx9 = int_to_mini_roman(arg90)\nv9 = \"xciv\"\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = 532\nx10 = int_to_mini_roman(arg100)\nv10 = \"dxxxii\"\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = 900\nx11 = int_to_mini_roman(arg110)\nv11 = \"cm\"\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = 994\nx12 = int_to_mini_roman(arg120)\nv12 = \"cmxciv\"\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\narg130 = 1000\nx13 = int_to_mini_roman(arg130)\nv13 = \"m\"\nif x13 != v13\n    raise StandardError, \"Error at test case 14\"\nend\n\n", "description": "ایک مثبت عدد کو دیکھتے ہوئے، اس کے رومن ہندسے کے مساوی سٹرنگ کے طور پر حاصل کریں، \nاور اسے چھوٹے حروف میں واپس کر دیں۔ \nپابندیاں: 1 <= num <= 1000 \n\nمثالیں: \n>>> int _ to _ منی _ رومن (19) = ='xix'\n>>> int _ to _ منی _ رومن (152) = ='کلائی'\n>>> int _ to _ منی _ رومن (426) = ='cdxxvi'", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/76", "entry_point": "right_angle_triangle", "test": "\n\narg00 = 3\narg01 = 4\narg02 = 5\nx0 = right_angle_triangle(arg00, arg01, arg02)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 1\narg11 = 2\narg12 = 3\nx1 = right_angle_triangle(arg10, arg11, arg12)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 10\narg21 = 6\narg22 = 8\nx2 = right_angle_triangle(arg20, arg21, arg22)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 2\narg31 = 2\narg32 = 2\nx3 = right_angle_triangle(arg30, arg31, arg32)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 7\narg41 = 24\narg42 = 25\nx4 = right_angle_triangle(arg40, arg41, arg42)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 10\narg51 = 5\narg52 = 7\nx5 = right_angle_triangle(arg50, arg51, arg52)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 5\narg61 = 12\narg62 = 13\nx6 = right_angle_triangle(arg60, arg61, arg62)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 15\narg71 = 8\narg72 = 17\nx7 = right_angle_triangle(arg70, arg71, arg72)\nv7 = true\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 48\narg81 = 55\narg82 = 73\nx8 = right_angle_triangle(arg80, arg81, arg82)\nv8 = true\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 1\narg91 = 1\narg92 = 1\nx9 = right_angle_triangle(arg90, arg91, arg92)\nv9 = false\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = 2\narg101 = 2\narg102 = 10\nx10 = right_angle_triangle(arg100, arg101, arg102)\nv10 = false\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\n", "description": "مثلث کے تینوں اطراف کی لمبائی کو دیکھتے ہوئے۔ اگر تینوں ہوں تو درست واپس کریں۔ \nاطراف دائیں زاویہ مثلث بناتے ہیں، بصورت دیگر غلط۔ \nدائیں زاویہ والا مثلث ایک مثلث ہے جس میں ایک زاویہ صحیح زاویہ یا \n90 ڈگری۔ \nمثال: \nدائیں _ زاویہ _ مثلث (3، 4، 5) = = درست \nدائیں _ زاویہ _ مثلث (1، 2، 3) = = غلط", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/77", "entry_point": "solve", "test": "\n\narg00 = \"AsDf\"\nx0 = solve(arg00)\nv0 = \"aSdF\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"1234\"\nx1 = solve(arg10)\nv1 = \"4321\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"ab\"\nx2 = solve(arg20)\nv2 = \"AB\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"#a@C\"\nx3 = solve(arg30)\nv3 = \"#A@c\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"#AsdfW^45\"\nx4 = solve(arg40)\nv4 = \"#aSDFw^45\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"#6@2\"\nx5 = solve(arg50)\nv5 = \"2@6#\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"#\\$a^D\"\nx6 = solve(arg60)\nv6 = \"#\\$A^d\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"#ccc\"\nx7 = solve(arg70)\nv7 = \"#CCC\"\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\n", "description": "آپ کو ایک سٹرنگ s دی گئی ہے۔ \nاگر s [i] ایک حرف ہے، تو اس کے معاملے کو نچلے سے اوپری یا اس کے برعکس موڑ دیں، \nورنہ اسے جیسا ہے ویسا ہی رکھیں۔ \nاگر سٹرنگ میں کوئی حرف نہ ہوں تو سٹرنگ کو الٹ دیں۔ \nفنکشن کو نتیجہ خیز سٹرنگ واپس کرنی چاہیے۔ \nمثالیں \nحل کریں (\"1234\") = \"4321\" \nحل کریں (\"اب\") = \"اے بی\" \nحل کریں (\"#a @C\") = \"#A @c\"", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/78", "entry_point": "string_to_md5", "test": "\n\narg00 = \"Hello world\"\nx0 = string_to_md5(arg00)\nv0 = \"3e25960a79dbc69b674cd4ec67a72c62\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"\"\nx1 = string_to_md5(arg10)\nv1 = nil\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"A B C\"\nx2 = string_to_md5(arg20)\nv2 = \"0ef78513b0cb8cef12743f5aeb35f888\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"password\"\nx3 = string_to_md5(arg30)\nv3 = \"5f4dcc3b5aa765d61d8327deb882cf99\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "سٹرنگ'ٹیکسٹ'کو دیکھتے ہوئے، اس کی ایم ڈی 5 ہیش کے مساوی سٹرنگ واپس کریں۔ \nاگر'ٹیکسٹ'ایک خالی سٹرنگ ہے، تو کالعدم واپس کریں۔ \n\n>>> سٹرنگ _ سے _ md5 ('ہیلو ورلڈ') = ='3e25960a79dbc69b674cd4ec67a72c62'", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
{"task_id": "ruby/79", "entry_point": "generate_integers", "test": "\n\narg00 = 2\narg01 = 10\nx0 = generate_integers(arg00, arg01)\nv0 = [2, 4, 6, 8]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 10\narg11 = 2\nx1 = generate_integers(arg10, arg11)\nv1 = [2, 4, 6, 8]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 132\narg21 = 2\nx2 = generate_integers(arg20, arg21)\nv2 = [2, 4, 6, 8]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 17\narg31 = 89\nx3 = generate_integers(arg30, arg31)\nv3 = []\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "دو مثبت عددوں a اور b کو دیکھتے ہوئے، a کے درمیان کے یکساں ہندسوں کو واپس کریں۔ \nاور ب، چڑھتے ہوئے ترتیب میں۔ \n\nمثال کے طور پر: \nجنریٹ _ انٹیجرز (2، 8) => [2، 4، 6، 8] \nجنریٹ _ انٹیجرز (8، 2) => [2، 4، 6، 8] \nجنریٹ _ انٹیجرز (10، 14) => []", "language": "ruby", "canonical_solution": null, "natural_language": "Urdu"}
