{"task_id": "ruby/0", "entry_point": "below_zero", "test": "\n\narg00 = []\nx0 = below_zero(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 2, -3, 1, 2, -3]\nx1 = below_zero(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 2, -4, 5, 6]\nx2 = below_zero(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1, -1, 2, -2, 5, -5, 4, -4]\nx3 = below_zero(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, -1, 2, -2, 5, -5, 4, -5]\nx4 = below_zero(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [1, -2, 2, -2, 5, -5, 4, -4]\nx5 = below_zero(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "आपको बैंक खाते में जमा और निकासी कार्यों की एक सूची दी जाती है जो किस से शुरू होती है \nशून्य शेष राशि। आपका काम यह पता लगाना है कि क्या किसी भी समय खाते की शेष राशि शून्य से नीचे गिरती है, और \nउस बिंदु पर फ़ंक्शन को सही लौटाना चाहिए। अन्यथा इसे गलत लौटाना चाहिए। \n>>> शून्य से नीचे ([1,2,3]) \nझूठ बोलती है। \n>>> शून्य से नीचे ([1,2,-4,5]) \nसच है।", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/1", "entry_point": "sum_product", "test": "\n\narg00 = []\nx0 = sum_product(arg00)\nv0 = [0, 1]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 1, 1]\nx1 = sum_product(arg10)\nv1 = [3, 1]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [100, 0]\nx2 = sum_product(arg20)\nv2 = [100, 0]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [3, 5, 7]\nx3 = sum_product(arg30)\nv3 = [15, 105]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [10]\nx4 = sum_product(arg40)\nv4 = [10, 10]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "पूर्णांकों की दी गई सूची के लिए, एक टुपल वापस करें जिसमें एक सूची में सभी पूर्णांकों का योग और एक गुणनफल हो। \nखाली राशि 0 के बराबर होनी चाहिए और खाली उत्पाद 1 के बराबर होना चाहिए। \n>>> sum _ product ([]) \n(0,1) \n>>> sum _ product ([1,2,3,4]) \n(10,24)", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/2", "entry_point": "string_xor", "test": "\n\narg00 = \"111000\"\narg01 = \"101010\"\nx0 = string_xor(arg00, arg01)\nv0 = \"010010\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"1\"\narg11 = \"1\"\nx1 = string_xor(arg10, arg11)\nv1 = \"0\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"0101\"\narg21 = \"0000\"\nx2 = string_xor(arg20, arg21)\nv2 = \"0101\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\n", "description": "इनपुट दो स्ट्रिंग a और b हैं जिनमें केवल 1s और 0s होते हैं। \nइन निवेशों पर द्विआधारी XOR करें और एक स्ट्रिंग के रूप में परिणाम भी वापस करें। \n>>> स्ट्रिंग _ xor ('010','110') \n'100'", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/3", "entry_point": "longest", "test": "\n\narg00 = []\nx0 = longest(arg00)\nv0 = nil\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [\"x\", \"y\", \"z\"]\nx1 = longest(arg10)\nv1 = \"x\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]\nx2 = longest(arg20)\nv2 = \"zzzz\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\n", "description": "स्ट्रिंग्स की सूची में से सबसे लंबा स्ट्रिंग्स वापस करें। कई स्ट्रिंग्स होने पर पहला स्ट्रिंग्स वापस करें। \nसमान लंबाई के स्ट्रिंग। यदि इनपुट सूची खाली है तो शून्य लौटें। \n>>> सबसे लंबा ([]) \n\n>>> सबसे लंबा (['ए','बी','सी']) \n'ए'\n>>> सबसे लंबा (['ए','बीबी','सीसीसी']) \n'सी. सी. सी.'", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/4", "entry_point": "greatest_common_divisor", "test": "\n\narg00 = 3\narg01 = 7\nx0 = greatest_common_divisor(arg00, arg01)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 10\narg11 = 15\nx1 = greatest_common_divisor(arg10, arg11)\nv1 = 5\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 49\narg21 = 14\nx2 = greatest_common_divisor(arg20, arg21)\nv2 = 7\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 144\narg31 = 60\nx3 = greatest_common_divisor(arg30, arg31)\nv3 = 12\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "दो पूर्णांकों a और b का सबसे बड़ा सामान्य भाजक वापस करें \n>>> ग्रेटेस्ट _ कॉमन _ डिवाइजर (3,5) \n1. \n>>> ग्रेटेस्ट _ कॉमन _ डिवाइजर (25,15) \n5.", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/5", "entry_point": "sort_numbers", "test": "\n\narg00 = \"\"\nx0 = sort_numbers(arg00)\nv0 = \"\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"three\"\nx1 = sort_numbers(arg10)\nv1 = \"three\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"three five nine\"\nx2 = sort_numbers(arg20)\nv2 = \"three five nine\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"five zero four seven nine eight\"\nx3 = sort_numbers(arg30)\nv3 = \"zero four five seven eight nine\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"six five four three two one zero\"\nx4 = sort_numbers(arg40)\nv4 = \"zero one two three four five six\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "इनपुट'शून्य'से'नौ'तक की संख्याओं की एक स्थान-सीमित स्ट्रिंग है। \nवैध विकल्प'शून्य','एक','दो','तीन','चार','पाँच','छह','सात','आठ'और'नौ'हैं। \nस्ट्रिंग को सबसे छोटी से सबसे बड़ी तक क्रमबद्ध संख्याओं के साथ वापस करें \n>>> छँटाई संख्याएँ ('तीन एक पाँच') \n'एक तीन पाँच'", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/6", "entry_point": "rescale_to_unit", "test": "\n\narg00 = [2.0, 49.9]\nx0 = rescale_to_unit(arg00)\nv0 = [0.0, 1.0]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [100.0, 49.9]\nx1 = rescale_to_unit(arg10)\nv1 = [1.0, 0.0]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1.0, 2.0, 3.0, 4.0, 5.0]\nx2 = rescale_to_unit(arg20)\nv2 = [0.0, 0.25, 0.5, 0.75, 1.0]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [2.0, 1.0, 5.0, 3.0, 4.0]\nx3 = rescale_to_unit(arg30)\nv3 = [0.25, 0.0, 1.0, 0.5, 0.75]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [12.0, 11.0, 15.0, 13.0, 14.0]\nx4 = rescale_to_unit(arg40)\nv4 = [0.25, 0.0, 1.0, 0.5, 0.75]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "संख्याओं की सूची (कम से कम दो तत्वों की) को देखते हुए, उस सूची में एक रैखिक परिवर्तन लागू करें, \nकि सबसे छोटी संख्या 0 हो जाएगी और सबसे बड़ी संख्या 1 हो जाएगी। \n>>> इकाई को पुनः प्राप्त करें ([1, 2, 3, 4, 5]) \n[0,0,25,0,0.75,1.0]", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/7", "entry_point": "flip_case", "test": "\n\narg00 = \"\"\nx0 = flip_case(arg00)\nv0 = \"\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Hello!\"\nx1 = flip_case(arg10)\nv1 = \"hELLO!\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"These violent delights have violent ends\"\nx2 = flip_case(arg20)\nv2 = \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\n", "description": "किसी दिए गए स्ट्रिंग के लिए, छोटे अक्षरों को बड़े अक्षरों में और बड़े अक्षरों को छोटे अक्षरों में बदलें। \n>>> फ़्लिप केस ('हैलो') \n'हैलो'", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/8", "entry_point": "get_positive", "test": "\n\narg00 = [-1, -2, 4, 5, 6]\nx0 = get_positive(arg00)\nv0 = [4, 5, 6]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]\nx1 = get_positive(arg10)\nv1 = [5, 3, 2, 3, 3, 9, 123, 1]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [-1, -2]\nx2 = get_positive(arg20)\nv2 = []\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = []\nx3 = get_positive(arg30)\nv3 = []\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "सूची में केवल सकारात्मक संख्याएँ वापस करें। \n>>> सकारात्मक प्राप्त करें ([-1,2,-4,5,6]) \n[2,5,6] \n>>> सकारात्मक प्राप्त करें ([5,3,-5,2,-3,3,9,0,123,1,-10]) \n[5,3,2,3,9,123,1]", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/9", "entry_point": "is_prime", "test": "\n\narg00 = 6\nx0 = is_prime(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 101\nx1 = is_prime(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 11\nx2 = is_prime(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 13441\nx3 = is_prime(arg30)\nv3 = true\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 61\nx4 = is_prime(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 4\nx5 = is_prime(arg50)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 1\nx6 = is_prime(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 5\nx7 = is_prime(arg70)\nv7 = true\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 11\nx8 = is_prime(arg80)\nv8 = true\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 17\nx9 = is_prime(arg90)\nv9 = true\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = 85\nx10 = is_prime(arg100)\nv10 = false\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = 77\nx11 = is_prime(arg110)\nv11 = false\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = 255379\nx12 = is_prime(arg120)\nv12 = false\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\n", "description": "यदि कोई दी गई संख्या अभाज्य है तो सही वापस करें, और अन्यथा गलत। \n>>> प्राइम है (6) \nझूठ बोलती है। \n>>> इस _ प्राइम (101) है \nसच है। \n>>> प्राइम है (11) \nसच है। \n= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \nसच है। \n>>> इस _ प्राइम (61) \nसच है। \n>>> प्राइम है (4) \nझूठ बोलती है। \n>>> प्राइम है (1) \nझूठ बोलती है।", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/10", "entry_point": "unique", "test": "\n\narg00 = [5, 3, 5, 2, 3, 3, 9, 0, 123]\nx0 = unique(arg00)\nv0 = [0, 2, 3, 5, 9, 123]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\n", "description": "एक सूची में क्रमबद्ध अद्वितीय तत्वों को वापस करें \n>>> अद्वितीय ([5,3,5,2,3,3,9,0,123]) \n[0,2,3,5,9,123]", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/11", "entry_point": "prime_fib", "test": "\n\narg00 = 1\nx0 = prime_fib(arg00)\nv0 = 2\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 2\nx1 = prime_fib(arg10)\nv1 = 3\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 3\nx2 = prime_fib(arg20)\nv2 = 5\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 4\nx3 = prime_fib(arg30)\nv3 = 13\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 5\nx4 = prime_fib(arg40)\nv4 = 89\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 6\nx5 = prime_fib(arg50)\nv5 = 233\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 7\nx6 = prime_fib(arg60)\nv6 = 1597\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 8\nx7 = prime_fib(arg70)\nv7 = 28657\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 9\nx8 = prime_fib(arg80)\nv8 = 514229\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 10\nx9 = prime_fib(arg90)\nv9 = 433494437\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\n", "description": "प्राइम _ फाइब n-th संख्या बताता है जो एक फिबोनाची संख्या है और यह भी अभाज्य है। \n>>> प्राइम _ फाइब (1) \n2. \n>>> प्राइम _ फाइब (2) \n3. \n>>> प्राइम _ फाइब (3) \n5. \n>>> प्राइम _ फाइब (4) \n13. \n>>> प्राइम _ फाइब (5) \n89", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/12", "entry_point": "triples_sum_to_zero", "test": "\n\narg00 = [1, 3, 5, 0]\nx0 = triples_sum_to_zero(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 3, 5, -1]\nx1 = triples_sum_to_zero(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 3, -2, 1]\nx2 = triples_sum_to_zero(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1, 2, 3, 7]\nx3 = triples_sum_to_zero(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 2, 5, 7]\nx4 = triples_sum_to_zero(arg40)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [2, 4, -5, 3, 9, 7]\nx5 = triples_sum_to_zero(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [1]\nx6 = triples_sum_to_zero(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [1, 3, 5, -100]\nx7 = triples_sum_to_zero(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [100, 3, 5, -100]\nx8 = triples_sum_to_zero(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "ट्रिपल्स _ सम _ से _ जीरो एक इनपुट के रूप में पूर्णांकों की एक सूची लेता है। \nयह सही बताता है यदि सूची में तीन अलग-अलग तत्व हैं जो \nशून्य का योग, और अन्यथा गलत। \n\n>>> ट्रिपल _ सम _ से _ शून्य ([1,35,5,0]) \nझूठ बोलती है। \n>>> ट्रिपल _ सम _ से _ शून्य ([1,3,-2,1]) \nसच है। \n>>> ट्रिपल _ सम _ से _ शून्य ([1,2,3,7]) \nझूठ बोलती है। \n>>> ट्रिपल _ सम _ से _ शून्य ([2,4,-5,3,9,7]) \nसच है। \n>>> ट्रिपल _ सम _ से _ शून्य ([1]) \nझूठ बोलती है।", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/13", "entry_point": "pairs_sum_to_zero", "test": "\n\narg00 = [1, 3, 5, 0]\nx0 = pairs_sum_to_zero(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 3, -2, 1]\nx1 = pairs_sum_to_zero(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 2, 3, 7]\nx2 = pairs_sum_to_zero(arg20)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [2, 4, -5, 3, 5, 7]\nx3 = pairs_sum_to_zero(arg30)\nv3 = true\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1]\nx4 = pairs_sum_to_zero(arg40)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [-3, 9, -1, 3, 2, 30]\nx5 = pairs_sum_to_zero(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [-3, 9, -1, 3, 2, 31]\nx6 = pairs_sum_to_zero(arg60)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [-3, 9, -1, 4, 2, 30]\nx7 = pairs_sum_to_zero(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [-3, 9, -1, 4, 2, 31]\nx8 = pairs_sum_to_zero(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "pair _ sum _ to _ zero पूर्णांकों की एक सूची को एक इनपुट के रूप में लेता है। \nयह सही बताता है यदि सूची में दो अलग-अलग तत्व हैं जो \nशून्य का योग, और अन्यथा गलत। \n>>> जोड़े _ योग _ से _ शून्य ([1,3,5,0]) \nझूठ बोलती है। \n>>> जोड़े _ योग _ से _ शून्य ([1,3,-2,1]) \nझूठ बोलती है। \n>>> जोड़े _ योग _ से _ शून्य ([1,2,3,7]) \nझूठ बोलती है। \n>>> जोड़े _ योग _ से _ शून्य ([2,4,-5,3,5,7]) \nसच है। \n>>> जोड़े _ योग _ से _ शून्य ([1]) \nझूठ बोलती है।", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/14", "entry_point": "fib4", "test": "\n\narg00 = 5\nx0 = fib4(arg00)\nv0 = 4\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 8\nx1 = fib4(arg10)\nv1 = 28\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 10\nx2 = fib4(arg20)\nv2 = 104\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 12\nx3 = fib4(arg30)\nv3 = 386\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "फाइब4 संख्या अनुक्रम फाइबोनैचि सेकुनेस के समान एक अनुक्रम है जिसे निम्नानुसार परिभाषित किया गया हैः \nfib4 (0)-> 0 \nफाइब 4 (1)-> 0 \nफाइब 4 (2)-> 2 \nफाइब 4 (3)-> 0 \nफाइब 4 (एन)-> फाइब 4 (एन-1) + फाइब 4 (एन-2) + फाइब 4 (एन-3) + फाइब 4 (एन-4)। \nकृपया तन्तु 4 संख्या अनुक्रम के n-th तत्व की कुशलता से गणना करने के लिए एक कार्य लिखें। पुनरावृत्ति का उपयोग न करें। \n>>> फाइब4 (5) \n4. \n>>> fib4 (6) \n8. \n>>> fib4 (7) \n14.", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/15", "entry_point": "median", "test": "\n\narg00 = [3, 1, 2, 4, 5]\nx0 = median(arg00)\nv0 = 3\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [-10, 4, 6, 1000, 10, 20]\nx1 = median(arg10)\nv1 = 8.0\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [5]\nx2 = median(arg20)\nv2 = 5\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [6, 5]\nx3 = median(arg30)\nv3 = 5.5\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [8, 1, 3, 9, 9, 2, 7]\nx4 = median(arg40)\nv4 = 7\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "सूची एल में तत्वों का माध्यिका वापस करें। \n>>> माध्यिका ([3,1,2,4,5]) \n3. \n>>> माध्यिका ([-10,4,6,1000,10,20]) \n15. 0", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/16", "entry_point": "is_palindrome", "test": "\n\narg00 = \"\"\nx0 = is_palindrome(arg00)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"aba\"\nx1 = is_palindrome(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"aaaaa\"\nx2 = is_palindrome(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"zbcd\"\nx3 = is_palindrome(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"xywyx\"\nx4 = is_palindrome(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"xywyz\"\nx5 = is_palindrome(arg50)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"xywzx\"\nx6 = is_palindrome(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "जाँच करता है कि क्या दी गई स्ट्रिंग एक पालिंड्रोम है \n>>> इस _ पालिंड्रोम (\") है \nसच है। \n>>> इस _ पालिंड्रोम ('अबा') है \nसच है। \n>>> इस _ पालिंड्रोम ('एएएएए') है \nसच है। \n>>> is _ palindrom ('zbcd') है \nझूठ बोलती है।", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/17", "entry_point": "remove_vowels", "test": "\n\narg00 = \"\"\nx0 = remove_vowels(arg00)\nv0 = \"\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"abcdef\\nghijklm\"\nx1 = remove_vowels(arg10)\nv1 = \"bcdf\\nghjklm\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"fedcba\"\nx2 = remove_vowels(arg20)\nv2 = \"fdcb\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"eeeee\"\nx3 = remove_vowels(arg30)\nv3 = \"\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"acBAA\"\nx4 = remove_vowels(arg40)\nv4 = \"cB\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"EcBOO\"\nx5 = remove_vowels(arg50)\nv5 = \"cB\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"ybcd\"\nx6 = remove_vowels(arg60)\nv6 = \"ybcd\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "रिमूव _ वॉवेल्स एक ऐसा फंक्शन है जो स्ट्रिंग लेता है और बिना स्वर के स्ट्रिंग लौटाता है। \n>>> स्वर हटाएँ (\") \n\"\n>>> स्वरों को हटाएँ (\"abcdef\\nghijklm\") \n'बी. सी. डी. एफ. \\एनजी. जे. के. एल. एम.'\n>>> स्वरों को हटाएँ ('abcdef') \n'बी. सी. डी. एफ.'\n>>> स्वरों को हटाएँ ('एएएए') \n\"\n>>> स्वरों को हटाएँ ('एएबीएए') \n'बी'\n>>> स्वर हटाएँ ('zbcd') \n'जेड. बी. सी. डी.'", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/18", "entry_point": "below_threshold", "test": "\n\narg00 = [1, 2, 4, 10]\narg01 = 100\nx0 = below_threshold(arg00, arg01)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 20, 4, 10]\narg11 = 5\nx1 = below_threshold(arg10, arg11)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 20, 4, 10]\narg21 = 21\nx2 = below_threshold(arg20, arg21)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1, 20, 4, 10]\narg31 = 22\nx3 = below_threshold(arg30, arg31)\nv3 = true\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 8, 4, 10]\narg41 = 11\nx4 = below_threshold(arg40, arg41)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [1, 8, 4, 10]\narg51 = 10\nx5 = below_threshold(arg50, arg51)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "सही लौटें यदि सूची में सभी संख्याएँ t की सीमा से नीचे हैं। \n>>> थ्रेसहोल्ड के नीचे ([1,2,4,10], 100) \nसच है। \n>>> थ्रेसहोल्ड के नीचे ([1,20,4,10], 5) \nझूठ बोलती है।", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/19", "entry_point": "add", "test": "\n\narg00 = 0\narg01 = 1\nx0 = add(arg00, arg01)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 1\narg11 = 0\nx1 = add(arg10, arg11)\nv1 = 1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 2\narg21 = 3\nx2 = add(arg20, arg21)\nv2 = 5\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 5\narg31 = 7\nx3 = add(arg30, arg31)\nv3 = 12\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 7\narg41 = 5\nx4 = add(arg40, arg41)\nv4 = 12\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 572\narg51 = 725\nx5 = add(arg50, arg51)\nv5 = 1297\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 51\narg61 = 804\nx6 = add(arg60, arg61)\nv6 = 855\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 645\narg71 = 96\nx7 = add(arg70, arg71)\nv7 = 741\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 712\narg81 = 853\nx8 = add(arg80, arg81)\nv8 = 1565\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 223\narg91 = 101\nx9 = add(arg90, arg91)\nv9 = 324\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = 76\narg101 = 29\nx10 = add(arg100, arg101)\nv10 = 105\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = 416\narg111 = 149\nx11 = add(arg110, arg111)\nv11 = 565\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = 145\narg121 = 409\nx12 = add(arg120, arg121)\nv12 = 554\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\narg130 = 535\narg131 = 430\nx13 = add(arg130, arg131)\nv13 = 965\nif x13 != v13\n    raise StandardError, \"Error at test case 14\"\nend\n\narg140 = 118\narg141 = 303\nx14 = add(arg140, arg141)\nv14 = 421\nif x14 != v14\n    raise StandardError, \"Error at test case 15\"\nend\n\narg150 = 287\narg151 = 94\nx15 = add(arg150, arg151)\nv15 = 381\nif x15 != v15\n    raise StandardError, \"Error at test case 16\"\nend\n\narg160 = 768\narg161 = 257\nx16 = add(arg160, arg161)\nv16 = 1025\nif x16 != v16\n    raise StandardError, \"Error at test case 17\"\nend\n\narg170 = 421\narg171 = 677\nx17 = add(arg170, arg171)\nv17 = 1098\nif x17 != v17\n    raise StandardError, \"Error at test case 18\"\nend\n\narg180 = 802\narg181 = 814\nx18 = add(arg180, arg181)\nv18 = 1616\nif x18 != v18\n    raise StandardError, \"Error at test case 19\"\nend\n\narg190 = 510\narg191 = 922\nx19 = add(arg190, arg191)\nv19 = 1432\nif x19 != v19\n    raise StandardError, \"Error at test case 20\"\nend\n\narg200 = 345\narg201 = 819\nx20 = add(arg200, arg201)\nv20 = 1164\nif x20 != v20\n    raise StandardError, \"Error at test case 21\"\nend\n\narg210 = 895\narg211 = 436\nx21 = add(arg210, arg211)\nv21 = 1331\nif x21 != v21\n    raise StandardError, \"Error at test case 22\"\nend\n\narg220 = 123\narg221 = 424\nx22 = add(arg220, arg221)\nv22 = 547\nif x22 != v22\n    raise StandardError, \"Error at test case 23\"\nend\n\narg230 = 923\narg231 = 245\nx23 = add(arg230, arg231)\nv23 = 1168\nif x23 != v23\n    raise StandardError, \"Error at test case 24\"\nend\n\narg240 = 23\narg241 = 438\nx24 = add(arg240, arg241)\nv24 = 461\nif x24 != v24\n    raise StandardError, \"Error at test case 25\"\nend\n\narg250 = 565\narg251 = 133\nx25 = add(arg250, arg251)\nv25 = 698\nif x25 != v25\n    raise StandardError, \"Error at test case 26\"\nend\n\narg260 = 945\narg261 = 925\nx26 = add(arg260, arg261)\nv26 = 1870\nif x26 != v26\n    raise StandardError, \"Error at test case 27\"\nend\n\narg270 = 261\narg271 = 983\nx27 = add(arg270, arg271)\nv27 = 1244\nif x27 != v27\n    raise StandardError, \"Error at test case 28\"\nend\n\narg280 = 139\narg281 = 577\nx28 = add(arg280, arg281)\nv28 = 716\nif x28 != v28\n    raise StandardError, \"Error at test case 29\"\nend\n\narg290 = 763\narg291 = 178\nx29 = add(arg290, arg291)\nv29 = 941\nif x29 != v29\n    raise StandardError, \"Error at test case 30\"\nend\n\narg300 = 147\narg301 = 892\nx30 = add(arg300, arg301)\nv30 = 1039\nif x30 != v30\n    raise StandardError, \"Error at test case 31\"\nend\n\narg310 = 436\narg311 = 402\nx31 = add(arg310, arg311)\nv31 = 838\nif x31 != v31\n    raise StandardError, \"Error at test case 32\"\nend\n\narg320 = 610\narg321 = 581\nx32 = add(arg320, arg321)\nv32 = 1191\nif x32 != v32\n    raise StandardError, \"Error at test case 33\"\nend\n\narg330 = 103\narg331 = 416\nx33 = add(arg330, arg331)\nv33 = 519\nif x33 != v33\n    raise StandardError, \"Error at test case 34\"\nend\n\narg340 = 339\narg341 = 990\nx34 = add(arg340, arg341)\nv34 = 1329\nif x34 != v34\n    raise StandardError, \"Error at test case 35\"\nend\n\narg350 = 130\narg351 = 504\nx35 = add(arg350, arg351)\nv35 = 634\nif x35 != v35\n    raise StandardError, \"Error at test case 36\"\nend\n\narg360 = 242\narg361 = 717\nx36 = add(arg360, arg361)\nv36 = 959\nif x36 != v36\n    raise StandardError, \"Error at test case 37\"\nend\n\narg370 = 562\narg371 = 110\nx37 = add(arg370, arg371)\nv37 = 672\nif x37 != v37\n    raise StandardError, \"Error at test case 38\"\nend\n\narg380 = 396\narg381 = 909\nx38 = add(arg380, arg381)\nv38 = 1305\nif x38 != v38\n    raise StandardError, \"Error at test case 39\"\nend\n\narg390 = 887\narg391 = 703\nx39 = add(arg390, arg391)\nv39 = 1590\nif x39 != v39\n    raise StandardError, \"Error at test case 40\"\nend\n\narg400 = 870\narg401 = 551\nx40 = add(arg400, arg401)\nv40 = 1421\nif x40 != v40\n    raise StandardError, \"Error at test case 41\"\nend\n\narg410 = 422\narg411 = 391\nx41 = add(arg410, arg411)\nv41 = 813\nif x41 != v41\n    raise StandardError, \"Error at test case 42\"\nend\n\narg420 = 299\narg421 = 505\nx42 = add(arg420, arg421)\nv42 = 804\nif x42 != v42\n    raise StandardError, \"Error at test case 43\"\nend\n\narg430 = 346\narg431 = 56\nx43 = add(arg430, arg431)\nv43 = 402\nif x43 != v43\n    raise StandardError, \"Error at test case 44\"\nend\n\narg440 = 36\narg441 = 706\nx44 = add(arg440, arg441)\nv44 = 742\nif x44 != v44\n    raise StandardError, \"Error at test case 45\"\nend\n\narg450 = 738\narg451 = 411\nx45 = add(arg450, arg451)\nv45 = 1149\nif x45 != v45\n    raise StandardError, \"Error at test case 46\"\nend\n\narg460 = 679\narg461 = 87\nx46 = add(arg460, arg461)\nv46 = 766\nif x46 != v46\n    raise StandardError, \"Error at test case 47\"\nend\n\narg470 = 25\narg471 = 303\nx47 = add(arg470, arg471)\nv47 = 328\nif x47 != v47\n    raise StandardError, \"Error at test case 48\"\nend\n\narg480 = 161\narg481 = 612\nx48 = add(arg480, arg481)\nv48 = 773\nif x48 != v48\n    raise StandardError, \"Error at test case 49\"\nend\n\narg490 = 306\narg491 = 841\nx49 = add(arg490, arg491)\nv49 = 1147\nif x49 != v49\n    raise StandardError, \"Error at test case 50\"\nend\n\narg500 = 973\narg501 = 411\nx50 = add(arg500, arg501)\nv50 = 1384\nif x50 != v50\n    raise StandardError, \"Error at test case 51\"\nend\n\narg510 = 711\narg511 = 157\nx51 = add(arg510, arg511)\nv51 = 868\nif x51 != v51\n    raise StandardError, \"Error at test case 52\"\nend\n\narg520 = 471\narg521 = 27\nx52 = add(arg520, arg521)\nv52 = 498\nif x52 != v52\n    raise StandardError, \"Error at test case 53\"\nend\n\narg530 = 714\narg531 = 792\nx53 = add(arg530, arg531)\nv53 = 1506\nif x53 != v53\n    raise StandardError, \"Error at test case 54\"\nend\n\narg540 = 38\narg541 = 206\nx54 = add(arg540, arg541)\nv54 = 244\nif x54 != v54\n    raise StandardError, \"Error at test case 55\"\nend\n\narg550 = 907\narg551 = 343\nx55 = add(arg550, arg551)\nv55 = 1250\nif x55 != v55\n    raise StandardError, \"Error at test case 56\"\nend\n\narg560 = 23\narg561 = 760\nx56 = add(arg560, arg561)\nv56 = 783\nif x56 != v56\n    raise StandardError, \"Error at test case 57\"\nend\n\narg570 = 524\narg571 = 859\nx57 = add(arg570, arg571)\nv57 = 1383\nif x57 != v57\n    raise StandardError, \"Error at test case 58\"\nend\n\narg580 = 30\narg581 = 529\nx58 = add(arg580, arg581)\nv58 = 559\nif x58 != v58\n    raise StandardError, \"Error at test case 59\"\nend\n\narg590 = 341\narg591 = 691\nx59 = add(arg590, arg591)\nv59 = 1032\nif x59 != v59\n    raise StandardError, \"Error at test case 60\"\nend\n\narg600 = 167\narg601 = 729\nx60 = add(arg600, arg601)\nv60 = 896\nif x60 != v60\n    raise StandardError, \"Error at test case 61\"\nend\n\narg610 = 636\narg611 = 289\nx61 = add(arg610, arg611)\nv61 = 925\nif x61 != v61\n    raise StandardError, \"Error at test case 62\"\nend\n\narg620 = 503\narg621 = 144\nx62 = add(arg620, arg621)\nv62 = 647\nif x62 != v62\n    raise StandardError, \"Error at test case 63\"\nend\n\narg630 = 51\narg631 = 985\nx63 = add(arg630, arg631)\nv63 = 1036\nif x63 != v63\n    raise StandardError, \"Error at test case 64\"\nend\n\narg640 = 287\narg641 = 149\nx64 = add(arg640, arg641)\nv64 = 436\nif x64 != v64\n    raise StandardError, \"Error at test case 65\"\nend\n\narg650 = 659\narg651 = 75\nx65 = add(arg650, arg651)\nv65 = 734\nif x65 != v65\n    raise StandardError, \"Error at test case 66\"\nend\n\narg660 = 462\narg661 = 797\nx66 = add(arg660, arg661)\nv66 = 1259\nif x66 != v66\n    raise StandardError, \"Error at test case 67\"\nend\n\narg670 = 406\narg671 = 141\nx67 = add(arg670, arg671)\nv67 = 547\nif x67 != v67\n    raise StandardError, \"Error at test case 68\"\nend\n\narg680 = 106\narg681 = 44\nx68 = add(arg680, arg681)\nv68 = 150\nif x68 != v68\n    raise StandardError, \"Error at test case 69\"\nend\n\narg690 = 300\narg691 = 934\nx69 = add(arg690, arg691)\nv69 = 1234\nif x69 != v69\n    raise StandardError, \"Error at test case 70\"\nend\n\narg700 = 471\narg701 = 524\nx70 = add(arg700, arg701)\nv70 = 995\nif x70 != v70\n    raise StandardError, \"Error at test case 71\"\nend\n\narg710 = 122\narg711 = 429\nx71 = add(arg710, arg711)\nv71 = 551\nif x71 != v71\n    raise StandardError, \"Error at test case 72\"\nend\n\narg720 = 735\narg721 = 195\nx72 = add(arg720, arg721)\nv72 = 930\nif x72 != v72\n    raise StandardError, \"Error at test case 73\"\nend\n\narg730 = 335\narg731 = 484\nx73 = add(arg730, arg731)\nv73 = 819\nif x73 != v73\n    raise StandardError, \"Error at test case 74\"\nend\n\narg740 = 28\narg741 = 809\nx74 = add(arg740, arg741)\nv74 = 837\nif x74 != v74\n    raise StandardError, \"Error at test case 75\"\nend\n\narg750 = 430\narg751 = 20\nx75 = add(arg750, arg751)\nv75 = 450\nif x75 != v75\n    raise StandardError, \"Error at test case 76\"\nend\n\narg760 = 916\narg761 = 635\nx76 = add(arg760, arg761)\nv76 = 1551\nif x76 != v76\n    raise StandardError, \"Error at test case 77\"\nend\n\narg770 = 301\narg771 = 999\nx77 = add(arg770, arg771)\nv77 = 1300\nif x77 != v77\n    raise StandardError, \"Error at test case 78\"\nend\n\narg780 = 454\narg781 = 466\nx78 = add(arg780, arg781)\nv78 = 920\nif x78 != v78\n    raise StandardError, \"Error at test case 79\"\nend\n\narg790 = 905\narg791 = 259\nx79 = add(arg790, arg791)\nv79 = 1164\nif x79 != v79\n    raise StandardError, \"Error at test case 80\"\nend\n\narg800 = 168\narg801 = 205\nx80 = add(arg800, arg801)\nv80 = 373\nif x80 != v80\n    raise StandardError, \"Error at test case 81\"\nend\n\narg810 = 570\narg811 = 434\nx81 = add(arg810, arg811)\nv81 = 1004\nif x81 != v81\n    raise StandardError, \"Error at test case 82\"\nend\n\narg820 = 64\narg821 = 959\nx82 = add(arg820, arg821)\nv82 = 1023\nif x82 != v82\n    raise StandardError, \"Error at test case 83\"\nend\n\narg830 = 957\narg831 = 510\nx83 = add(arg830, arg831)\nv83 = 1467\nif x83 != v83\n    raise StandardError, \"Error at test case 84\"\nend\n\narg840 = 722\narg841 = 598\nx84 = add(arg840, arg841)\nv84 = 1320\nif x84 != v84\n    raise StandardError, \"Error at test case 85\"\nend\n\narg850 = 770\narg851 = 226\nx85 = add(arg850, arg851)\nv85 = 996\nif x85 != v85\n    raise StandardError, \"Error at test case 86\"\nend\n\narg860 = 579\narg861 = 66\nx86 = add(arg860, arg861)\nv86 = 645\nif x86 != v86\n    raise StandardError, \"Error at test case 87\"\nend\n\narg870 = 117\narg871 = 674\nx87 = add(arg870, arg871)\nv87 = 791\nif x87 != v87\n    raise StandardError, \"Error at test case 88\"\nend\n\narg880 = 530\narg881 = 30\nx88 = add(arg880, arg881)\nv88 = 560\nif x88 != v88\n    raise StandardError, \"Error at test case 89\"\nend\n\narg890 = 776\narg891 = 345\nx89 = add(arg890, arg891)\nv89 = 1121\nif x89 != v89\n    raise StandardError, \"Error at test case 90\"\nend\n\narg900 = 327\narg901 = 389\nx90 = add(arg900, arg901)\nv90 = 716\nif x90 != v90\n    raise StandardError, \"Error at test case 91\"\nend\n\narg910 = 596\narg911 = 12\nx91 = add(arg910, arg911)\nv91 = 608\nif x91 != v91\n    raise StandardError, \"Error at test case 92\"\nend\n\narg920 = 599\narg921 = 511\nx92 = add(arg920, arg921)\nv92 = 1110\nif x92 != v92\n    raise StandardError, \"Error at test case 93\"\nend\n\narg930 = 936\narg931 = 476\nx93 = add(arg930, arg931)\nv93 = 1412\nif x93 != v93\n    raise StandardError, \"Error at test case 94\"\nend\n\narg940 = 461\narg941 = 14\nx94 = add(arg940, arg941)\nv94 = 475\nif x94 != v94\n    raise StandardError, \"Error at test case 95\"\nend\n\narg950 = 966\narg951 = 157\nx95 = add(arg950, arg951)\nv95 = 1123\nif x95 != v95\n    raise StandardError, \"Error at test case 96\"\nend\n\narg960 = 326\narg961 = 91\nx96 = add(arg960, arg961)\nv96 = 417\nif x96 != v96\n    raise StandardError, \"Error at test case 97\"\nend\n\narg970 = 392\narg971 = 455\nx97 = add(arg970, arg971)\nv97 = 847\nif x97 != v97\n    raise StandardError, \"Error at test case 98\"\nend\n\narg980 = 446\narg981 = 477\nx98 = add(arg980, arg981)\nv98 = 923\nif x98 != v98\n    raise StandardError, \"Error at test case 99\"\nend\n\narg990 = 324\narg991 = 860\nx99 = add(arg990, arg991)\nv99 = 1184\nif x99 != v99\n    raise StandardError, \"Error at test case 100\"\nend\n\narg1000 = 945\narg1001 = 85\nx100 = add(arg1000, arg1001)\nv100 = 1030\nif x100 != v100\n    raise StandardError, \"Error at test case 101\"\nend\n\narg1010 = 886\narg1011 = 582\nx101 = add(arg1010, arg1011)\nv101 = 1468\nif x101 != v101\n    raise StandardError, \"Error at test case 102\"\nend\n\narg1020 = 886\narg1021 = 712\nx102 = add(arg1020, arg1021)\nv102 = 1598\nif x102 != v102\n    raise StandardError, \"Error at test case 103\"\nend\n\narg1030 = 842\narg1031 = 953\nx103 = add(arg1030, arg1031)\nv103 = 1795\nif x103 != v103\n    raise StandardError, \"Error at test case 104\"\nend\n\n", "description": "दो संख्याएँ x और y जोड़ें \n>>> जोड़ें (2,3) \n5. \n>>> जोड़ें (5,7) \n12.", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/20", "entry_point": "same_chars", "test": "\n\narg00 = \"eabcdzzzz\"\narg01 = \"dddzzzzzzzddeddabc\"\nx0 = same_chars(arg00, arg01)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"abcd\"\narg11 = \"dddddddabc\"\nx1 = same_chars(arg10, arg11)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"dddddddabc\"\narg21 = \"abcd\"\nx2 = same_chars(arg20, arg21)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"eabcd\"\narg31 = \"dddddddabc\"\nx3 = same_chars(arg30, arg31)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"abcd\"\narg41 = \"dddddddabcf\"\nx4 = same_chars(arg40, arg41)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"eabcdzzzz\"\narg51 = \"dddzzzzzzzddddabc\"\nx5 = same_chars(arg50, arg51)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"aabb\"\narg61 = \"aaccc\"\nx6 = same_chars(arg60, arg61)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "जाँच करें कि क्या दो शब्दों में समान अक्षर हैं। \n>>> समान अक्षर ('eabcdzzzz','dddzzzzzuddeddabc') \nसच है। \n>>> समान अक्षर ('एबीसीडी','डीडीडीडीडीएबीसी') \nसच है। \n>>> समान अक्षर ('ddddddabc','abcd') \nसच है। \n>>> समान अक्षर ('ई. ए. बी. सी. डी.','डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. \nझूठ बोलती है। \n>>> समान अक्षर ('ए. बी. सी. डी.','डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. \nझूठ बोलती है। \n>>> समान अक्षर ('eabcdzzzz','dddzzzzzddddddabc') \nझूठ बोलती है।", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/21", "entry_point": "fib", "test": "\n\narg00 = 10\nx0 = fib(arg00)\nv0 = 55\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 1\nx1 = fib(arg10)\nv1 = 1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 8\nx2 = fib(arg20)\nv2 = 21\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 11\nx3 = fib(arg30)\nv3 = 89\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 12\nx4 = fib(arg40)\nv4 = 144\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "n-th फिबोनाची संख्या वापस करें। \n>>> फाइबर (10) \n55. \n>>> फाइबर (1) \n1. \n>>> फाइबर (8) \n21.", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/22", "entry_point": "common", "test": "\n\narg00 = [1, 4, 3, 34, 653, 2, 5]\narg01 = [5, 7, 1, 5, 9, 653, 121]\nx0 = common(arg00, arg01)\nv0 = [1, 5, 653]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [5, 3, 2, 8]\narg11 = [3, 2]\nx1 = common(arg10, arg11)\nv1 = [2, 3]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [4, 3, 2, 8]\narg21 = [3, 2, 4]\nx2 = common(arg20, arg21)\nv2 = [2, 3, 4]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [4, 3, 2, 8]\narg31 = []\nx3 = common(arg30, arg31)\nv3 = []\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "दो सूचियों के लिए विशिष्ट सामान्य तत्वों को वापस क्रमबद्ध करें। \n>>> सामान्य ([1,4,3,34,653,2,5], [5,7,1,5,9,653,121]) \n[1,5,653] \n>>> सामान्य ([5,3,2,8], [3,2]) \n[2,3]", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/23", "entry_point": "largest_prime_factor", "test": "\n\narg00 = 15\nx0 = largest_prime_factor(arg00)\nv0 = 5\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 27\nx1 = largest_prime_factor(arg10)\nv1 = 3\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 63\nx2 = largest_prime_factor(arg20)\nv2 = 7\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 330\nx3 = largest_prime_factor(arg30)\nv3 = 11\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 13195\nx4 = largest_prime_factor(arg40)\nv4 = 29\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "n का सबसे बड़ा अभाज्य गुणनखंड वापस करें। मान लीजिए कि n> 1 अभाज्य नहीं है। \n>>> सबसे बड़ा _ प्राइम _ फैक्टर (13195) \n29. \n>>> सबसे बड़ा _ प्राइम _ फैक्टर (2048) \n2.", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/24", "entry_point": "sum_to_n", "test": "\n\narg00 = 1\nx0 = sum_to_n(arg00)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 6\nx1 = sum_to_n(arg10)\nv1 = 21\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 11\nx2 = sum_to_n(arg20)\nv2 = 66\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 30\nx3 = sum_to_n(arg30)\nv3 = 465\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 100\nx4 = sum_to_n(arg40)\nv4 = 5050\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "sum _ to _ n एक फलन है जो 1 से n तक की संख्याओं का योग करता है। \n>>> योग _ से _ एन (30) \n465 \n>>> योग _ से _ एन (100) \n5050 \n>>> योग _ से _ एन (5) \n15. \n>>> योग _ से _ एन (10) \n55. \n>>> योग _ से _ एन (1) \n1.", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/25", "entry_point": "derivative", "test": "\n\narg00 = [3, 1, 2, 4, 5]\nx0 = derivative(arg00)\nv0 = [1, 4, 12, 20]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 2, 3]\nx1 = derivative(arg10)\nv1 = [2, 6]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [3, 2, 1]\nx2 = derivative(arg20)\nv2 = [2, 2]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [3, 2, 1, 0, 4]\nx3 = derivative(arg30)\nv3 = [2, 2, 0, 16]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1]\nx4 = derivative(arg40)\nv4 = []\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "xs एक बहुपद के गुणांक का प्रतिनिधित्व करता है। \nxs [0] + xs [1] * x + xs [2] * x2 +.... \nइस बहुपद का उसी रूप में व्युत्पन्न वापस करें। \n>>> व्युत्पन्न ([3,1,2,4,5]) \n[1,4,12,20] \n>>> व्युत्पन्न ([1,2,3]) \n[2,6]", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/26", "entry_point": "fibfib", "test": "\n\narg00 = 2\nx0 = fibfib(arg00)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 1\nx1 = fibfib(arg10)\nv1 = 0\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 5\nx2 = fibfib(arg20)\nv2 = 4\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 8\nx3 = fibfib(arg30)\nv3 = 24\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 10\nx4 = fibfib(arg40)\nv4 = 81\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 12\nx5 = fibfib(arg50)\nv5 = 274\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 14\nx6 = fibfib(arg60)\nv6 = 927\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "फाइबफाइब संख्या अनुक्रम फाइबोनैचि सेकुनेस के समान एक अनुक्रम है जिसे निम्नानुसार परिभाषित किया गया हैः \nफाइबफिब (0) = = 0 \nफाइबफिब (1) = = 0 \nफाइबफिब (2) = = 1 \nफाइबफिब (एन) = = फाइबफिब (एन-1) + फाइबफिब (एन-2) + फाइबफिब (एन-3)। \nकृपया फाइबफिब संख्या अनुक्रम के n-th तत्व की कुशलता से गणना करने के लिए एक कार्य लिखें। \n>>> फाइबफिब (1) \n0 \n>>> फाइबफिब (5) \n4. \n>>> फाइबफिब (8) \n24.", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/27", "entry_point": "vowels_count", "test": "\n\narg00 = \"abcde\"\nx0 = vowels_count(arg00)\nv0 = 2\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Alone\"\nx1 = vowels_count(arg10)\nv1 = 3\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"key\"\nx2 = vowels_count(arg20)\nv2 = 2\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"bye\"\nx3 = vowels_count(arg30)\nv3 = 1\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"keY\"\nx4 = vowels_count(arg40)\nv4 = 2\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"bYe\"\nx5 = vowels_count(arg50)\nv5 = 1\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"ACEDY\"\nx6 = vowels_count(arg60)\nv6 = 3\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "एक फलन स्वर गणना लिखें जो एक स्ट्रिंग का प्रतिनिधित्व करता है \nइनपुट के रूप में एक शब्द और स्ट्रिंग में स्वरों की संख्या लौटाता है। \nइस मामले में स्वर'ए','ई','आई','ओ','यू'हैं। यहाँ,'वाई'भी एक है। \nस्वर, लेकिन केवल तभी जब यह दिए गए शब्द के अंत में हो। \n\nउदाहरणः \n>>> स्वरों की गिनती (\"एबीसीडीई\") \n2. \n>>> स्वर गणना (\"ACEDY\") \n3.", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/28", "entry_point": "search", "test": "\n\narg00 = [5, 5, 5, 5, 1]\nx0 = search(arg00)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [4, 1, 4, 1, 4, 4]\nx1 = search(arg10)\nv1 = 4\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [3, 3]\nx2 = search(arg20)\nv2 = -1\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [8, 8, 8, 8, 8, 8, 8, 8]\nx3 = search(arg30)\nv3 = 8\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [2, 3, 3, 2, 2]\nx4 = search(arg40)\nv4 = 2\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]\nx5 = search(arg50)\nv5 = 1\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [3, 2, 8, 2]\nx6 = search(arg60)\nv6 = 2\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]\nx7 = search(arg70)\nv7 = 1\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [8, 8, 3, 6, 5, 6, 4]\nx8 = search(arg80)\nv8 = -1\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = [6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]\nx9 = search(arg90)\nv9 = 1\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = [1, 9, 10, 1, 3]\nx10 = search(arg100)\nv10 = 1\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = [6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]\nx11 = search(arg110)\nv11 = 5\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = [1]\nx12 = search(arg120)\nv12 = 1\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\narg130 = [8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]\nx13 = search(arg130)\nv13 = 4\nif x13 != v13\n    raise StandardError, \"Error at test case 14\"\nend\n\narg140 = [2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]\nx14 = search(arg140)\nv14 = 2\nif x14 != v14\n    raise StandardError, \"Error at test case 15\"\nend\n\narg150 = [1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]\nx15 = search(arg150)\nv15 = 1\nif x15 != v15\n    raise StandardError, \"Error at test case 16\"\nend\n\narg160 = [9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]\nx16 = search(arg160)\nv16 = 4\nif x16 != v16\n    raise StandardError, \"Error at test case 17\"\nend\n\narg170 = [2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]\nx17 = search(arg170)\nv17 = 4\nif x17 != v17\n    raise StandardError, \"Error at test case 18\"\nend\n\narg180 = [9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]\nx18 = search(arg180)\nv18 = 2\nif x18 != v18\n    raise StandardError, \"Error at test case 19\"\nend\n\narg190 = [5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]\nx19 = search(arg190)\nv19 = -1\nif x19 != v19\n    raise StandardError, \"Error at test case 20\"\nend\n\narg200 = [10]\nx20 = search(arg200)\nv20 = -1\nif x20 != v20\n    raise StandardError, \"Error at test case 21\"\nend\n\narg210 = [9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]\nx21 = search(arg210)\nv21 = 2\nif x21 != v21\n    raise StandardError, \"Error at test case 22\"\nend\n\narg220 = [5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]\nx22 = search(arg220)\nv22 = 1\nif x22 != v22\n    raise StandardError, \"Error at test case 23\"\nend\n\narg230 = [7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]\nx23 = search(arg230)\nv23 = 1\nif x23 != v23\n    raise StandardError, \"Error at test case 24\"\nend\n\narg240 = [3, 10, 10, 9, 2]\nx24 = search(arg240)\nv24 = -1\nif x24 != v24\n    raise StandardError, \"Error at test case 25\"\nend\n\n", "description": "आपको सकारात्मक पूर्णांकों की एक गैर-खाली सूची दी जाती है। सबसे बड़ा पूर्णांक वापस करें जो उससे बड़ा है \nशून्य, और इसकी आवृत्ति पूर्णांक के मूल्य से अधिक या उसके बराबर होती है। \nएक पूर्णांक की आवृत्ति वह संख्या है जो वह सूची में कितनी बार दिखाई देती है। \nयदि ऐसा कोई मान मौजूद नहीं है, तो-1 वापस करें। \nउदाहरण के लिएः \nखोज ([4,1,2,2,3,1]) = = 2 \nखोज ([1,2,3,3,4,4]) = = 3 \nखोज ([5,5,4,4]) = =-1", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/29", "entry_point": "triangle_area", "test": "\n\narg00 = 3\narg01 = 4\narg02 = 5\nx0 = triangle_area(arg00, arg01, arg02)\nv0 = 6.0\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 1\narg11 = 2\narg12 = 10\nx1 = triangle_area(arg10, arg11, arg12)\nv1 = -1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 4\narg21 = 8\narg22 = 5\nx2 = triangle_area(arg20, arg21, arg22)\nv2 = 8.18\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 2\narg31 = 2\narg32 = 2\nx3 = triangle_area(arg30, arg31, arg32)\nv3 = 1.73\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 1\narg41 = 2\narg42 = 3\nx4 = triangle_area(arg40, arg41, arg42)\nv4 = -1\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 10\narg51 = 5\narg52 = 7\nx5 = triangle_area(arg50, arg51, arg52)\nv5 = 16.25\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 2\narg61 = 6\narg62 = 3\nx6 = triangle_area(arg60, arg61, arg62)\nv6 = -1\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 1\narg71 = 1\narg72 = 1\nx7 = triangle_area(arg70, arg71, arg72)\nv7 = 0.43\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 2\narg81 = 2\narg82 = 10\nx8 = triangle_area(arg80, arg81, arg82)\nv8 = -1\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "त्रिभुज की तीनों भुजाओं की लंबाई को देखते हुए। \nत्रिभुज को 2 दशमलव बिंदुओं पर गोल किया जाता है यदि तीनों भुजाएं एक वैध त्रिभुज बनाती हैं। \nअन्यथा वापसी-1 \nतीन भुजाएँ एक वैध त्रिभुज बनाती हैं जब किसी भी दो भुजाओं का योग अधिक होता है। \nतीसरे पक्ष की तुलना में। \nउदाहरणः \nत्रिभुज क्षेत्रफल (3,4,5) = = 6.00 \nत्रिभुज क्षेत्र (1,2,10) = =-1", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/30", "entry_point": "will_it_fly", "test": "\n\narg00 = [3, 2, 3]\narg01 = 9\nx0 = will_it_fly(arg00, arg01)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 2]\narg11 = 5\nx1 = will_it_fly(arg10, arg11)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [3]\narg21 = 5\nx2 = will_it_fly(arg20, arg21)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [3, 2, 3]\narg31 = 1\nx3 = will_it_fly(arg30, arg31)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 2, 3]\narg41 = 6\nx4 = will_it_fly(arg40, arg41)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [5]\narg51 = 5\nx5 = will_it_fly(arg50, arg51)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "एक फलन लिखें जो सही बताता है यदि वस्तु q उड़ान भरेगी, और अन्यथा गलत। \nवस्तु q उड़ जाएगी यदि यह संतुलित है (यह एक पैलिन्ड्रोमिक सूची है) और इसके तत्वों का योग अधिकतम संभव वजन डब्ल्यू से कम या उसके बराबर है। \n\nउदाहरणः \nविल इट फ्लाई ([1,2], 5) ′ फाल्स \n#1 + 2 अधिकतम संभव वजन से कम है, लेकिन यह असंतुलित है। \n\nविल इट फ्लाई ([3,2,3], 1) ′ फाल्स \n#यह संतुलित है, लेकिन 3 + 2 + 3 अधिकतम संभव वजन से अधिक है। \n\nविल इट फ्लाई ([3,2,3], 9) सही है \n#3 + 2 + 3 अधिकतम संभव वजन से कम है, और यह संतुलित है। \n\nविल इट फ्लाई ([3], 5) ट्रू \n#3 अधिकतम संभव वजन से कम है, और यह संतुलित है।", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/31", "entry_point": "is_multiply_prime", "test": "\n\narg00 = 5\nx0 = is_multiply_prime(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 30\nx1 = is_multiply_prime(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 8\nx2 = is_multiply_prime(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 10\nx3 = is_multiply_prime(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 125\nx4 = is_multiply_prime(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 105\nx5 = is_multiply_prime(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 126\nx6 = is_multiply_prime(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 729\nx7 = is_multiply_prime(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 891\nx8 = is_multiply_prime(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 1001\nx9 = is_multiply_prime(arg90)\nv9 = true\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\n", "description": "एक फलन लिखें जो सही लौटता है यदि दी गई संख्या 3 अभाज्य संख्याओं का गुणन है। \nऔर अन्यथा गलत। \nयह जानते हुए कि (ए) 100 से कम है। \nउदाहरणः \nक्या _ गुणा _ अभाज्य (30) = = सही है \n30 = 2 * 3 * 5", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/32", "entry_point": "decimal_to_binary", "test": "\n\narg00 = 0\nx0 = decimal_to_binary(arg00)\nv0 = \"db0db\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 32\nx1 = decimal_to_binary(arg10)\nv1 = \"db100000db\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 103\nx2 = decimal_to_binary(arg20)\nv2 = \"db1100111db\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 15\nx3 = decimal_to_binary(arg30)\nv3 = \"db1111db\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "आपको दशमलव के रूप में एक संख्या दी जाएगी और आपका काम इसे में बदलना है \nद्विआधारी प्रारूप। फलन को एक स्ट्रिंग वापस करनी चाहिए, जिसमें प्रत्येक वर्ण द्विआधारी का प्रतिनिधित्व करता है। \nसंख्या. स्ट्रिंग में प्रत्येक वर्ण'0'या'1'होगा। \n\nस्ट्रिंग के शुरू में और अंत में कुछ अतिरिक्त वर्ण'db'होंगे। \nप्रारूप में मदद करने के लिए अतिरिक्त वर्ण हैं। \n\nउदाहरण के लिएः \nदशमलव से द्विआधारी (15) #\"db1111db\" बताता है \nदशमलव _ से _ द्विआधारी (32) #बताता है \"db100000db\"", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/33", "entry_point": "is_happy", "test": "\n\narg00 = \"a\"\nx0 = is_happy(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"aa\"\nx1 = is_happy(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"abcd\"\nx2 = is_happy(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"aabb\"\nx3 = is_happy(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"adb\"\nx4 = is_happy(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"xyy\"\nx5 = is_happy(arg50)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"iopaxpoi\"\nx6 = is_happy(arg60)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"iopaxioi\"\nx7 = is_happy(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\n", "description": "आपको एक स्ट्रिंग s दी जाती है। \nआपका काम यह जांचना है कि स्ट्रिंग खुश है या नहीं। \nएक स्ट्रिंग तब खुश होती है जब इसकी लंबाई कम से कम 3 हो और हर 3 लगातार अक्षर अलग-अलग हों। \nउदाहरण के लिएः \nखुश है (a) => गलत है \nखुश है (एए) => गलत है \nखुश है (ए. बी. सी. डी.) => सही है \nखुश है (आब्ब) => गलत है \nखुश है (ए. डी. बी.) => सच है \nखुश है (xyy) => गलत है", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/34", "entry_point": "numerical_letter_grade", "test": "\n\narg00 = [4.0, 3, 1.7, 2, 3.5]\nx0 = numerical_letter_grade(arg00)\nv0 = [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1.2]\nx1 = numerical_letter_grade(arg10)\nv1 = [\"D+\"]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [0.5]\nx2 = numerical_letter_grade(arg20)\nv2 = [\"D-\"]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [0.0]\nx3 = numerical_letter_grade(arg30)\nv3 = [\"E\"]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 0.3, 1.5, 2.8, 3.3]\nx4 = numerical_letter_grade(arg40)\nv4 = [\"D\", \"D-\", \"C-\", \"B\", \"B+\"]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [0, 0.7]\nx5 = numerical_letter_grade(arg50)\nv5 = [\"E\", \"D-\"]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "यह सेमेस्टर का अंतिम सप्ताह होता है और शिक्षक को अंक देने होते हैं। \nछात्रों के लिए। शिक्षक ग्रेडिंग के लिए अपना खुद का एल्गोरिदम बना रहे हैं। \nएकमात्र समस्या यह है कि उसने ग्रेडिंग के लिए उपयोग किया गया कोड खो दिया है। \nउन्होंने आपको कुछ छात्रों के लिए जी. पी. ए. की सूची दी है और आपको लिखना होगा। \nएक प्रकार्य जो निम्नलिखित तालिका का उपयोग करके अक्षर श्रेणी की सूची तैयार कर सकता हैः \nजी. पी. ए। लेटर ग्रेड \n4. 0 ए + \n> 3.7 ए \n> 3.3 ए-\n> 3 बी + \n> 2.7 बी \n> 2.3 बी-\n> 2 सी + \n> 1.7 डिग्री सेल्सियस \n> 1.3 सी-\n> 1 डी + \n> 0.7 डी \n> 0.0 डी-\n0. 0 ई \n\nउदाहरणः \nश्रेणी समीकरण ([4.0,3,17,2,3.5]) = => ['ए +','बी','सी-','सी','ए -']", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/35", "entry_point": "prime_length", "test": "\n\narg00 = \"Hello\"\nx0 = prime_length(arg00)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"abcdcba\"\nx1 = prime_length(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"kittens\"\nx2 = prime_length(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"orange\"\nx3 = prime_length(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"wow\"\nx4 = prime_length(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"world\"\nx5 = prime_length(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"MadaM\"\nx6 = prime_length(arg60)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"Wow\"\nx7 = prime_length(arg70)\nv7 = true\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"\"\nx8 = prime_length(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = \"HI\"\nx9 = prime_length(arg90)\nv9 = true\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = \"go\"\nx10 = prime_length(arg100)\nv10 = true\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = \"gogo\"\nx11 = prime_length(arg110)\nv11 = false\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = \"aaaaaaaaaaaaaaa\"\nx12 = prime_length(arg120)\nv12 = false\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\narg130 = \"Madam\"\nx13 = prime_length(arg130)\nv13 = true\nif x13 != v13\n    raise StandardError, \"Error at test case 14\"\nend\n\narg140 = \"M\"\nx14 = prime_length(arg140)\nv14 = false\nif x14 != v14\n    raise StandardError, \"Error at test case 15\"\nend\n\narg150 = \"0\"\nx15 = prime_length(arg150)\nv15 = false\nif x15 != v15\n    raise StandardError, \"Error at test case 16\"\nend\n\n", "description": "एक फ़ंक्शन लिखें जो एक स्ट्रिंग लेता है और सही लौटाता है यदि स्ट्रिंग \nलंबाई एक अभाज्य संख्या है या अन्यथा गलत है \nउदाहरण \nप्राइम लेंथ ('हैलो') = = सही \nप्राइम _ लेंथ ('एबीसीडीसीबीए') = = सही \nअभाज्य लंबाई ('बिल्ली के बच्चे') = = सही \nअभाज्य लंबाई ('नारंगी') = = गलत", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/36", "entry_point": "solve", "test": "\n\narg00 = 1000\nx0 = solve(arg00)\nv0 = \"1\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 150\nx1 = solve(arg10)\nv1 = \"110\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 147\nx2 = solve(arg20)\nv2 = \"1100\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 333\nx3 = solve(arg30)\nv3 = \"1001\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 963\nx4 = solve(arg40)\nv4 = \"10010\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "एक सकारात्मक पूर्णांक N दिए जाने पर, इसके अंकों का कुल योग द्विआधारी में वापस करें। \n\nउदाहरण \nएन = 1000 के लिए, अंकों का योग 1 होगा और आउटपुट \"1\" होना चाहिए। \nएन = 150 के लिए, अंकों का योग 6 होगा और आउटपुट \"110\" होना चाहिए। \nएन = 147 के लिए, अंकों का योग 12 होगा और आउटपुट \"1100\" होना चाहिए। \n\nचरः \n@N पूर्णांक \nबाधाएँः 0 ≤ एन ≤ 10000। \nआउटपुटः \nद्विआधारी संख्या की एक स्ट्रिंग", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/37", "entry_point": "get_row", "test": "\n\narg00 = []\narg01 = 1\nx0 = get_row(arg00, arg01)\nv0 = []\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [[1]]\narg11 = 2\nx1 = get_row(arg10, arg11)\nv1 = []\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [[], [1], [1, 2, 3]]\narg21 = 3\nx2 = get_row(arg20, arg21)\nv2 = [[2, 2]]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\n", "description": "आपको एक 2 आयामी डेटा दिया जाता है, एक नेस्टेड सूची के रूप में, \nजो मैट्रिक्स के समान है, हालांकि, मैट्रिक्स के विपरीत, \nप्रत्येक पंक्ति में अलग-अलग संख्या में स्तंभ हो सकते हैं। \nपहले और पूर्णांक x को देखते हुए, सूची में पूर्णांक x खोजें, \nऔर टुपल्स की वापसी सूची, [(x1, y1), (x2, y2)...] जैसे कि \nप्रत्येक टुपल एक निर्देशांक है-(पंक्ति, कॉलम), जो 0 से शुरू होता है। \nनिर्देशांकों को प्रारंभ में पंक्तियों द्वारा आरोही क्रम में क्रमबद्ध करें। \nइसके अलावा, पंक्ति के निर्देशांक को स्तंभों द्वारा अवरोही क्रम में क्रमबद्ध करें। \n\nउदाहरण के लिएः \nपंक्ति प्राप्त करें (_ r) \n[1,2,3, 4,5,6], \n[1,2,3, 4,1,6], \n[1,2,3, 4,5,1] \n], 1) = = [(0,0), (1,4), (1,0), (2,5), (2,0)] \nपंक्ति प्राप्त करें ([], 1) = = [] \nगेट _ रो ([[], [1], [1,2,3]], 3) = = [(2,2)]", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/38", "entry_point": "next_smallest", "test": "\n\narg00 = [1, 2, 3, 4, 5]\nx0 = next_smallest(arg00)\nv0 = 2\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [5, 1, 4, 3, 2]\nx1 = next_smallest(arg10)\nv1 = 2\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = []\nx2 = next_smallest(arg20)\nv2 = nil\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1, 1]\nx3 = next_smallest(arg30)\nv3 = nil\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 1, 1, 1, 0]\nx4 = next_smallest(arg40)\nv4 = 1\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [1, 1]\nx5 = next_smallest(arg50)\nv5 = nil\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [-35, 34, 12, -45]\nx6 = next_smallest(arg60)\nv6 = -35\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "आपको पूर्णांकों की एक सूची दी जाती है। \nएक फलन अगला _ सबसे छोटा () लिखें जो सूची का दूसरा सबसे छोटा तत्व देता है। \nशून्य लौटें यदि ऐसा कोई तत्व नहीं है। \n\nअगला _ सबसे छोटा ([1,2,3,4,5]) = = 2 \nअगला _ सबसे छोटा ([5,1,4,3,2]) = = 2 \nअगला _ सबसे छोटा ([]) = = कोई नहीं \nअगला _ सबसे छोटा ([1,1]) = = कोई नहीं", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/39", "entry_point": "is_bored", "test": "\n\narg00 = \"Hello world\"\nx0 = is_bored(arg00)\nv0 = 0\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Is the sky blue?\"\nx1 = is_bored(arg10)\nv1 = 0\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"I love It !\"\nx2 = is_bored(arg20)\nv2 = 1\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"bIt\"\nx3 = is_bored(arg30)\nv3 = 0\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"I feel good today. I will be productive. will kill It\"\nx4 = is_bored(arg40)\nv4 = 2\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"You and I are going for a walk\"\nx5 = is_bored(arg50)\nv5 = 0\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "आपको शब्दों की एक श्रृंखला दी जाएगी, और आपका काम संख्या को गिनना है। \nऊब का। ऊब एक वाक्य है जो \"मैं\" शब्द से शुरू होता है। \nवाक्यों को '.', '?'या '!'द्वारा सीमांकित किया जाता है। \n\nउदाहरण के लिएः \n>>> बोर हो गया है (\"हैलो वर्ल्ड\") \n0 \n>>> ऊब गया है (\"आकाश नीला है। सूरज चमक रहा है। मुझे यह मौसम पसंद है\") \n1.", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/40", "entry_point": "skjkasdkd", "test": "\n\narg00 = [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]\nx0 = skjkasdkd(arg00)\nv0 = 10\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]\nx1 = skjkasdkd(arg10)\nv1 = 25\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]\nx2 = skjkasdkd(arg20)\nv2 = 13\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]\nx3 = skjkasdkd(arg30)\nv3 = 11\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [0, 81, 12, 3, 1, 21]\nx4 = skjkasdkd(arg40)\nv4 = 3\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [0, 8, 1, 2, 1, 7]\nx5 = skjkasdkd(arg50)\nv5 = 7\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [8191]\nx6 = skjkasdkd(arg60)\nv6 = 19\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [8191, 123456, 127, 7]\nx7 = skjkasdkd(arg70)\nv7 = 19\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [127, 97, 8192]\nx8 = skjkasdkd(arg80)\nv8 = 10\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "आपको पूर्णांकों की एक सूची दी जाती है। \nआपको सबसे बड़ा अभाज्य मूल्य खोजने और उसके अंकों का योग वापस करने की आवश्यकता है। \n\nउदाहरण के लिएः \nlst = [0,3,2, 1,3,5, 7,4,5, 5,5,2, 181,32,4, 32,3,2, 32,324,4, 3] के लिए आउटपुट 10 होना चाहिए। \nlst = [1,0,1, 8,2,4597, 2,1,3, 40,1,2, 1,2,4, 2,5,1] के लिए आउटपुट 25 होना चाहिए। \nlst = [1,3,1, 32,5107,34, 83278,109,163, 23,2323,32, 30,1,9, 3] के लिए आउटपुट 13 होना चाहिए। \nlst = [0,724,32, 71,99,32, 6,0,5, 91,83,0, 5,6] के लिए आउटपुट 11 होना चाहिए। \nlst = [0,81,12, 3,1,21] के लिए आउटपुट 3 होना चाहिए। \nlst = [0,8,1, 2,1,7] के लिए आउटपुट 7 होना चाहिए।", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/41", "entry_point": "check_dict_case", "test": "\n\narg00 = {\"p\"=>\"pineapple\", \"b\"=>\"banana\"}\nx0 = check_dict_case(arg00)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = {\"p\"=>\"pineapple\", \"A\"=>\"banana\", \"B\"=>\"banana\"}\nx1 = check_dict_case(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = {\"p\"=>\"pineapple\", 5=>\"banana\", \"a\"=>\"apple\"}\nx2 = check_dict_case(arg20)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = {\"Name\"=>\"John\", \"Age\"=>\"36\", \"City\"=>\"Houston\"}\nx3 = check_dict_case(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = {\"STATE\"=>\"NC\", \"ZIP\"=>\"12345\"}\nx4 = check_dict_case(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = {\"fruit\"=>\"Orange\", \"taste\"=>\"Sweet\"}\nx5 = check_dict_case(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = {}\nx6 = check_dict_case(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "शब्दकोश दिए जाने पर, सही वापस करें यदि सभी कुंजी निचले हिस्से में स्ट्रिंग हैं \nकेस या सभी कुंजी ऊपरी मामले में स्ट्रिंग हैं, अन्यथा गलत लौटें। \nफ़ंक्शन को वापस करना चाहिए गलत है दिया गया शब्दकोश खाली है। \nउदाहरण के लिएः \nचेक _ डिक्ट _ केस ({\"a\": \"सेब\", \"b\": \"केला\"}) को सही लौटना चाहिए। \nचेक _ डिक्ट _ केस ({\"a\": \"सेब\", \"A\": \"केला\", \"B\": \"केला\"}) को गलत लौटाना चाहिए। \nचेक _ डिक्ट _ केस ({\"a\": \"सेब\", 8: \"केला\", \"a\": \"सेब\"}) को गलत लौटाना चाहिए। \nचेक _ डिक्ट _ केस ({\"नाम\": \"जॉन\", \"आयु\": \"36\", \"सिटी\": \"ह्यूस्टन\"}) को गलत लौटाना चाहिए। \nचेक _ डिक्ट _ केस ({\"STATE\": \"NC\", \"ZIP\": \"12345\"}) को सही लौटना चाहिए।", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/42", "entry_point": "closest_integer", "test": "\n\narg00 = \"10\"\nx0 = closest_integer(arg00)\nv0 = 10\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"14.5\"\nx1 = closest_integer(arg10)\nv1 = 15\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"-15.5\"\nx2 = closest_integer(arg20)\nv2 = -16\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"15.3\"\nx3 = closest_integer(arg30)\nv3 = 15\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"0\"\nx4 = closest_integer(arg40)\nv4 = 0\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "एक फ़ंक्शन बनाएँ जो एक संख्या का प्रतिनिधित्व करने वाला मान (स्ट्रिंग) लेता है \nऔर निकटतम पूर्णांक देता है। यदि संख्या समान दूरी पर है। \nदो पूर्णांकों से, इसे शून्य से दूर गोल करें। \n\nउदाहरण \n>>> निकटतम पूर्णांक (\"10\") \n10. \n>>> निकटतम पूर्णांक (\"15.3\") \n15. \n\nध्यान देंः \nशून्य से दूर गोल करने का अर्थ है कि यदि दी गई संख्या समान दूरी पर है \nदो पूर्णांकों से, जिसे आपको वापस करना चाहिए वह वह है जो \nशून्य से सबसे दूर। उदाहरण के लिए निकटतम पूर्णांक (\"14.5\") चाहिए \n15 वापस करें और निकटतम पूर्णांक (\"-14.5\") को-15 वापस करना चाहिए।", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/43", "entry_point": "make_a_pile", "test": "\n\narg00 = 3\nx0 = make_a_pile(arg00)\nv0 = [3, 5, 7]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 4\nx1 = make_a_pile(arg10)\nv1 = [4, 6, 8, 10]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 5\nx2 = make_a_pile(arg20)\nv2 = [5, 7, 9, 11, 13]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 6\nx3 = make_a_pile(arg30)\nv3 = [6, 8, 10, 12, 14, 16]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 8\nx4 = make_a_pile(arg40)\nv4 = [8, 10, 12, 14, 16, 18, 20, 22]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "एक सकारात्मक पूर्णांक n को देखते हुए, आपको पत्थरों के n स्तरों का ढेर बनाना होगा। \nपहले स्तर में एन पत्थर हैं। \nअगले स्तर पर पत्थरों की संख्या हैः \n- अगली विषम संख्या यदि n विषम है। \n- अगली सम संख्या यदि n सम है। \nसूची में प्रत्येक स्तर पर पत्थरों की संख्या वापस करें, जहां सूचकांक पर तत्व है \ni स्तर (i + 1) में पत्थरों की संख्या का प्रतिनिधित्व करता है। \n\nउदाहरण के लिएः \n>>> _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[3,5,7]", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/44", "entry_point": "words_string", "test": "\n\narg00 = \"Hi, my name is John\"\nx0 = words_string(arg00)\nv0 = [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"One, two, three, four, five, six\"\nx1 = words_string(arg10)\nv1 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"Hi, my name\"\nx2 = words_string(arg20)\nv2 = [\"Hi\", \"my\", \"name\"]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"One,, two, three, four, five, six,\"\nx3 = words_string(arg30)\nv3 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"\"\nx4 = words_string(arg40)\nv4 = []\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"ahmed     , gamal\"\nx5 = words_string(arg50)\nv5 = [\"ahmed\", \"gamal\"]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "आपको अल्पविराम या रिक्त स्थान द्वारा अलग किए गए शब्दों की एक श्रृंखला दी जाएगी। आपका कार्य है \nस्ट्रिंग को शब्दों में विभाजित करने और शब्दों की एक सरणी वापस करने के लिए। \n\nउदाहरण के लिएः \nशब्द _ स्ट्रिंग (\"हाय, मेरा नाम जॉन है\") = = [\"हाय\", \"मेरा\", \"नाम\", \"है\", \"जॉन\"] \nशब्द _ स्ट्रिंग (\"एक, दो, तीन, चार, पांच, छह\") = = [\"एक\", \"दो\", \"तीन\", \"चार\", \"पांच\", \"छह\"]", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/45", "entry_point": "choose_num", "test": "\n\narg00 = 12\narg01 = 15\nx0 = choose_num(arg00, arg01)\nv0 = 14\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 13\narg11 = 12\nx1 = choose_num(arg10, arg11)\nv1 = -1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 33\narg21 = 12354\nx2 = choose_num(arg20, arg21)\nv2 = 12354\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 5234\narg31 = 5233\nx3 = choose_num(arg30, arg31)\nv3 = -1\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 6\narg41 = 29\nx4 = choose_num(arg40, arg41)\nv4 = 28\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 27\narg51 = 10\nx5 = choose_num(arg50, arg51)\nv5 = -1\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 7\narg61 = 7\nx6 = choose_num(arg60, arg61)\nv6 = -1\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 546\narg71 = 546\nx7 = choose_num(arg70, arg71)\nv7 = 546\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\n", "description": "यह फलन दो धनात्मक संख्याएँ x और y लेता है और वापस करता है \nसबसे बड़ी सम पूर्णांक संख्या जो [x, y] समावेशी सीमा में है। यदि \nऐसी कोई संख्या नहीं है, तो फ़ंक्शन-1 लौटना चाहिए। \n\nउदाहरण के लिएः \nचुनें (12,15) = 14 \nचुनें (13,12) =-1", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/46", "entry_point": "rounded_avg", "test": "\n\narg00 = 1\narg01 = 5\nx0 = rounded_avg(arg00, arg01)\nv0 = \"0b11\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 7\narg11 = 13\nx1 = rounded_avg(arg10, arg11)\nv1 = \"0b1010\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 964\narg21 = 977\nx2 = rounded_avg(arg20, arg21)\nv2 = \"0b1111001010\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 996\narg31 = 997\nx3 = rounded_avg(arg30, arg31)\nv3 = \"0b1111100100\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 560\narg41 = 851\nx4 = rounded_avg(arg40, arg41)\nv4 = \"0b1011000010\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 185\narg51 = 546\nx5 = rounded_avg(arg50, arg51)\nv5 = \"0b101101110\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 362\narg61 = 496\nx6 = rounded_avg(arg60, arg61)\nv6 = \"0b110101101\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 350\narg71 = 902\nx7 = rounded_avg(arg70, arg71)\nv7 = \"0b1001110010\"\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 197\narg81 = 233\nx8 = rounded_avg(arg80, arg81)\nv8 = \"0b11010111\"\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 7\narg91 = 5\nx9 = rounded_avg(arg90, arg91)\nv9 = -1\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = 5\narg101 = 1\nx10 = rounded_avg(arg100, arg101)\nv10 = -1\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = 5\narg111 = 5\nx11 = rounded_avg(arg110, arg111)\nv11 = \"0b101\"\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\n", "description": "आपको दो सकारात्मक पूर्णांक n और m दिए गए हैं, और आपका कार्य गणना करना है \nn से m तक के पूर्णांकों का औसत (n और m सहित)। \nनिकटतम पूर्णांक के उत्तर को गोल करें और उसे द्विआधारी में परिवर्तित करें। \nयदि n, m से बड़ा है, तो-1 वापस करें। \nउदाहरणः \nगोलाकार _ ए. वी. जी. (1,5) => \"0बी11\" \nगोलाकार _ ए. वी. जी. (7,5) =>-1 \nगोलाकार _ ए. वी. जी. (10,20) => \"0बी1111\" \nगोलाकार _ ए. वी. जी. (20,33) => \"0बी11010\"", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/47", "entry_point": "f", "test": "\n\narg00 = 5\nx0 = f(arg00)\nv0 = [1, 2, 6, 24, 15]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 7\nx1 = f(arg10)\nv1 = [1, 2, 6, 24, 15, 720, 28]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 1\nx2 = f(arg20)\nv2 = [1]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 3\nx3 = f(arg30)\nv3 = [1, 2, 6]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "फलन f को लागू करें जो n को एक पैरामीटर के रूप में लेता है, \nऔर आकार n की एक सूची लौटाता है, जैसे कि सूचकांक i पर तत्व का मान i का भाज्य है यदि i सम है \nया अन्यथा 1 से i तक की संख्याओं का योग। \nमैं 1 से शुरू करता हूँ। \ni का भाज्य 1 से i (1 * 2 *... * i) तक की संख्याओं का गुणन है। \nउदाहरणः \nf (5) = = [1,2,6,24,15]", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/48", "entry_point": "even_odd_palindrome", "test": "\n\narg00 = 123\nx0 = even_odd_palindrome(arg00)\nv0 = [8, 13]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 12\nx1 = even_odd_palindrome(arg10)\nv1 = [4, 6]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 3\nx2 = even_odd_palindrome(arg20)\nv2 = [1, 2]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 63\nx3 = even_odd_palindrome(arg30)\nv3 = [6, 8]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 25\nx4 = even_odd_palindrome(arg40)\nv4 = [5, 6]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 19\nx5 = even_odd_palindrome(arg50)\nv5 = [4, 6]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 9\nx6 = even_odd_palindrome(arg60)\nv6 = [4, 5]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 1\nx7 = even_odd_palindrome(arg70)\nv7 = [0, 1]\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\n", "description": "एक सकारात्मक पूर्णांक n दिए जाने पर, एक टुपल वापस करें जिसमें सम और विषम की संख्या हो। \nपूर्णांक पालिंड्रोम जो सीमा (1, एन) के भीतर आते हैं, समावेशी। \n\nउदाहरण 1: \n\nइनपुटः 3 \nआउटपुटः (1,2) \nव्याख्याः \nपूर्णांक पालिंड्रोम 1,2,3 हैं. उनमें से एक सम है, और उनमें से दो विषम हैं। \n\nउदाहरण 2: \n\nइनपुटः 12 \nआउटपुटः (4,6) \nव्याख्याः \nपूर्णांक पालिंड्रोम हैं 1,2,3,4,5,6,7,8,9,11. उनमें से चार सम हैं, और उनमें से 6 विषम हैं। \n\nध्यान देंः \n1. 1 <= n <= 10 ^ 3 \n2. लौटाए गए टुपल में क्रमशः सम और विषम पूर्णांक पालिंड्रोम्स की संख्या होती है।", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/49", "entry_point": "move_one_ball", "test": "\n\narg00 = [3, 4, 5, 1, 2]\nx0 = move_one_ball(arg00)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [3, 5, 10, 1, 2]\nx1 = move_one_ball(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [4, 3, 1, 2]\nx2 = move_one_ball(arg20)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [3, 5, 4, 1, 2]\nx3 = move_one_ball(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = []\nx4 = move_one_ball(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "हमारे पास एन पूर्णांक arr [1], arr [2],..., arr [N] की एक सरणी'arr'है। \nसरणी में संख्याओं को यादृच्छिक रूप से क्रमबद्ध किया जाएगा। आपका कार्य यह निर्धारित करना है कि क्या \nप्रदर्शन करके गैर-घटते क्रम में एक सरणी को क्रमबद्ध करना संभव है। \nदिए गए सरणी पर निम्नलिखित ऑपरेशनः \nआपको किसी भी समय सही शिफ्ट ऑपरेशन करने की अनुमति है। \n\nएक राइट शिफ्ट ऑपरेशन का अर्थ है सरणी के सभी तत्वों को एक से स्थानांतरित करना। \nसही दिशा में स्थिति। सरणी के अंतिम तत्व को स्थानांतरित किया जाएगा \nसरणी में प्रारंभिक स्थिति अर्थात 0 वां सूचकांक। \n\nयदि उपरोक्त ऑपरेशन करके क्रमबद्ध सरणी प्राप्त करना संभव है \nफिर सही लौटें अन्यथा गलत लौटें। \nयदि दी गई सरणी खाली है तो सही वापस करें। \n\nनोटः दी गई सूची में अद्वितीय तत्व होने की गारंटी है। \n\nउदाहरण के लिएः \n\nमूव _ वन _ बॉल ([3,4,5,1,2]) = => सही \nव्याख्याः 2 सही शिफ्ट संचालन में प्रदर्शन करके, गैर-घटता क्रम कर सकता है \nदिए गए सरणी के लिए प्राप्त किया जा सकता है। \nमूव _ वन _ बॉल ([3,5,4,1,2]) = => गलत \nव्याख्याः दिए गए के लिए गैर-घटता आदेश प्राप्त करना संभव नहीं है। \nकिसी भी संख्या में सही शिफ्ट संचालन करके सरणी।", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/50", "entry_point": "exchange", "test": "\n\narg00 = [1, 2, 3, 4]\narg01 = [1, 2, 3, 4]\nx0 = exchange(arg00, arg01)\nv0 = \"YES\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 2, 3, 4]\narg11 = [1, 5, 3, 4]\nx1 = exchange(arg10, arg11)\nv1 = \"NO\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 2, 3, 4]\narg21 = [2, 1, 4, 3]\nx2 = exchange(arg20, arg21)\nv2 = \"YES\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [5, 7, 3]\narg31 = [2, 6, 4]\nx3 = exchange(arg30, arg31)\nv3 = \"YES\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [5, 7, 3]\narg41 = [2, 6, 3]\nx4 = exchange(arg40, arg41)\nv4 = \"NO\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [3, 2, 6, 1, 8, 9]\narg51 = [3, 5, 5, 1, 1, 1]\nx5 = exchange(arg50, arg51)\nv5 = \"NO\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [100, 200]\narg61 = [200, 200]\nx6 = exchange(arg60, arg61)\nv6 = \"YES\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "इस समस्या में, आप एक फ़ंक्शन लागू करेंगे जो संख्याओं की दो सूचियाँ लेता है, \nऔर यह निर्धारित करता है कि क्या तत्वों का आदान-प्रदान करना संभव है \nउनके बीच lst1 को केवल सम संख्याओं की सूची बनाने के लिए। \nlst1 और lst2 के बीच आदान-प्रदान किए गए तत्वों की संख्या की कोई सीमा नहीं है। \nयदि बनाने के लिए lst1 और lst2 के बीच तत्वों का आदान-प्रदान करना संभव है \nlst1 के सभी तत्वों को सम होने के लिए, \"हाँ\" वापस करें। \nअन्यथा, \"नहीं\" वापस करें। \nउदाहरण के लिएः \nविनिमय ([1,2,3,4], [1,2,3,4]) => \"हाँ\" \nविनिमय ([1,2,3,4], [1,5,3,4]) => \"नहीं\" \nयह माना जाता है कि इनपुट सूचियाँ खाली नहीं होंगी।", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/51", "entry_point": "reverse_delete", "test": "\n\narg00 = \"abcde\"\narg01 = \"ae\"\nx0 = reverse_delete(arg00, arg01)\nv0 = [\"bcd\", false]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"abcdef\"\narg11 = \"b\"\nx1 = reverse_delete(arg10, arg11)\nv1 = [\"acdef\", false]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"abcdedcba\"\narg21 = \"ab\"\nx2 = reverse_delete(arg20, arg21)\nv2 = [\"cdedc\", true]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"dwik\"\narg31 = \"w\"\nx3 = reverse_delete(arg30, arg31)\nv3 = [\"dik\", false]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"a\"\narg41 = \"a\"\nx4 = reverse_delete(arg40, arg41)\nv4 = [\"\", true]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"abcdedcba\"\narg51 = \"\"\nx5 = reverse_delete(arg50, arg51)\nv5 = [\"abcdedcba\", true]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"abcdedcba\"\narg61 = \"v\"\nx6 = reverse_delete(arg60, arg61)\nv6 = [\"abcdedcba\", true]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"vabba\"\narg71 = \"v\"\nx7 = reverse_delete(arg70, arg71)\nv7 = [\"abba\", true]\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"mamma\"\narg81 = \"mia\"\nx8 = reverse_delete(arg80, arg81)\nv8 = [\"\", true]\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "कार्य \nहमें दो स्ट्रिंग s और c दिए गए हैं, आपको s में सभी वर्णों को हटाना होगा जो c में किसी भी वर्ण के बराबर हैं। \nफिर जाँच करें कि परिणाम स्ट्रिंग पालिंड्रोम है या नहीं। \nएक तार को पालिंड्रोम कहा जाता है यदि यह आगे के समान पीछे की ओर पढ़ता है। \nआपको चेक के लिए परिणाम स्ट्रिंग और सही/गलत वाला एक टुपल वापस करना चाहिए। \nउदाहरण \nएस = \"एबीसीडी\", सी = \"एई\" के लिए, परिणाम होना चाहिए ('बीसीडी', गलत) \nएस = \"एबीसीडीएफ\" के लिए, सी = \"बी\" परिणाम होना चाहिए ('एसीडीएफ', गलत) \ns = \"abcdedcba\", c = \"ab\" के लिए, परिणाम होना चाहिए ('cdedc', सही)", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/52", "entry_point": "max_fill", "test": "\n\narg00 = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]]\narg01 = 1\nx0 = max_fill(arg00, arg01)\nv0 = 6\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]]\narg11 = 2\nx1 = max_fill(arg10, arg11)\nv1 = 5\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [[0, 0, 0], [0, 0, 0]]\narg21 = 5\nx2 = max_fill(arg20, arg21)\nv2 = 0\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [[1, 1, 1, 1], [1, 1, 1, 1]]\narg31 = 2\nx3 = max_fill(arg30, arg31)\nv3 = 4\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [[1, 1, 1, 1], [1, 1, 1, 1]]\narg41 = 9\nx4 = max_fill(arg40, arg41)\nv4 = 2\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "आपको कुओं का एक आयताकार ग्रिड दिया जाता है। प्रत्येक पंक्ति एक कुएं का प्रतिनिधित्व करती है, \nऔर एक पंक्ति में प्रत्येक 1 पानी की एक इकाई का प्रतिनिधित्व करता है। \nप्रत्येक कुएँ में एक संबंधित बाल्टी होती है जिसका उपयोग उससे पानी निकालने के लिए किया जा सकता है। \nऔर सभी बाल्टियों में समान क्षमता होती है। \nआपका काम कुओं को खाली करने के लिए बाल्टियों का उपयोग करना है। \nजितनी बार आपको बाल्टियों को कम करने की आवश्यकता होगी, उसे आउटपुट करें। \n\nउदाहरण 1: \nइनपुटः \nग्रिडः [[0, 0,1,0], [0,1,0, 0], [1,1,1, 1]] \nबाल्टी क्षमताः 1 \nआउटपुटः 6 \n\nउदाहरण 2: \nइनपुटः \nग्रिडः [[0, 0,1,1], [0,0,0, 0], [1,1,1, 1], [0,1,1, 1]] \nबाल्टी क्षमताः 2 \nआउटपुटः 5 \n\nउदाहरण 3: \nइनपुटः \nग्रिडः [0,0,0], [0,0,0] \nबाल्टी क्षमताः 5 \nआउटपुटः 0 \n\nअड़चनेंः \n* सभी कुओं की लंबाई समान होती है। \n* 1 <= grid.length <= 10 ^ 2 \n* 1 <= ग्रिड [:, 1]. लंबाई <= 10 ^ 2 \nग्रिड [i] [j]-> 0। 1 \n* 1 <= क्षमता <= 10", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/53", "entry_point": "select_words", "test": "\n\narg00 = \"Mary had a little lamb\"\narg01 = 4\nx0 = select_words(arg00, arg01)\nv0 = [\"little\"]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Mary had a little lamb\"\narg11 = 3\nx1 = select_words(arg10, arg11)\nv1 = [\"Mary\", \"lamb\"]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"simple white space\"\narg21 = 2\nx2 = select_words(arg20, arg21)\nv2 = []\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"Hello world\"\narg31 = 4\nx3 = select_words(arg30, arg31)\nv3 = [\"world\"]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"Uncle sam\"\narg41 = 3\nx4 = select_words(arg40, arg41)\nv4 = [\"Uncle\"]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"\"\narg51 = 4\nx5 = select_words(arg50, arg51)\nv5 = []\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"a b c d e f\"\narg61 = 1\nx6 = select_words(arg60, arg61)\nv6 = [\"b\", \"c\", \"d\", \"f\"]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "एक स्ट्रिंग s और एक प्राकृतिक संख्या n को देखते हुए, आपको इसे लागू करने का काम सौंपा गया है। \nएक प्रकार्य जो स्ट्रिंग एस से सभी शब्दों की एक सूची देता है जिसमें ठीक-ठीक शब्द होते हैं \nएन व्यंजन, क्रम में ये शब्द स्ट्रिंग एस में दिखाई देते हैं। \nयदि स्ट्रिंग s खाली है तो फ़ंक्शन को एक खाली सूची वापस करनी चाहिए। \nनोटः आप मान सकते हैं कि इनपुट स्ट्रिंग में केवल अक्षर और रिक्त स्थान हैं। \nउदाहरण के लिएः \nशब्द चुनें (\"मैरी के पास एक छोटा भेड़ का बच्चा था\", 4) = => [\"छोटा\"] \nशब्द चुनें (\"मैरी का एक छोटा भेड़ का बच्चा था\", 3) = => [\"मैरी\", \"भेड़ का बच्चा\"] \nशब्द चुनें (\"साधारण सफेद स्थान\", 2) = => [] \nशब्द चुनें (\"हैलो वर्ल्ड\", 4) = => [\"वर्ल्ड\"] \nशब्द चुनें (\"अंकल सैम\", 3) = => [\"अंकल\"]", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/54", "entry_point": "maximum", "test": "\n\narg00 = [-3, -4, 5]\narg01 = 3\nx0 = maximum(arg00, arg01)\nv0 = [-4, -3, 5]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [4, -4, 4]\narg11 = 2\nx1 = maximum(arg10, arg11)\nv1 = [4, 4]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [-3, 2, 1, 2, -1, -2, 1]\narg21 = 1\nx2 = maximum(arg20, arg21)\nv2 = [2]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [123, -123, 20, 0, 1, 2, -3]\narg31 = 3\nx3 = maximum(arg30, arg31)\nv3 = [2, 20, 123]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [-123, 20, 0, 1, 2, -3]\narg41 = 4\nx4 = maximum(arg40, arg41)\nv4 = [0, 1, 2, 20]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [5, 15, 0, 3, -13, -8, 0]\narg51 = 7\nx5 = maximum(arg50, arg51)\nv5 = [-13, -8, 0, 0, 3, 5, 15]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [-1, 0, 2, 5, 3, -10]\narg61 = 2\nx6 = maximum(arg60, arg61)\nv6 = [3, 5]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [1, 0, 5, -7]\narg71 = 1\nx7 = maximum(arg70, arg71)\nv7 = [5]\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [4, -4]\narg81 = 2\nx8 = maximum(arg80, arg81)\nv8 = [-4, 4]\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = [-10, 10]\narg91 = 2\nx9 = maximum(arg90, arg91)\nv9 = [-10, 10]\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = [1, 2, 3, -23, 243, -400, 0]\narg101 = 0\nx10 = maximum(arg100, arg101)\nv10 = []\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\n", "description": "पूर्णांकों की एक सरणी arr और एक सकारात्मक पूर्णांक k दिए जाने पर, एक क्रमबद्ध सूची वापस करें \nए. आर. आर. में अधिकतम के संख्याओं के साथ लंबाई के. \n\nउदाहरण 1: \n\nइनपुटः arr = [-3,-4,5], k = 3 \nआउटपुटः [-4,-3,5] \n\nउदाहरण 2: \n\nइनपुटः arr = [4,-4,4], k = 2 \nआउटपुटः [4,4] \n\nउदाहरण 3: \n\nइनपुटः arr = [-3,2,1,2,-1,2,1], k = 1 \nआउटपुटः [2] \n\nध्यान देंः \n1. सरणी की लंबाई [1000] की सीमा में होगी। \n2. सरणी में तत्व [-1000] की सीमा में होंगे। \n3. 0 <= k <= लेन (arr)", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/55", "entry_point": "add_elements", "test": "\n\narg00 = [1, -2, -3, 41, 57, 76, 87, 88, 99]\narg01 = 3\nx0 = add_elements(arg00, arg01)\nv0 = -4\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [111, 121, 3, 4000, 5, 6]\narg11 = 2\nx1 = add_elements(arg10, arg11)\nv1 = 0\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [11, 21, 3, 90, 5, 6, 7, 8, 9]\narg21 = 4\nx2 = add_elements(arg20, arg21)\nv2 = 125\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [111, 21, 3, 4000, 5, 6, 7, 8, 9]\narg31 = 4\nx3 = add_elements(arg30, arg31)\nv3 = 24\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1]\narg41 = 1\nx4 = add_elements(arg40, arg41)\nv4 = 1\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "पूर्णांक एआरआर और एक पूर्णांक के की एक गैर-खाली सरणी को देखते हुए, वापस करें \narr के पहले k तत्वों से अधिकतम दो अंकों वाले तत्वों का योग। \n\nउदाहरणः \n\nइनपुटः arr = [111,21,3, 4000,5,6, 7,8,9], k = 4 \nआउटपुटः 24 #21 + 3 का योग \n\nअड़चनेंः \n1. 1 <= लेन (arr) <= 100 \n2. 1 <= k <= लेन (arr)", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/56", "entry_point": "intersection", "test": "\n\narg00 = [1, 2]\narg01 = [2, 3]\nx0 = intersection(arg00, arg01)\nv0 = \"NO\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [-1, 1]\narg11 = [0, 4]\nx1 = intersection(arg10, arg11)\nv1 = \"NO\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [-3, -1]\narg21 = [-5, 5]\nx2 = intersection(arg20, arg21)\nv2 = \"YES\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [-2, 2]\narg31 = [-4, 0]\nx3 = intersection(arg30, arg31)\nv3 = \"YES\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [-11, 2]\narg41 = [-1, -1]\nx4 = intersection(arg40, arg41)\nv4 = \"NO\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [1, 2]\narg51 = [3, 5]\nx5 = intersection(arg50, arg51)\nv5 = \"NO\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [1, 2]\narg61 = [1, 2]\nx6 = intersection(arg60, arg61)\nv6 = \"NO\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [-2, -2]\narg71 = [-3, -2]\nx7 = intersection(arg70, arg71)\nv7 = \"NO\"\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\n", "description": "आपको दो अंतराल दिए जाते हैं, \nजहाँ प्रत्येक अंतराल पूर्णांकों का एक जोड़ा है। उदाहरण के लिए, अंतराल = (प्रारंभ, अंत) = (1,2)। \nदिए गए अंतराल बंद होते हैं जिसका अर्थ है कि अंतराल (प्रारंभ, अंत) \nइसमें शुरुआत और अंत दोनों शामिल हैं। \nप्रत्येक दिए गए अंतराल के लिए, यह माना जाता है कि इसकी शुरुआत कम या इसके अंत के बराबर है। \nआपका काम यह निर्धारित करना है कि इन दोनों के प्रतिच्छेदन की लंबाई कितनी है। \nअंतराल एक अभाज्य संख्या है। \nउदाहरण के लिए, अंतराल (1,3), (2,4) का प्रतिच्छेदन (2,3) है। \nजिसकी लंबाई 1 है, जो एक अभाज्य संख्या नहीं है। \nयदि प्रतिच्छेदन की लंबाई एक अभाज्य संख्या है, तो \"हाँ\" वापस करें, \nअन्यथा, \"नहीं\" वापस करें। \nयदि दोनों अंतराल एक दूसरे को नहीं काटते हैं, तो \"नहीं\" वापस करें। \n\n[इनपुट/आउटपुट] नमूनेः \nप्रतिच्छेदन ((1,2,3)) = => \"नहीं\" \nप्रतिच्छेदन ((-1,1), (0,4)) = => \"नहीं\" \nप्रतिच्छेदन ((-3,-1), (-5,5)) = => \"हाँ\"", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/57", "entry_point": "tri", "test": "\n\narg00 = 3\nx0 = tri(arg00)\nv0 = [1, 3, 2.0, 8.0]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 4\nx1 = tri(arg10)\nv1 = [1, 3, 2.0, 8.0, 3.0]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 5\nx2 = tri(arg20)\nv2 = [1, 3, 2.0, 8.0, 3.0, 15.0]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 6\nx3 = tri(arg30)\nv3 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 7\nx4 = tri(arg40)\nv4 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 8\nx5 = tri(arg50)\nv5 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 9\nx6 = tri(arg60)\nv6 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 20\nx7 = tri(arg70)\nv7 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 0\nx8 = tri(arg80)\nv8 = [1]\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 1\nx9 = tri(arg90)\nv9 = [1, 3]\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\n", "description": "हर कोई फिबोनाची अनुक्रम को जानता है, इसका गणितविदों द्वारा गहराई से अध्ययन किया गया था \nपिछली कुछ शताब्दियाँ। हालाँकि, लोग जो नहीं जानते हैं वह है ट्रिबोनाची अनुक्रम। \nट्राइबोनाची अनुक्रम को पुनरावृत्ति द्वारा परिभाषित किया जाता हैः \nत्रि (1) = 3 \nत्रि (एन) = 1 + एन/2, यदि एन सम है। \nयदि n विषम है तो त्रि (n) = त्रि (n-1) + त्रि (n-2) + त्रि (n + 1)। \nउदाहरण के लिएः \nत्रि (2) = 1 + (2/2) = 2 \nत्रि (4) = 3 \nत्रि (3) = त्रि (2) + त्रि (1) + त्रि (4) \n= 2 + 3 + 3 = 8 \nआपको एक गैर-नकारात्मक पूर्णांक संख्या n दी गई है, आपको एक सूची वापस करनी होगी \nट्रिबोनाची अनुक्रम की पहली n + 1 संख्याएँ। \nउदाहरण के लिएः \nत्रि (3) = [1,3,2,8]", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/58", "entry_point": "digits", "test": "\n\narg00 = 5\nx0 = digits(arg00)\nv0 = 5\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 54\nx1 = digits(arg10)\nv1 = 5\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 120\nx2 = digits(arg20)\nv2 = 1\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 5014\nx3 = digits(arg30)\nv3 = 5\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 98765\nx4 = digits(arg40)\nv4 = 315\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 5576543\nx5 = digits(arg50)\nv5 = 2625\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 2468\nx6 = digits(arg60)\nv6 = 0\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "एक सकारात्मक पूर्णांक n दिए जाने पर, विषम अंकों के गुणनफल को वापस करें। \nयदि सभी अंक सम हैं तो 0 वापस करें। \nउदाहरण के लिएः \nअंक (1) = = 1 \nअंक (4) = = 0 \nअंक (235) = = 15", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/59", "entry_point": "is_nested", "test": "\n\narg00 = \"[[]]\"\nx0 = is_nested(arg00)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"[]]]]]]][[[[[]\"\nx1 = is_nested(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"[][]\"\nx2 = is_nested(arg20)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"[]\"\nx3 = is_nested(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"[[[[]]]]\"\nx4 = is_nested(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"[]]]]]]]]]]\"\nx5 = is_nested(arg50)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"[][][[]]\"\nx6 = is_nested(arg60)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"[[]\"\nx7 = is_nested(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"[]]\"\nx8 = is_nested(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = \"[[]][[\"\nx9 = is_nested(arg90)\nv9 = true\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = \"[[][]]\"\nx10 = is_nested(arg100)\nv10 = true\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = \"\"\nx11 = is_nested(arg110)\nv11 = false\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = \"[[[[[[[[\"\nx12 = is_nested(arg120)\nv12 = false\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\narg130 = \"]]]]]]]]\"\nx13 = is_nested(arg130)\nv13 = false\nif x13 != v13\n    raise StandardError, \"Error at test case 14\"\nend\n\n", "description": "एक ऐसा फ़ंक्शन बनाएँ जो एक स्ट्रिंग को इनपुट के रूप में लेता है जिसमें केवल वर्ग कोष्ठक होते हैं। \nफ़ंक्शन को सही लौटना चाहिए यदि और केवल तभी जब कोष्ठक का एक वैध अनुक्रम हो \nजेराव उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन। \n\nनेस्टेड ('[[]]') सही है \nis _ nested ('[]]]]] [[[[]') गलत है \nनेस्टेड ('[] []') गलत है \nनेस्टेड ('[]') गलत है \nनेस्टेड ('[[] []]') सही है \nनेस्टेड है ('[[]] [[') सही है", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/60", "entry_point": "sum_squares", "test": "\n\narg00 = [1, 2, 3]\nx0 = sum_squares(arg00)\nv0 = 14\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1.0, 2, 3]\nx1 = sum_squares(arg10)\nv1 = 14\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 3, 5, 7]\nx2 = sum_squares(arg20)\nv2 = 84\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1.4, 4.2, 0]\nx3 = sum_squares(arg30)\nv3 = 29\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [-2.4, 1, 1]\nx4 = sum_squares(arg40)\nv4 = 6\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [100, 1, 15, 2]\nx5 = sum_squares(arg50)\nv5 = 10230\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [10000, 10000]\nx6 = sum_squares(arg60)\nv6 = 200000000\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [-1.4, 4.6, 6.3]\nx7 = sum_squares(arg70)\nv7 = 75\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [-1.4, 17.9, 18.9, 19.9]\nx8 = sum_squares(arg80)\nv8 = 1086\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = [0]\nx9 = sum_squares(arg90)\nv9 = 0\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = [-1]\nx10 = sum_squares(arg100)\nv10 = 1\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = [-1, 1, 0]\nx11 = sum_squares(arg110)\nv11 = 2\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\n", "description": "आपको संख्याओं की एक सूची दी जाती है। \nआपको दी गई सूची में वर्ग संख्या का योग वापस करना होगा, \nसूची में प्रत्येक तत्व को पहले ऊपरी इंट (सीलिंग) में गोल करें। \nउदाहरण के लिएः \nlst = [1,2,3] के लिए आउटपुट 14 होना चाहिए। \nlst = [1,4,9] के लिए आउटपुट 98 होना चाहिए। \nlst = [1,3,5, 7] के लिए आउटपुट 84 होना चाहिए। \nlst = [1.4,4.2, 0] के लिए आउटपुट 29 होना चाहिए। \nlst = [-2.4,1, 1] के लिए आउटपुट 6 होना चाहिए।", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/61", "entry_point": "check_if_last_char_is_a_letter", "test": "\n\narg00 = \"apple\"\nx0 = check_if_last_char_is_a_letter(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"apple pi e\"\nx1 = check_if_last_char_is_a_letter(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"eeeee\"\nx2 = check_if_last_char_is_a_letter(arg20)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"A\"\nx3 = check_if_last_char_is_a_letter(arg30)\nv3 = true\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"Pumpkin pie \"\nx4 = check_if_last_char_is_a_letter(arg40)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"Pumpkin pie 1\"\nx5 = check_if_last_char_is_a_letter(arg50)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"\"\nx6 = check_if_last_char_is_a_letter(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"eeeee e \"\nx7 = check_if_last_char_is_a_letter(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"apple pie\"\nx8 = check_if_last_char_is_a_letter(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = \"apple pi e \"\nx9 = check_if_last_char_is_a_letter(arg90)\nv9 = false\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\n", "description": "एक प्रकार्य बनाएँ जो सही लौटाता है यदि अंतिम वर्ण \nकिसी दिए गए स्ट्रिंग का वर्णमाला वर्ण है और यह नहीं है \nएक शब्द का एक हिस्सा, और अन्यथा गलत। \nनोटः \"शब्द\" अक्षरों का एक समूह है जो स्थान द्वारा अलग किया जाता है। \n\nउदाहरण के लिएः \nजाँचें _ अगर _ अंतिम _ चर _ है _ ए _ अक्षर (\"सेब पाई\") ′ गलत \nजाँच करें कि अगर _ अंतिम _ चर _ है _ a _ अक्षर (\"एप्पल पाई ई\") सही है \nजाँचें _ अगर _ अंतिम _ चर _ है _ ए _ अक्षर (\"सेब पाई ई\") गलत है \nजाँचें _ अगर _ अंतिम _ चर _ है _ ए _ अक्षर (\"\") ′ गलत", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/62", "entry_point": "can_arrange", "test": "\n\narg00 = [1, 2, 4, 3, 5]\nx0 = can_arrange(arg00)\nv0 = 3\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 2, 4, 5]\nx1 = can_arrange(arg10)\nv1 = -1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 4, 2, 5, 6, 7, 8, 9, 10]\nx2 = can_arrange(arg20)\nv2 = 2\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [4, 8, 5, 7, 3]\nx3 = can_arrange(arg30)\nv3 = 4\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = []\nx4 = can_arrange(arg40)\nv4 = -1\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "एक ऐसा फलन बनाएँ जो किसी तत्व का सबसे बड़ा सूचकांक देता है जो \nयह उससे तुरंत पहले के तत्व से बड़ा या बराबर नहीं है। यदि \nऐसा कोई तत्व मौजूद नहीं है तो वापसी-1। दिए गए सरणी में शामिल नहीं होगा \nडुप्लिकेट मान। \n\nउदाहरण के लिएः \nकैन अरेंज ([1,2,4, 3,5]) = 3 \nकैन अरेंज ([1,2,3]) =-1", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/63", "entry_point": "largest_smallest_integers", "test": "\n\narg00 = [2, 4, 1, 3, 5, 7]\nx0 = largest_smallest_integers(arg00)\nv0 = [nil, 1]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [2, 4, 1, 3, 5, 7, 0]\nx1 = largest_smallest_integers(arg10)\nv1 = [nil, 1]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 3, 2, 4, 5, 6, -2]\nx2 = largest_smallest_integers(arg20)\nv2 = [-2, 1]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [4, 5, 3, 6, 2, 7, -7]\nx3 = largest_smallest_integers(arg30)\nv3 = [-7, 2]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [7, 3, 8, 4, 9, 2, 5, -9]\nx4 = largest_smallest_integers(arg40)\nv4 = [-9, 2]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = []\nx5 = largest_smallest_integers(arg50)\nv5 = [nil, nil]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [0]\nx6 = largest_smallest_integers(arg60)\nv6 = [nil, nil]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [-1, -3, -5, -6]\nx7 = largest_smallest_integers(arg70)\nv7 = [-1, nil]\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [-1, -3, -5, -6, 0]\nx8 = largest_smallest_integers(arg80)\nv8 = [-1, nil]\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = [-6, -4, -4, -3, 1]\nx9 = largest_smallest_integers(arg90)\nv9 = [-3, 1]\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = [-6, -4, -4, -3, -100, 1]\nx10 = largest_smallest_integers(arg100)\nv10 = [-3, 1]\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\n", "description": "एक फलन बनाएँ जो एक टुपल (ए, बी) देता है, जहाँ'ए'है \nऋणात्मक पूर्णांकों में सबसे बड़ा, और'बी'सबसे छोटा है \nएक सूची में सकारात्मक पूर्णांक। \nयदि कोई ऋणात्मक या धनात्मक पूर्णांक नहीं हैं, तो उन्हें शून्य के रूप में वापस करें। \n\nउदाहरण के लिएः \nसबसे बड़ा _ सबसे छोटा _ पूर्णांक ([2,4,1,3,5,7]) = = (कोई नहीं, 1) \nसबसे बड़ा _ सबसे छोटा _ पूर्णांक ([]) = = (कोई नहीं, कोई नहीं) \nसबसे बड़ा _ सबसे छोटा _ पूर्णांक ([0]) = = (कोई नहीं, कोई नहीं)", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/64", "entry_point": "special_factorial", "test": "\n\narg00 = 4\nx0 = special_factorial(arg00)\nv0 = 288\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 5\nx1 = special_factorial(arg10)\nv1 = 34560\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 7\nx2 = special_factorial(arg20)\nv2 = 125411328000\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 1\nx3 = special_factorial(arg30)\nv3 = 1\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "ब्राजीलियाई भाज्य को इस प्रकार परिभाषित किया गया हैः \nब्राज़ीलियाई _ फैक्टोरियल (एन) = एन! * (एन-1)! * (एन-2)! *... * 1! \nजहाँ n> 0 \n\nउदाहरण के लिएः \n>>> स्पेशल _ फैक्टोरियल (4) \n288 \n\nफ़ंक्शन को इनपुट के रूप में एक पूर्णांक प्राप्त होगा और विशेष वापस करना चाहिए \nइस पूर्णांक का भाज्य।", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/65", "entry_point": "words_in_sentence", "test": "\n\narg00 = \"This is a test\"\nx0 = words_in_sentence(arg00)\nv0 = \"is\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"lets go for swimming\"\nx1 = words_in_sentence(arg10)\nv1 = \"go for\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"there is no place available here\"\nx2 = words_in_sentence(arg20)\nv2 = \"there is no place\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"Hi I am Hussein\"\nx3 = words_in_sentence(arg30)\nv3 = \"Hi am Hussein\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"go for it\"\nx4 = words_in_sentence(arg40)\nv4 = \"go for it\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"here\"\nx5 = words_in_sentence(arg50)\nv5 = \"\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"here is\"\nx6 = words_in_sentence(arg60)\nv6 = \"is\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "आपको एक वाक्य का प्रतिनिधित्व करने वाली एक स्ट्रिंग दी जाती है, \nवाक्य में कुछ शब्द हैं जो एक स्थान द्वारा अलग किए गए हैं, \nऔर आपको एक स्ट्रिंग वापस करनी होगी जिसमें मूल वाक्य के शब्द शामिल हैं, \nजिनकी लंबाई अभाज्य संख्याएँ हैं, \nनई स्ट्रिंग में शब्दों का क्रम मूल के समान होना चाहिए। \n\nउदाहरण 1: \nइनपुटः वाक्य = \"यह एक परीक्षण है\" \nआउटपुटः \"है\" \n\nउदाहरण 2: \nइनपुटः वाक्य = \"चलो तैरने के लिए चलते हैं\" \nआउटपुटः \"के लिए जाएँ\" \n\nअड़चनेंः \n* 1 <= लेन (वाक्य) <= 100 \n* वाक्य में केवल अक्षर होते हैं", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/66", "entry_point": "simplify", "test": "\n\narg00 = \"1/5\"\narg01 = \"5/1\"\nx0 = simplify(arg00, arg01)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"1/6\"\narg11 = \"2/1\"\nx1 = simplify(arg10, arg11)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"5/1\"\narg21 = \"3/1\"\nx2 = simplify(arg20, arg21)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"7/10\"\narg31 = \"10/2\"\nx3 = simplify(arg30, arg31)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"2/10\"\narg41 = \"50/10\"\nx4 = simplify(arg40, arg41)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"7/2\"\narg51 = \"4/2\"\nx5 = simplify(arg50, arg51)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"11/6\"\narg61 = \"6/1\"\nx6 = simplify(arg60, arg61)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"2/3\"\narg71 = \"5/2\"\nx7 = simplify(arg70, arg71)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"5/2\"\narg81 = \"3/5\"\nx8 = simplify(arg80, arg81)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = \"2/4\"\narg91 = \"8/4\"\nx9 = simplify(arg90, arg91)\nv9 = true\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = \"2/4\"\narg101 = \"4/2\"\nx10 = simplify(arg100, arg101)\nv10 = true\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = \"1/5\"\narg111 = \"5/1\"\nx11 = simplify(arg110, arg111)\nv11 = true\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = \"1/5\"\narg121 = \"1/5\"\nx12 = simplify(arg120, arg121)\nv12 = false\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\n", "description": "आपका काम एक ऐसे कार्य को लागू करना है जो अभिव्यक्ति को सरल बनाएगा। \nx * n. फलन सही बताता है यदि x * n एक पूर्ण संख्या का मूल्यांकन करता है और गलत \nअन्यथा। x और n दोनों, एक अंश के स्ट्रिंग प्रतिनिधित्व हैं, और निम्नलिखित प्रारूप हैं, \n<अंश> <भाजक> जहाँ अंश और भाजक दोनों सकारात्मक पूर्ण संख्याएँ हैं। \n\nआप मान सकते हैं कि x, और n वैध अंश हैं, और विभाजक के रूप में शून्य नहीं हैं। \n\nसरलीकरण (\"1/5\", \"5/1\") = सही \nसरलीकरण (\"1/6\", \"2/1\") = गलत \nसरलीकरण (\"7/10\", \"10/2\") = गलत", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/67", "entry_point": "order_by_points", "test": "\n\narg00 = [1, 11, -1, -11, -12]\nx0 = order_by_points(arg00)\nv0 = [-1, -11, 1, -12, 11]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]\nx1 = order_by_points(arg10)\nv1 = [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = []\nx2 = order_by_points(arg20)\nv2 = []\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1, -11, -32, 43, 54, -98, 2, -3]\nx3 = order_by_points(arg30)\nv3 = [-3, -32, -98, -11, 1, 2, 43, 54]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\nx4 = order_by_points(arg40)\nv4 = [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [0, 6, 6, -76, -21, 23, 4]\nx5 = order_by_points(arg50)\nv5 = [-76, -21, 0, 4, 23, 6, 6]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "एक प्रकार्य लिखें जो पूर्णांकों की दी गई सूची को क्रमबद्ध करता है। \nउनके अंकों के योग के अनुसार आरोही क्रम में। \nनोटः यदि कई वस्तुएँ हैं जिनके अंकों का योग समान है, \nमूल सूची में उनके सूचकांक के आधार पर उन्हें ऑर्डर करें। \n\nउदाहरण के लिएः \n>>> ऑर्डर _ बाय _ पॉइंट्स ([1,11,-1,11,-12]) = = [-1,11,1,-12,11] \n>>> ऑर्डर _ बाय _ पॉइंट्स ([]) = = []", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/68", "entry_point": "specialfilter", "test": "\n\narg00 = [5, -2, 1, -5]\nx0 = specialfilter(arg00)\nv0 = 0\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [15, -73, 14, -15]\nx1 = specialfilter(arg10)\nv1 = 1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [33, -2, -3, 45, 21, 109]\nx2 = specialfilter(arg20)\nv2 = 2\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [43, -12, 93, 125, 121, 109]\nx3 = specialfilter(arg30)\nv3 = 4\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [71, -2, -33, 75, 21, 19]\nx4 = specialfilter(arg40)\nv4 = 3\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [1]\nx5 = specialfilter(arg50)\nv5 = 0\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = []\nx6 = specialfilter(arg60)\nv6 = 0\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "एक प्रकार्य लिखें जो इनपुट और रिटर्न के रूप में संख्याओं की एक सरणी लेता है। \nसरणी में तत्वों की संख्या जो 10 से अधिक है और दोनों \nएक संख्या के पहले और अंतिम अंक विषम (1,3,5,7,9) होते हैं। \nउदाहरण के लिएः \nविशेष फ़िल्टर ([15,-73,14,-15]) => 1 \nविशेष फ़िल्टर ([33,-2,-3,45,21,109]) => 2", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/69", "entry_point": "get_max_triples", "test": "\n\narg00 = 5\nx0 = get_max_triples(arg00)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 6\nx1 = get_max_triples(arg10)\nv1 = 4\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 10\nx2 = get_max_triples(arg20)\nv2 = 36\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 100\nx3 = get_max_triples(arg30)\nv3 = 53361\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "आपको एक सकारात्मक पूर्णांक n दिया जाता है। आपको n लंबाई का एक पूर्णांक सरणी a बनाना होगा। \nप्रत्येक i (1 ≤ i ≤ n) के लिए, a [i] = i * i-i + 1 का मान। \na के तीन गुना (a [i], a [j], a [k]) की संख्या वापस करें जहाँ i <j <k, \nऔर a [i] + a [j] + a [k] 3 का गुणज है। \n\nउदाहरणः \nइनपुटः एन = 5 \nआउटपुटः 1 \nव्याख्याः \na = [1,3,7,13,21] \nएकमात्र वैध ट्रिपल (1,7,13) है।", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/70", "entry_point": "bf", "test": "\n\narg00 = \"Jupiter\"\narg01 = \"Neptune\"\nx0 = bf(arg00, arg01)\nv0 = [\"Saturn\", \"Uranus\"]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Earth\"\narg11 = \"Mercury\"\nx1 = bf(arg10, arg11)\nv1 = [\"Venus\"]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"Mercury\"\narg21 = \"Uranus\"\nx2 = bf(arg20, arg21)\nv2 = [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"Neptune\"\narg31 = \"Venus\"\nx3 = bf(arg30, arg31)\nv3 = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"Earth\"\narg41 = \"Earth\"\nx4 = bf(arg40, arg41)\nv4 = []\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"Mars\"\narg51 = \"Earth\"\nx5 = bf(arg50, arg51)\nv5 = []\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"Jupiter\"\narg61 = \"Makemake\"\nx6 = bf(arg60, arg61)\nv6 = []\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "हमारे सौर मंडल में आठ ग्रह हैंः सूर्य के सबसे करीब \nबुध है, अगला शुक्र है, फिर पृथ्वी, मंगल, बृहस्पति, शनि, \nयूरेनस, नेपच्यून। \nएक कार्य लिखें जो दो ग्रहों के नाम ग्रह 1 और ग्रह 2 के रूप में लेता है। \nफ़ंक्शन को सभी ग्रहों वाले एक टुपल को वापस करना चाहिए जिनकी कक्षाएँ हैं \nग्रह 1 की कक्षा और ग्रह 2 की कक्षा के बीच स्थित, द्वारा क्रमबद्ध \nसूर्य की निकटता। \nयदि प्लैनेट1 या प्लैनेट2 है तो फ़ंक्शन को एक खाली टुपल वापस करना चाहिए। \nग्रहों के नाम सही नहीं हैं। \nउदाहरण \nbf (\"बृहस्पति\", \"नेपच्यून\") = => (\"शनि\", \"यूरेनस\") \nbf (\"पृथ्वी\", \"बुध\") = => (\"शुक्र\") \nbf (\"बुध\", \"यूरेनस\") = => (\"शुक्र\", \"पृथ्वी\", \"मंगल\", \"बृहस्पति\", \"शनि\")", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/71", "entry_point": "x_or_y", "test": "\n\narg00 = 7\narg01 = 34\narg02 = 12\nx0 = x_or_y(arg00, arg01, arg02)\nv0 = 34\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 15\narg11 = 8\narg12 = 5\nx1 = x_or_y(arg10, arg11, arg12)\nv1 = 5\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 3\narg21 = 33\narg22 = 5212\nx2 = x_or_y(arg20, arg21, arg22)\nv2 = 33\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 1259\narg31 = 3\narg32 = 52\nx3 = x_or_y(arg30, arg31, arg32)\nv3 = 3\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 7919\narg41 = -1\narg42 = 12\nx4 = x_or_y(arg40, arg41, arg42)\nv4 = -1\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 3609\narg51 = 1245\narg52 = 583\nx5 = x_or_y(arg50, arg51, arg52)\nv5 = 583\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 91\narg61 = 56\narg62 = 129\nx6 = x_or_y(arg60, arg61, arg62)\nv6 = 129\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 6\narg71 = 34\narg72 = 1234\nx7 = x_or_y(arg70, arg71, arg72)\nv7 = 1234\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 1\narg81 = 2\narg82 = 0\nx8 = x_or_y(arg80, arg81, arg82)\nv8 = 0\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 2\narg91 = 2\narg92 = 0\nx9 = x_or_y(arg90, arg91, arg92)\nv9 = 2\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\n", "description": "एक सरल प्रोग्राम जिसे x का मान वापस करना चाहिए यदि n है \nएक अभाज्य संख्या और अन्यथा y का मान वापस करना चाहिए। \n\nउदाहरण के लिएः \nx _ या _ y (7,34,12) = = 34 के लिए \nx _ या _ y (15,8,5) = = 5 के लिए", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/72", "entry_point": "double_the_difference", "test": "\n\narg00 = []\nx0 = double_the_difference(arg00)\nv0 = 0\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [5, 4]\nx1 = double_the_difference(arg10)\nv1 = 25\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [0.1, 0.2, 0.3]\nx2 = double_the_difference(arg20)\nv2 = 0\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [-10, -20, -30]\nx3 = double_the_difference(arg30)\nv3 = 0\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [-1, -2, 8]\nx4 = double_the_difference(arg40)\nv4 = 0\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [0.2, 3, 5]\nx5 = double_the_difference(arg50)\nv5 = 34\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [-99, -97, -95, -93, -91, -89, -87, -85, -83, -81, -79, -77, -75, -73, -71, -69, -67, -65, -63, -61, -59, -57, -55, -53, -51, -49, -47, -45, -43, -41, -39, -37, -35, -33, -31, -29, -27, -25, -23, -21, -19, -17, -15, -13, -11, -9, -7, -5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99]\nx6 = double_the_difference(arg60)\nv6 = 166650\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "संख्याओं की सूची दिए जाने पर, संख्याओं के वर्गों का योग वापस करें। \nविषम सूची में. उन संख्याओं को नजरअंदाज करें जो ऋणात्मक हैं या पूर्णांक नहीं हैं। \n\nडबल _ द _ डिफरेंस ([1,3,2,0]) = = 1 + 9 + 0 + 0 = 10 \nडबल _ द _ डिफरेंस ([-1,0]) = = 0 \nडबल _ द _ डिफरेंस ([9,-2]) = = 81 \nडबल _ द _ डिफरेंस ([0]) = = 0 \n\nयदि इनपुट सूची खाली है, तो 0 वापस करें।", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/73", "entry_point": "strongest_extension", "test": "\n\narg00 = \"Watashi\"\narg01 = [\"tEN\", \"niNE\", \"eIGHt8OKe\"]\nx0 = strongest_extension(arg00, arg01)\nv0 = \"Watashi.eIGHt8OKe\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Boku123\"\narg11 = [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]\nx1 = strongest_extension(arg10, arg11)\nv1 = \"Boku123.YEs.WeCaNe\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"__YESIMHERE\"\narg21 = [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]\nx2 = strongest_extension(arg20, arg21)\nv2 = \"__YESIMHERE.NuLl__\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"K\"\narg31 = [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]\nx3 = strongest_extension(arg30, arg31)\nv3 = \"K.TAR\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"__HAHA\"\narg41 = [\"Tab\", \"123\", \"781345\", \"-_-\"]\nx4 = strongest_extension(arg40, arg41)\nv4 = \"__HAHA.123\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"YameRore\"\narg51 = [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]\nx5 = strongest_extension(arg50, arg51)\nv5 = \"YameRore.okIWILL123\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"finNNalLLly\"\narg61 = [\"Die\", \"NowW\", \"Wow\", \"WoW\"]\nx6 = strongest_extension(arg60, arg61)\nv6 = \"finNNalLLly.WoW\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"_\"\narg71 = [\"Bb\", \"91245\"]\nx7 = strongest_extension(arg70, arg71)\nv7 = \"_.Bb\"\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"Sp\"\narg81 = [\"671235\", \"Bb\"]\nx8 = strongest_extension(arg80, arg81)\nv8 = \"Sp.671235\"\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "आपको एक वर्ग का नाम (एक स्ट्रिंग) और एक्सटेंशन की एक सूची दी जाएगी। \nइन विस्तारों का उपयोग कक्षा में अतिरिक्त वर्गों को लोड करने के लिए किया जाना है। \nविस्तार की ताकत इस प्रकार हैः मान लीजिए कि CAP बड़े अक्षर की संख्या है। \nविस्तार के नाम में अक्षर, और एस. एम. को छोटे अक्षरों की संख्या होने दें \nविस्तार के नाम में, ताकत सीएपी-एसएम अंश द्वारा दी जाती है। \nआपको सबसे मजबूत एक्सटेंशन ढूंढना चाहिए और इसमें एक स्ट्रिंग वापस करनी चाहिए। \nप्रारूपः ClassName.StrongestExtensionName। \nयदि एक ही ताकत के साथ दो या दो से अधिक विस्तार हैं, तो आपको करना चाहिए \nसूची में सबसे पहले आने वाले को चुनें। \nउदाहरण के लिए, यदि आपको वर्ग और सूची के रूप में \"स्लाइस\" दिए गए हैं \nविस्तारः ['SERVINGSliCes','चीज़','स्टुफ़ेड'] तो आपको करना चाहिए \nरिटर्न'Slices.SErviNGSliCes'क्योंकि'SERVINGSliCes'सबसे मजबूत एक्सटेंशन है \n(इसकी ताकत-1 है)। \nउदाहरणः \nसबसे मजबूत _ विस्तार के लिए ('माय _ क्लास', ['एए','बी','सीसी']) = ='my_class.AA'", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/74", "entry_point": "cycpattern_check", "test": "\n\narg00 = \"xyzw\"\narg01 = \"xyw\"\nx0 = cycpattern_check(arg00, arg01)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"yello\"\narg11 = \"ell\"\nx1 = cycpattern_check(arg10, arg11)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"whattup\"\narg21 = \"ptut\"\nx2 = cycpattern_check(arg20, arg21)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"efef\"\narg31 = \"fee\"\nx3 = cycpattern_check(arg30, arg31)\nv3 = true\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"abab\"\narg41 = \"aabb\"\nx4 = cycpattern_check(arg40, arg41)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"winemtt\"\narg51 = \"tinem\"\nx5 = cycpattern_check(arg50, arg51)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "आपको 2 शब्द दिए गए हैं। आपको सही लौटाने की आवश्यकता है यदि दूसरा शब्द या इसका कोई भी आवर्तन पहले शब्द में एक सबस्ट्रिंग है। \nसाइकपेटर्न _ चेक (\"ए. बी. सी. डी\"., \"ए. बी. डी\".) => गलत \nसाइकपेटर्न _ चेक (\"हैलो\", \"ईल\") => सही \nसाइकपेटर्न _ चेक (\"व्हासअप\", \"psus\") => गलत \nसाइकपेटर्न _ चेक (\"अबाब\", \"बा\") => सही \nसाइकपेटर्न _ चेक (\"ई. एफ. ई. एफ\"., \"ई. ई. एफ. एफ\".) => गलत \nसाइकपेटर्न _ चेक (\"हिमेन्स\", \"सिमेन\") => सही", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/75", "entry_point": "int_to_mini_roman", "test": "\n\narg00 = 19\nx0 = int_to_mini_roman(arg00)\nv0 = \"xix\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 152\nx1 = int_to_mini_roman(arg10)\nv1 = \"clii\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 251\nx2 = int_to_mini_roman(arg20)\nv2 = \"ccli\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 426\nx3 = int_to_mini_roman(arg30)\nv3 = \"cdxxvi\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 500\nx4 = int_to_mini_roman(arg40)\nv4 = \"d\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 1\nx5 = int_to_mini_roman(arg50)\nv5 = \"i\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 4\nx6 = int_to_mini_roman(arg60)\nv6 = \"iv\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 43\nx7 = int_to_mini_roman(arg70)\nv7 = \"xliii\"\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 90\nx8 = int_to_mini_roman(arg80)\nv8 = \"xc\"\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 94\nx9 = int_to_mini_roman(arg90)\nv9 = \"xciv\"\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = 532\nx10 = int_to_mini_roman(arg100)\nv10 = \"dxxxii\"\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = 900\nx11 = int_to_mini_roman(arg110)\nv11 = \"cm\"\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = 994\nx12 = int_to_mini_roman(arg120)\nv12 = \"cmxciv\"\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\narg130 = 1000\nx13 = int_to_mini_roman(arg130)\nv13 = \"m\"\nif x13 != v13\n    raise StandardError, \"Error at test case 14\"\nend\n\n", "description": "एक सकारात्मक पूर्णांक दिए जाने पर, एक स्ट्रिंग के रूप में इसके रोमन अंक के समतुल्य प्राप्त करें, \nऔर इसे छोटे अक्षर में वापस कर दें। \nप्रतिबंधः 1 <= संख्या <= 1000 \n\nउदाहरण के लिएः \n>>> इंट _ टू _ मिनी _ रोमन (19) = ='xix'\n>>> इंट _ टू _ मिनी _ रोमन (152) = ='क्लाई'\n>> इंट _ टू _ मिनी _ रोमन (426) = ='cdxxvi'", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/76", "entry_point": "right_angle_triangle", "test": "\n\narg00 = 3\narg01 = 4\narg02 = 5\nx0 = right_angle_triangle(arg00, arg01, arg02)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 1\narg11 = 2\narg12 = 3\nx1 = right_angle_triangle(arg10, arg11, arg12)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 10\narg21 = 6\narg22 = 8\nx2 = right_angle_triangle(arg20, arg21, arg22)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 2\narg31 = 2\narg32 = 2\nx3 = right_angle_triangle(arg30, arg31, arg32)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 7\narg41 = 24\narg42 = 25\nx4 = right_angle_triangle(arg40, arg41, arg42)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 10\narg51 = 5\narg52 = 7\nx5 = right_angle_triangle(arg50, arg51, arg52)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 5\narg61 = 12\narg62 = 13\nx6 = right_angle_triangle(arg60, arg61, arg62)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 15\narg71 = 8\narg72 = 17\nx7 = right_angle_triangle(arg70, arg71, arg72)\nv7 = true\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 48\narg81 = 55\narg82 = 73\nx8 = right_angle_triangle(arg80, arg81, arg82)\nv8 = true\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 1\narg91 = 1\narg92 = 1\nx9 = right_angle_triangle(arg90, arg91, arg92)\nv9 = false\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = 2\narg101 = 2\narg102 = 10\nx10 = right_angle_triangle(arg100, arg101, arg102)\nv10 = false\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\n", "description": "त्रिभुज की तीनों भुजाओं की लंबाई को देखते हुए. सही लौटें यदि तीनों \nभुजाएँ एक समकोण त्रिभुज बनाती हैं, अन्यथा गलत। \nसमकोण त्रिभुज वह त्रिभुज है जिसमें एक कोण समकोण या समकोण होता है। \n90 डिग्री। \nउदाहरणः \nसमकोण त्रिभुज (3,4,5) = = सही \nसमकोण त्रिभुज (1,2,3) = = गलत", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/77", "entry_point": "solve", "test": "\n\narg00 = \"AsDf\"\nx0 = solve(arg00)\nv0 = \"aSdF\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"1234\"\nx1 = solve(arg10)\nv1 = \"4321\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"ab\"\nx2 = solve(arg20)\nv2 = \"AB\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"#a@C\"\nx3 = solve(arg30)\nv3 = \"#A@c\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"#AsdfW^45\"\nx4 = solve(arg40)\nv4 = \"#aSDFw^45\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"#6@2\"\nx5 = solve(arg50)\nv5 = \"2@6#\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"#\\$a^D\"\nx6 = solve(arg60)\nv6 = \"#\\$A^d\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"#ccc\"\nx7 = solve(arg70)\nv7 = \"#CCC\"\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\n", "description": "आपको एक स्ट्रिंग s दी जाती है। \nयदि एस [आई] एक अक्षर है, तो इसके मामले को निचले से ऊपरी या इसके विपरीत करें, \nअन्यथा इसे वैसे ही रखें जैसे वह है। \nयदि स्ट्रिंग में कोई अक्षर नहीं हैं, तो स्ट्रिंग को उलट दें। \nफ़ंक्शन को परिणामी स्ट्रिंग वापस करनी चाहिए। \nउदाहरण \nहल करें (\"1234\") = \"4321\" \nहल करें (\"एबी\") = \"एबी\" \nहल करें (\"#a @C\") = \"#A @c\"", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/78", "entry_point": "string_to_md5", "test": "\n\narg00 = \"Hello world\"\nx0 = string_to_md5(arg00)\nv0 = \"3e25960a79dbc69b674cd4ec67a72c62\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"\"\nx1 = string_to_md5(arg10)\nv1 = nil\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"A B C\"\nx2 = string_to_md5(arg20)\nv2 = \"0ef78513b0cb8cef12743f5aeb35f888\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"password\"\nx3 = string_to_md5(arg30)\nv3 = \"5f4dcc3b5aa765d61d8327deb882cf99\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "स्ट्रिंग'टेक्स्ट'को देखते हुए, इसके md5 हैश समकक्ष स्ट्रिंग को वापस करें। \nयदि'पाठ'एक खाली स्ट्रिंग है, तो शून्य वापस करें। \n\n>> स्ट्रिंग _ से _ md5 ('हैलो वर्ल्ड') = ='3e25960a79dbc69b674cd4ec67a72c62'", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
{"task_id": "ruby/79", "entry_point": "generate_integers", "test": "\n\narg00 = 2\narg01 = 10\nx0 = generate_integers(arg00, arg01)\nv0 = [2, 4, 6, 8]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 10\narg11 = 2\nx1 = generate_integers(arg10, arg11)\nv1 = [2, 4, 6, 8]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 132\narg21 = 2\nx2 = generate_integers(arg20, arg21)\nv2 = [2, 4, 6, 8]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 17\narg31 = 89\nx3 = generate_integers(arg30, arg31)\nv3 = []\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "दो धनात्मक पूर्णांक a और b दिए जाने पर, a के बीच के सम अंकों को वापस करें। \nऔर बी, आरोही क्रम में। \n\nउदाहरण के लिएः \nपूर्णांक उत्पन्न करें (2,8) => [2,4,6,8] \nपूर्णांक उत्पन्न करें (8,2) => [2,4,6,8] \nपूर्णांक उत्पन्न करें (10,14) => []", "language": "ruby", "canonical_solution": null, "natural_language": "Hindi"}
