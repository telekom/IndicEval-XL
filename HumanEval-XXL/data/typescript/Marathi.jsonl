{"task_id": "typescript/0", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = below_zero([]);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = below_zero([1, 2, -3, 1, 2, -3]);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = below_zero([1, 2, -4, 5, 6]);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = below_zero([1, -1, 2, -2, 5, -5, 4, -4]);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = below_zero([1, -1, 2, -2, 5, -5, 4, -5]);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = below_zero([1, -2, 2, -2, 5, -5, 4, -4]);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "तुम्हाला बँक खात्यातील ठेवी आणि पैसे काढण्याच्या कामांची यादी दिली जाते, जी या शब्दाने सुरू होते. \nशून्य शिल्लक. कोणत्याही क्षणी खात्यातील शिल्लक शून्याच्या खाली येते का हे शोधणे हे तुमचे काम आहे, आणि \nत्या वेळी फंक्शनने खरे परत केले पाहिजे. अन्यथा ते खोटे परत केले पाहिजे. \n>>> शून्याच्या खाली ([1,2,3]) \nखोटारडेपणा. \n>>> शून्याच्या खाली ([1,2,-4,5]) \nखरे आहे.", "entry_point": "below_zero", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/1", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = sum_product([]);\nlet expected_1 = [0, 1];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = sum_product([1, 1, 1]);\nlet expected_2 = [3, 1];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = sum_product([100, 0]);\nlet expected_3 = [100, 0];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = sum_product([3, 5, 7]);\nlet expected_4 = [15, 105];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = sum_product([10]);\nlet expected_5 = [10, 10];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "पूर्णांकांच्या दिलेल्या यादीसाठी, यादीतील सर्व पूर्णांकांची बेरीज आणि गुणाकार असलेले टुपल परत करा. \nरिकामी बेरीज 0 च्या बरोबरीची असावी आणि रिकामे गुणाकार 1 च्या बरोबरीचा असावा. \n>>> sum _ product ([]) \n(0,1) \n>>> sum _ product ([1,2,3,4]) \n(10,24)", "entry_point": "sum_product", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/2", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = string_xor(\"111000\",\"101010\");\nlet expected_1 = \"010010\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = string_xor(\"1\",\"1\");\nlet expected_2 = \"0\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = string_xor(\"0101\",\"0000\");\nlet expected_3 = \"0101\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\n", "language": "typescript", "description": "इनपुट हे दोन स्ट्रिंग a आणि b आहेत ज्यात फक्त 1s आणि 0s आहेत. \nया इनपुटवर बायनरी एक्सओआर करा आणि परिणाम देखील स्ट्रिंग म्हणून परत करा. \n>> स्ट्रिंग _ xor ('010','110') \n'100'", "entry_point": "string_xor", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/3", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = longest([]);\nlet expected_1 = undefined;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = longest([\"x\", \"y\", \"z\"]);\nlet expected_2 = \"x\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = longest([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]);\nlet expected_3 = \"zzzz\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\n", "language": "typescript", "description": "स्ट्रिंगच्या यादीमधून सर्वात लांब स्ट्रिंग परत करा. एकाधिक असल्यास पहिली परत करा. \nसमान लांबीच्या स्ट्रिंग. इनपुट यादी रिकामी असल्यास शून्य परत करा. \n>>> सर्वात लांब ([]) \n\n>>> सर्वात लांब (['अ','ब','क']) \n'अ'\n>>> सर्वात लांब (['अ','बीबी','सीसीसी']) \n'सी. सी. सी.'", "entry_point": "longest", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/4", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = greatest_common_divisor(3,7);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = greatest_common_divisor(10,15);\nlet expected_2 = 5;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = greatest_common_divisor(49,14);\nlet expected_3 = 7;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = greatest_common_divisor(144,60);\nlet expected_4 = 12;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "अ आणि ब या दोन पूर्णांकांचा सर्वात मोठा सामान्य विभाजक परत करा. \n>>> ग्रेटेस्ट _ कॉमन _ डिव्हायझर (3,5) \n1. \n>>> ग्रेटेस्ट _ कॉमन _ डिव्हायझर (25,15) \n5.", "entry_point": "greatest_common_divisor", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/5", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = sort_numbers(\"\");\nlet expected_1 = \"\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = sort_numbers(\"three\");\nlet expected_2 = \"three\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = sort_numbers(\"three five nine\");\nlet expected_3 = \"three five nine\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = sort_numbers(\"five zero four seven nine eight\");\nlet expected_4 = \"zero four five seven eight nine\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = sort_numbers(\"six five four three two one zero\");\nlet expected_5 = \"zero one two three four five six\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "इनपुट ही'शून्य'ते'नऊ'पर्यंतच्या संख्यांची जागा-सीमांकित स्ट्रिंग आहे. \n'शून्य','एक','दोन','तीन','चार','पाच','सहा','सात','आठ'आणि'नऊ'हे वैध पर्याय आहेत. \nसर्वात लहान ते सर्वात मोठ्या क्रमांकांसह स्ट्रिंग परत करा \n>>> क्रमांकांची क्रमवारी लावा ('तीन एक पाच') \n'एक तीन पाच'", "entry_point": "sort_numbers", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/6", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = rescale_to_unit([2.0, 49.9]);\nlet expected_1 = [0.0, 1.0];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = rescale_to_unit([100.0, 49.9]);\nlet expected_2 = [1.0, 0.0];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]);\nlet expected_3 = [0.0, 0.25, 0.5, 0.75, 1.0];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = rescale_to_unit([2.0, 1.0, 5.0, 3.0, 4.0]);\nlet expected_4 = [0.25, 0.0, 1.0, 0.5, 0.75];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = rescale_to_unit([12.0, 11.0, 15.0, 13.0, 14.0]);\nlet expected_5 = [0.25, 0.0, 1.0, 0.5, 0.75];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "संख्यांची (किमान दोन घटकांची) यादी दिल्यास, त्या यादीत एक रेषीय परिवर्तन लागू करा, \nम्हणजे सर्वात लहान संख्या 0 होईल आणि सर्वात मोठी संख्या 1 होईल. \n>> पुनर्चक्रण _ ते _ एकक ([1., 2., 3., 4., 5]) \n[0,0,25,0,0.75,1.0]", "entry_point": "rescale_to_unit", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/7", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = flip_case(\"\");\nlet expected_1 = \"\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = flip_case(\"Hello!\");\nlet expected_2 = \"hELLO!\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = flip_case(\"These violent delights have violent ends\");\nlet expected_3 = \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\n", "language": "typescript", "description": "दिलेल्या स्ट्रिंगसाठी, लहान अक्षरांना मोठ्या अक्षरात आणि मोठ्या अक्षरांना लहान अक्षरात उलटवा. \n>>> फ्लीप केस ('हॅलो') \n'हॅलो'", "entry_point": "flip_case", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/8", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = get_positive([-1, -2, 4, 5, 6]);\nlet expected_1 = [4, 5, 6];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = get_positive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]);\nlet expected_2 = [5, 3, 2, 3, 3, 9, 123, 1];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = get_positive([-1, -2]);\nlet expected_3 = [];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = get_positive([]);\nlet expected_4 = [];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "यादीतील केवळ सकारात्मक संख्या परत करा. \n>>> सकारात्मक मिळवा ([-1,2,-4,5,6]) \n[2,5,6] \n>>> सकारात्मक मिळवा ([5,3,-5,2,-3,3,9,0,123,1,-10]) \n[5,3,2,3,9,123,1]", "entry_point": "get_positive", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/9", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_prime(6);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_prime(101);\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_prime(11);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_prime(13441);\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_prime(61);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_prime(4);\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_prime(1);\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = is_prime(5);\nlet expected_8 = true;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = is_prime(11);\nlet expected_9 = true;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = is_prime(17);\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = is_prime(85);\nlet expected_11 = false;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = is_prime(77);\nlet expected_12 = false;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = is_prime(255379);\nlet expected_13 = false;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\n", "language": "typescript", "description": "दिलेली संख्या अभाज्य असल्यास खरी परत करा आणि अन्यथा खोटी. \n>>> हे _ प्राइम आहे (6) \nखोटारडेपणा. \n= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \nखरे आहे. \n>>> हे _ प्राइम आहे (11) \nखरे आहे. \n= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \nखरे आहे. \n>>> हे _ प्राइम आहे (61) \nखरे आहे. \n>>> हे _ प्राइम आहे (4) \nखोटारडेपणा. \n>>> हे _ प्राइम आहे (1) \nखोटारडेपणा.", "entry_point": "is_prime", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/10", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = unique([5, 3, 5, 2, 3, 3, 9, 0, 123]);\nlet expected_1 = [0, 2, 3, 5, 9, 123];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\n", "language": "typescript", "description": "यादीतील क्रमवारी लावलेले अद्वितीय घटक परत करा \n>>> अद्वितीय ([5,3,5,2,3,3,9,0,123]) \n[0,2,3,5,9,123]", "entry_point": "unique", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/11", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = prime_fib(1);\nlet expected_1 = 2;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = prime_fib(2);\nlet expected_2 = 3;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = prime_fib(3);\nlet expected_3 = 5;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = prime_fib(4);\nlet expected_4 = 13;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = prime_fib(5);\nlet expected_5 = 89;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = prime_fib(6);\nlet expected_6 = 233;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = prime_fib(7);\nlet expected_7 = 1597;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = prime_fib(8);\nlet expected_8 = 28657;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = prime_fib(9);\nlet expected_9 = 514229;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = prime_fib(10);\nlet expected_10 = 433494437;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "प्राइम _ फायब n-th संख्या परत करतो जी फिबोनाची संख्या आहे आणि ती देखील अविभाज्य आहे. \n>>> प्राइम _ फायब (1) \n2. \n>>> प्राइम _ फायब (2) \n3. \n>>> प्राइम _ फायब (3) \n5. \n>>> प्राइम _ फायब (4) \n13. \n>>> प्राइम _ फायब (5) \n89", "entry_point": "prime_fib", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/12", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = triples_sum_to_zero([1, 3, 5, 0]);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = triples_sum_to_zero([1, 3, 5, -1]);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = triples_sum_to_zero([1, 3, -2, 1]);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = triples_sum_to_zero([1, 2, 3, 7]);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = triples_sum_to_zero([1, 2, 5, 7]);\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = triples_sum_to_zero([2, 4, -5, 3, 9, 7]);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = triples_sum_to_zero([1]);\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = triples_sum_to_zero([1, 3, 5, -100]);\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = triples_sum_to_zero([100, 3, 5, -100]);\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "ट्रिपल्स _ सम _ ते _ शून्य हे इनपुट म्हणून पूर्णांकांची यादी घेतात. \nयादीत तीन वेगळे घटक असल्यास ते खरे परत करते \nबेरीज शून्यावर, आणि अन्यथा खोटे. \n\n>>> ट्रिपल्स _ सम _ ते _ शून्य ([1,35,5,0]) \nखोटारडेपणा. \n>>> ट्रिपल्स _ सम _ ते _ शून्य ([1,3,-2,1]) \nखरे आहे. \n>>> ट्रिपल्स _ सम _ ते _ शून्य ([1,2,3,7]) \nखोटारडेपणा. \n>>> ट्रिपल्स _ सम _ ते _ शून्य ([2,4,-5,3,9,7]) \nखरे आहे. \n>>> ट्रिपल्स _ सम _ ते _ शून्य ([1]) \nखोटारडेपणा.", "entry_point": "triples_sum_to_zero", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/13", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = pairs_sum_to_zero([1, 3, 5, 0]);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = pairs_sum_to_zero([1, 3, -2, 1]);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = pairs_sum_to_zero([1, 2, 3, 7]);\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = pairs_sum_to_zero([2, 4, -5, 3, 5, 7]);\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = pairs_sum_to_zero([1]);\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = pairs_sum_to_zero([-3, 9, -1, 3, 2, 30]);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = pairs_sum_to_zero([-3, 9, -1, 3, 2, 31]);\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = pairs_sum_to_zero([-3, 9, -1, 4, 2, 30]);\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = pairs_sum_to_zero([-3, 9, -1, 4, 2, 31]);\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "pairs _ sum _ to _ zero हे इनपुट म्हणून पूर्णांकांची यादी घेते. \nयादीत दोन वेगळे घटक असल्यास ते खरे परत करते \nबेरीज शून्यावर, आणि अन्यथा खोटे. \n>>> जोड्या _ बेरीज _ ते _ शून्य ([1,35,5,0]) \nखोटारडेपणा. \n>>> जोड्या _ बेरीज _ ते _ शून्य ([1,3,-2,1]) \nखोटारडेपणा. \n>>> जोड्या _ बेरीज _ ते _ शून्य ([1,2,3,7]) \nखोटारडेपणा. \n>>> जोड्या _ बेरीज _ ते _ शून्य ([2,4,-5,3,5,7]) \nखरे आहे. \n>>> जोड्या _ बेरीज _ ते _ शून्य ([1]) \nखोटारडेपणा.", "entry_point": "pairs_sum_to_zero", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/14", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = fib4(5);\nlet expected_1 = 4;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = fib4(8);\nlet expected_2 = 28;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = fib4(10);\nlet expected_3 = 104;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = fib4(12);\nlet expected_4 = 386;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "फायब 4 क्रमांकाचा क्रम हा फायबोनॅकी सेकुनेससारखाच एक क्रम आहे ज्याची व्याख्या खालीलप्रमाणे केली आहेः \nफायब 4 (0)-> 0 \nफायब 4 (1)-> 0 \nफायब 4 (2)-> 2 \nफायब 4 (3)-> 0 \nफायब 4 (एन)-> फायब 4 (एन-1) + फायब 4 (एन-2) + फायब 4 (एन-3) + फायब 4 (एन-4). \nफायब 4 क्रमांकाच्या क्रमाचा n-th घटक कार्यक्षमतेने मोजण्यासाठी कृपया कार्य लिहा. पुनरावृत्ती वापरू नका. \n>>> फायब 4 (5) \n4. \n>>> फायब 4 (6) \n8. \n>>> फायब 4 (7) \n14.", "entry_point": "fib4", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/15", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = median([3, 1, 2, 4, 5]);\nlet expected_1 = 3;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = median([-10, 4, 6, 1000, 10, 20]);\nlet expected_2 = 8.0;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = median([5]);\nlet expected_3 = 5;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = median([6, 5]);\nlet expected_4 = 5.5;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = median([8, 1, 3, 9, 9, 2, 7]);\nlet expected_5 = 7;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "यादीतील घटकांची मध्यक परत करा. \n>>> मध्यक ([3,1,2,4,5]) \n3. \n>>> मध्यक ([-10,4,6,1000,10,20]) \n15. 0", "entry_point": "median", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/16", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_palindrome(\"\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_palindrome(\"aba\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_palindrome(\"aaaaa\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_palindrome(\"zbcd\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_palindrome(\"xywyx\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_palindrome(\"xywyz\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_palindrome(\"xywzx\");\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "दिलेली स्ट्रिंग पॅलिंड्रोम आहे का ते तपासते \n>>> हे पॅलिंड्रोम आहे (\") \nखरे आहे. \n>>> हे पॅलिंड्रोम आहे ('अबा') \nखरे आहे. \n>>> हे पॅलिंड्रोम आहे ('एएएए') \nखरे आहे. \n>>> is _ palindrom ('zbcd') आहे \nखोटारडेपणा.", "entry_point": "is_palindrome", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/17", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = remove_vowels(\"\");\nlet expected_1 = \"\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = remove_vowels(\"abcdef\\nghijklm\");\nlet expected_2 = \"bcdf\\nghjklm\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = remove_vowels(\"fedcba\");\nlet expected_3 = \"fdcb\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = remove_vowels(\"eeeee\");\nlet expected_4 = \"\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = remove_vowels(\"acBAA\");\nlet expected_5 = \"cB\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = remove_vowels(\"EcBOO\");\nlet expected_6 = \"cB\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = remove_vowels(\"ybcd\");\nlet expected_7 = \"ybcd\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "रिमूव्ह _ व्हॉवेल्स हे एक कार्य आहे जे स्ट्रिंग घेते आणि स्वरांशिवाय स्ट्रिंग परत करते. \n>>> स्वर काढून टाका (\") \n\"\n>>> स्वर काढून टाका (\"abcdef\\nghijklm\") \n'बी. सी. डी. एफ. \\एनजी. जे. के. एल. एम.'\n>>> स्वर काढून टाका ('abcdef') \n'बी. सी. डी. एफ.'\n>>> स्वर काढून टाका ('एएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएएए \n\"\n>>> स्वर काढून टाका ('आ. ए. बी. ए. ए.') \n'ब'\n>>> स्वर काढून टाका ('zbcd') \n'zbcd'", "entry_point": "remove_vowels", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/18", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = below_threshold([1, 2, 4, 10],100);\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = below_threshold([1, 20, 4, 10],5);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = below_threshold([1, 20, 4, 10],21);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = below_threshold([1, 20, 4, 10],22);\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = below_threshold([1, 8, 4, 10],11);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = below_threshold([1, 8, 4, 10],10);\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "'l'यादीमधील सर्व संख्या't'च्या थ्रेशोल्डच्या खाली असल्यास'खरे'परत करा. \n>>> थ्रेशोल्डच्या खाली ([1,2,4,10], 100) \nखरे आहे. \n>>> थ्रेशोल्डच्या खाली ([1,20,4,10], 5) \nखोटारडेपणा.", "entry_point": "below_threshold", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/19", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = add(0,1);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = add(1,0);\nlet expected_2 = 1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = add(2,3);\nlet expected_3 = 5;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = add(5,7);\nlet expected_4 = 12;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = add(7,5);\nlet expected_5 = 12;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = add(572,725);\nlet expected_6 = 1297;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = add(51,804);\nlet expected_7 = 855;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = add(645,96);\nlet expected_8 = 741;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = add(712,853);\nlet expected_9 = 1565;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = add(223,101);\nlet expected_10 = 324;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = add(76,29);\nlet expected_11 = 105;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = add(416,149);\nlet expected_12 = 565;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = add(145,409);\nlet expected_13 = 554;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = add(535,430);\nlet expected_14 = 965;\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\nlet actual_15 = add(118,303);\nlet expected_15 = 421;\nassert.deepEqual(actual_15, expected_15, \"Exception --- test case 14 failed to pass\");\n\nlet actual_16 = add(287,94);\nlet expected_16 = 381;\nassert.deepEqual(actual_16, expected_16, \"Exception --- test case 15 failed to pass\");\n\nlet actual_17 = add(768,257);\nlet expected_17 = 1025;\nassert.deepEqual(actual_17, expected_17, \"Exception --- test case 16 failed to pass\");\n\nlet actual_18 = add(421,677);\nlet expected_18 = 1098;\nassert.deepEqual(actual_18, expected_18, \"Exception --- test case 17 failed to pass\");\n\nlet actual_19 = add(802,814);\nlet expected_19 = 1616;\nassert.deepEqual(actual_19, expected_19, \"Exception --- test case 18 failed to pass\");\n\nlet actual_20 = add(510,922);\nlet expected_20 = 1432;\nassert.deepEqual(actual_20, expected_20, \"Exception --- test case 19 failed to pass\");\n\nlet actual_21 = add(345,819);\nlet expected_21 = 1164;\nassert.deepEqual(actual_21, expected_21, \"Exception --- test case 20 failed to pass\");\n\nlet actual_22 = add(895,436);\nlet expected_22 = 1331;\nassert.deepEqual(actual_22, expected_22, \"Exception --- test case 21 failed to pass\");\n\nlet actual_23 = add(123,424);\nlet expected_23 = 547;\nassert.deepEqual(actual_23, expected_23, \"Exception --- test case 22 failed to pass\");\n\nlet actual_24 = add(923,245);\nlet expected_24 = 1168;\nassert.deepEqual(actual_24, expected_24, \"Exception --- test case 23 failed to pass\");\n\nlet actual_25 = add(23,438);\nlet expected_25 = 461;\nassert.deepEqual(actual_25, expected_25, \"Exception --- test case 24 failed to pass\");\n\nlet actual_26 = add(565,133);\nlet expected_26 = 698;\nassert.deepEqual(actual_26, expected_26, \"Exception --- test case 25 failed to pass\");\n\nlet actual_27 = add(945,925);\nlet expected_27 = 1870;\nassert.deepEqual(actual_27, expected_27, \"Exception --- test case 26 failed to pass\");\n\nlet actual_28 = add(261,983);\nlet expected_28 = 1244;\nassert.deepEqual(actual_28, expected_28, \"Exception --- test case 27 failed to pass\");\n\nlet actual_29 = add(139,577);\nlet expected_29 = 716;\nassert.deepEqual(actual_29, expected_29, \"Exception --- test case 28 failed to pass\");\n\nlet actual_30 = add(763,178);\nlet expected_30 = 941;\nassert.deepEqual(actual_30, expected_30, \"Exception --- test case 29 failed to pass\");\n\nlet actual_31 = add(147,892);\nlet expected_31 = 1039;\nassert.deepEqual(actual_31, expected_31, \"Exception --- test case 30 failed to pass\");\n\nlet actual_32 = add(436,402);\nlet expected_32 = 838;\nassert.deepEqual(actual_32, expected_32, \"Exception --- test case 31 failed to pass\");\n\nlet actual_33 = add(610,581);\nlet expected_33 = 1191;\nassert.deepEqual(actual_33, expected_33, \"Exception --- test case 32 failed to pass\");\n\nlet actual_34 = add(103,416);\nlet expected_34 = 519;\nassert.deepEqual(actual_34, expected_34, \"Exception --- test case 33 failed to pass\");\n\nlet actual_35 = add(339,990);\nlet expected_35 = 1329;\nassert.deepEqual(actual_35, expected_35, \"Exception --- test case 34 failed to pass\");\n\nlet actual_36 = add(130,504);\nlet expected_36 = 634;\nassert.deepEqual(actual_36, expected_36, \"Exception --- test case 35 failed to pass\");\n\nlet actual_37 = add(242,717);\nlet expected_37 = 959;\nassert.deepEqual(actual_37, expected_37, \"Exception --- test case 36 failed to pass\");\n\nlet actual_38 = add(562,110);\nlet expected_38 = 672;\nassert.deepEqual(actual_38, expected_38, \"Exception --- test case 37 failed to pass\");\n\nlet actual_39 = add(396,909);\nlet expected_39 = 1305;\nassert.deepEqual(actual_39, expected_39, \"Exception --- test case 38 failed to pass\");\n\nlet actual_40 = add(887,703);\nlet expected_40 = 1590;\nassert.deepEqual(actual_40, expected_40, \"Exception --- test case 39 failed to pass\");\n\nlet actual_41 = add(870,551);\nlet expected_41 = 1421;\nassert.deepEqual(actual_41, expected_41, \"Exception --- test case 40 failed to pass\");\n\nlet actual_42 = add(422,391);\nlet expected_42 = 813;\nassert.deepEqual(actual_42, expected_42, \"Exception --- test case 41 failed to pass\");\n\nlet actual_43 = add(299,505);\nlet expected_43 = 804;\nassert.deepEqual(actual_43, expected_43, \"Exception --- test case 42 failed to pass\");\n\nlet actual_44 = add(346,56);\nlet expected_44 = 402;\nassert.deepEqual(actual_44, expected_44, \"Exception --- test case 43 failed to pass\");\n\nlet actual_45 = add(36,706);\nlet expected_45 = 742;\nassert.deepEqual(actual_45, expected_45, \"Exception --- test case 44 failed to pass\");\n\nlet actual_46 = add(738,411);\nlet expected_46 = 1149;\nassert.deepEqual(actual_46, expected_46, \"Exception --- test case 45 failed to pass\");\n\nlet actual_47 = add(679,87);\nlet expected_47 = 766;\nassert.deepEqual(actual_47, expected_47, \"Exception --- test case 46 failed to pass\");\n\nlet actual_48 = add(25,303);\nlet expected_48 = 328;\nassert.deepEqual(actual_48, expected_48, \"Exception --- test case 47 failed to pass\");\n\nlet actual_49 = add(161,612);\nlet expected_49 = 773;\nassert.deepEqual(actual_49, expected_49, \"Exception --- test case 48 failed to pass\");\n\nlet actual_50 = add(306,841);\nlet expected_50 = 1147;\nassert.deepEqual(actual_50, expected_50, \"Exception --- test case 49 failed to pass\");\n\nlet actual_51 = add(973,411);\nlet expected_51 = 1384;\nassert.deepEqual(actual_51, expected_51, \"Exception --- test case 50 failed to pass\");\n\nlet actual_52 = add(711,157);\nlet expected_52 = 868;\nassert.deepEqual(actual_52, expected_52, \"Exception --- test case 51 failed to pass\");\n\nlet actual_53 = add(471,27);\nlet expected_53 = 498;\nassert.deepEqual(actual_53, expected_53, \"Exception --- test case 52 failed to pass\");\n\nlet actual_54 = add(714,792);\nlet expected_54 = 1506;\nassert.deepEqual(actual_54, expected_54, \"Exception --- test case 53 failed to pass\");\n\nlet actual_55 = add(38,206);\nlet expected_55 = 244;\nassert.deepEqual(actual_55, expected_55, \"Exception --- test case 54 failed to pass\");\n\nlet actual_56 = add(907,343);\nlet expected_56 = 1250;\nassert.deepEqual(actual_56, expected_56, \"Exception --- test case 55 failed to pass\");\n\nlet actual_57 = add(23,760);\nlet expected_57 = 783;\nassert.deepEqual(actual_57, expected_57, \"Exception --- test case 56 failed to pass\");\n\nlet actual_58 = add(524,859);\nlet expected_58 = 1383;\nassert.deepEqual(actual_58, expected_58, \"Exception --- test case 57 failed to pass\");\n\nlet actual_59 = add(30,529);\nlet expected_59 = 559;\nassert.deepEqual(actual_59, expected_59, \"Exception --- test case 58 failed to pass\");\n\nlet actual_60 = add(341,691);\nlet expected_60 = 1032;\nassert.deepEqual(actual_60, expected_60, \"Exception --- test case 59 failed to pass\");\n\nlet actual_61 = add(167,729);\nlet expected_61 = 896;\nassert.deepEqual(actual_61, expected_61, \"Exception --- test case 60 failed to pass\");\n\nlet actual_62 = add(636,289);\nlet expected_62 = 925;\nassert.deepEqual(actual_62, expected_62, \"Exception --- test case 61 failed to pass\");\n\nlet actual_63 = add(503,144);\nlet expected_63 = 647;\nassert.deepEqual(actual_63, expected_63, \"Exception --- test case 62 failed to pass\");\n\nlet actual_64 = add(51,985);\nlet expected_64 = 1036;\nassert.deepEqual(actual_64, expected_64, \"Exception --- test case 63 failed to pass\");\n\nlet actual_65 = add(287,149);\nlet expected_65 = 436;\nassert.deepEqual(actual_65, expected_65, \"Exception --- test case 64 failed to pass\");\n\nlet actual_66 = add(659,75);\nlet expected_66 = 734;\nassert.deepEqual(actual_66, expected_66, \"Exception --- test case 65 failed to pass\");\n\nlet actual_67 = add(462,797);\nlet expected_67 = 1259;\nassert.deepEqual(actual_67, expected_67, \"Exception --- test case 66 failed to pass\");\n\nlet actual_68 = add(406,141);\nlet expected_68 = 547;\nassert.deepEqual(actual_68, expected_68, \"Exception --- test case 67 failed to pass\");\n\nlet actual_69 = add(106,44);\nlet expected_69 = 150;\nassert.deepEqual(actual_69, expected_69, \"Exception --- test case 68 failed to pass\");\n\nlet actual_70 = add(300,934);\nlet expected_70 = 1234;\nassert.deepEqual(actual_70, expected_70, \"Exception --- test case 69 failed to pass\");\n\nlet actual_71 = add(471,524);\nlet expected_71 = 995;\nassert.deepEqual(actual_71, expected_71, \"Exception --- test case 70 failed to pass\");\n\nlet actual_72 = add(122,429);\nlet expected_72 = 551;\nassert.deepEqual(actual_72, expected_72, \"Exception --- test case 71 failed to pass\");\n\nlet actual_73 = add(735,195);\nlet expected_73 = 930;\nassert.deepEqual(actual_73, expected_73, \"Exception --- test case 72 failed to pass\");\n\nlet actual_74 = add(335,484);\nlet expected_74 = 819;\nassert.deepEqual(actual_74, expected_74, \"Exception --- test case 73 failed to pass\");\n\nlet actual_75 = add(28,809);\nlet expected_75 = 837;\nassert.deepEqual(actual_75, expected_75, \"Exception --- test case 74 failed to pass\");\n\nlet actual_76 = add(430,20);\nlet expected_76 = 450;\nassert.deepEqual(actual_76, expected_76, \"Exception --- test case 75 failed to pass\");\n\nlet actual_77 = add(916,635);\nlet expected_77 = 1551;\nassert.deepEqual(actual_77, expected_77, \"Exception --- test case 76 failed to pass\");\n\nlet actual_78 = add(301,999);\nlet expected_78 = 1300;\nassert.deepEqual(actual_78, expected_78, \"Exception --- test case 77 failed to pass\");\n\nlet actual_79 = add(454,466);\nlet expected_79 = 920;\nassert.deepEqual(actual_79, expected_79, \"Exception --- test case 78 failed to pass\");\n\nlet actual_80 = add(905,259);\nlet expected_80 = 1164;\nassert.deepEqual(actual_80, expected_80, \"Exception --- test case 79 failed to pass\");\n\nlet actual_81 = add(168,205);\nlet expected_81 = 373;\nassert.deepEqual(actual_81, expected_81, \"Exception --- test case 80 failed to pass\");\n\nlet actual_82 = add(570,434);\nlet expected_82 = 1004;\nassert.deepEqual(actual_82, expected_82, \"Exception --- test case 81 failed to pass\");\n\nlet actual_83 = add(64,959);\nlet expected_83 = 1023;\nassert.deepEqual(actual_83, expected_83, \"Exception --- test case 82 failed to pass\");\n\nlet actual_84 = add(957,510);\nlet expected_84 = 1467;\nassert.deepEqual(actual_84, expected_84, \"Exception --- test case 83 failed to pass\");\n\nlet actual_85 = add(722,598);\nlet expected_85 = 1320;\nassert.deepEqual(actual_85, expected_85, \"Exception --- test case 84 failed to pass\");\n\nlet actual_86 = add(770,226);\nlet expected_86 = 996;\nassert.deepEqual(actual_86, expected_86, \"Exception --- test case 85 failed to pass\");\n\nlet actual_87 = add(579,66);\nlet expected_87 = 645;\nassert.deepEqual(actual_87, expected_87, \"Exception --- test case 86 failed to pass\");\n\nlet actual_88 = add(117,674);\nlet expected_88 = 791;\nassert.deepEqual(actual_88, expected_88, \"Exception --- test case 87 failed to pass\");\n\nlet actual_89 = add(530,30);\nlet expected_89 = 560;\nassert.deepEqual(actual_89, expected_89, \"Exception --- test case 88 failed to pass\");\n\nlet actual_90 = add(776,345);\nlet expected_90 = 1121;\nassert.deepEqual(actual_90, expected_90, \"Exception --- test case 89 failed to pass\");\n\nlet actual_91 = add(327,389);\nlet expected_91 = 716;\nassert.deepEqual(actual_91, expected_91, \"Exception --- test case 90 failed to pass\");\n\nlet actual_92 = add(596,12);\nlet expected_92 = 608;\nassert.deepEqual(actual_92, expected_92, \"Exception --- test case 91 failed to pass\");\n\nlet actual_93 = add(599,511);\nlet expected_93 = 1110;\nassert.deepEqual(actual_93, expected_93, \"Exception --- test case 92 failed to pass\");\n\nlet actual_94 = add(936,476);\nlet expected_94 = 1412;\nassert.deepEqual(actual_94, expected_94, \"Exception --- test case 93 failed to pass\");\n\nlet actual_95 = add(461,14);\nlet expected_95 = 475;\nassert.deepEqual(actual_95, expected_95, \"Exception --- test case 94 failed to pass\");\n\nlet actual_96 = add(966,157);\nlet expected_96 = 1123;\nassert.deepEqual(actual_96, expected_96, \"Exception --- test case 95 failed to pass\");\n\nlet actual_97 = add(326,91);\nlet expected_97 = 417;\nassert.deepEqual(actual_97, expected_97, \"Exception --- test case 96 failed to pass\");\n\nlet actual_98 = add(392,455);\nlet expected_98 = 847;\nassert.deepEqual(actual_98, expected_98, \"Exception --- test case 97 failed to pass\");\n\nlet actual_99 = add(446,477);\nlet expected_99 = 923;\nassert.deepEqual(actual_99, expected_99, \"Exception --- test case 98 failed to pass\");\n\nlet actual_100 = add(324,860);\nlet expected_100 = 1184;\nassert.deepEqual(actual_100, expected_100, \"Exception --- test case 99 failed to pass\");\n\nlet actual_101 = add(945,85);\nlet expected_101 = 1030;\nassert.deepEqual(actual_101, expected_101, \"Exception --- test case 100 failed to pass\");\n\nlet actual_102 = add(886,582);\nlet expected_102 = 1468;\nassert.deepEqual(actual_102, expected_102, \"Exception --- test case 101 failed to pass\");\n\nlet actual_103 = add(886,712);\nlet expected_103 = 1598;\nassert.deepEqual(actual_103, expected_103, \"Exception --- test case 102 failed to pass\");\n\nlet actual_104 = add(842,953);\nlet expected_104 = 1795;\nassert.deepEqual(actual_104, expected_104, \"Exception --- test case 103 failed to pass\");\n\n", "language": "typescript", "description": "x आणि y या दोन संख्या जोडा. \n>>> जोडा (2,3) \n5. \n>>> जोडा (5,7) \n12.", "entry_point": "add", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/20", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = same_chars(\"eabcdzzzz\",\"dddzzzzzzzddeddabc\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = same_chars(\"abcd\",\"dddddddabc\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = same_chars(\"dddddddabc\",\"abcd\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = same_chars(\"eabcd\",\"dddddddabc\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = same_chars(\"abcd\",\"dddddddabcf\");\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = same_chars(\"eabcdzzzz\",\"dddzzzzzzzddddabc\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = same_chars(\"aabb\",\"aaccc\");\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "दोन शब्दांमध्ये समान अक्षरे आहेत का ते तपासा. \n>>> समान _ अक्षर ('eabcdzzzz','dddzzzzzuddeddabc') \nखरे आहे. \n>>> समान अक्षर ('ए. बी. सी. डी.','डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. \nखरे आहे. \n>>> समान अक्षर ('ddddddabc','abcd') \nखरे आहे. \n>>> समान अक्षर ('ई. ए. बी. सी. डी.','डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. \nखोटारडेपणा. \n>>> समान अक्षर ('ए. बी. सी. डी.','डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. \nखोटारडेपणा. \n>>> समान _ अक्षर ('eabcdzzzz','dddzzzzzddddddabc') \nखोटारडेपणा.", "entry_point": "same_chars", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/21", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = fib(10);\nlet expected_1 = 55;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = fib(1);\nlet expected_2 = 1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = fib(8);\nlet expected_3 = 21;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = fib(11);\nlet expected_4 = 89;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = fib(12);\nlet expected_5 = 144;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "n-th फिबोनाची क्रमांक परत करा. \n>>> फायब (10) \n55. \n>>> फायब (1) \n1. \n>>> फायब (8) \n21.", "entry_point": "fib", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/22", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = common([1, 4, 3, 34, 653, 2, 5],[5, 7, 1, 5, 9, 653, 121]);\nlet expected_1 = [1, 5, 653];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = common([5, 3, 2, 8],[3, 2]);\nlet expected_2 = [2, 3];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = common([4, 3, 2, 8],[3, 2, 4]);\nlet expected_3 = [2, 3, 4];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = common([4, 3, 2, 8],[]);\nlet expected_4 = [];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "दोन याद्यांसाठी विशिष्ट सामान्य घटकांची क्रमवारी लावून परत करा. \n>> सामान्य ([1,4,3,34,653,2,5], [5,7,1,5,9,653,121]) \n[1,5,653] \n>>> सामान्य ([5,3,2,8], [3,2]) \n[2,3]", "entry_point": "common", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/23", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = largest_prime_factor(15);\nlet expected_1 = 5;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = largest_prime_factor(27);\nlet expected_2 = 3;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = largest_prime_factor(63);\nlet expected_3 = 7;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = largest_prime_factor(330);\nlet expected_4 = 11;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = largest_prime_factor(13195);\nlet expected_5 = 29;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "n चा सर्वात मोठा अभाज्य घटक परत करा. n> 1 समजा आणि तो अभाज्य नाही. \n>>> सर्वांत मोठा _ मुख्य _ घटक (13195) \n29 \n>>> सर्वांत मोठा _ मुख्य _ घटक (2048) \n2.", "entry_point": "largest_prime_factor", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/24", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = sum_to_n(1);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = sum_to_n(6);\nlet expected_2 = 21;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = sum_to_n(11);\nlet expected_3 = 66;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = sum_to_n(30);\nlet expected_4 = 465;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = sum_to_n(100);\nlet expected_5 = 5050;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "sum _ to _ n हे एक कार्य आहे जे 1 ते n पर्यंतच्या संख्यांची बेरीज करते. \n>>> बेरीज _ ते _ एन (30) \n465 \n>>> बेरीज _ ते _ एन (100) \n5050 \n>>> बेरीज _ ते _ एन (5) \n15. \n>>> बेरीज _ ते _ एन (10) \n55. \n>>> बेरीज _ ते _ एन (1) \n1.", "entry_point": "sum_to_n", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/25", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = derivative([3, 1, 2, 4, 5]);\nlet expected_1 = [1, 4, 12, 20];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = derivative([1, 2, 3]);\nlet expected_2 = [2, 6];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = derivative([3, 2, 1]);\nlet expected_3 = [2, 2];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = derivative([3, 2, 1, 0, 4]);\nlet expected_4 = [2, 2, 0, 16];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = derivative([1]);\nlet expected_5 = [];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "xs हे बहुपदीचे गुणांक दर्शवते. \nxs [0] + xs [1] * x + xs [2] * x2 +.... \nया बहुपदीचे व्युत्पन्न त्याच स्वरूपात परत करा. \n>>> व्युत्पन्न ([3,1,2,4,5]) \n[1,4,12,20] \n>>> व्युत्पन्न ([1,2,3]) \n[2,6]", "entry_point": "derivative", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/26", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = fibfib(2);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = fibfib(1);\nlet expected_2 = 0;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = fibfib(5);\nlet expected_3 = 4;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = fibfib(8);\nlet expected_4 = 24;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = fibfib(10);\nlet expected_5 = 81;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = fibfib(12);\nlet expected_6 = 274;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = fibfib(14);\nlet expected_7 = 927;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "फायबफायब क्रमांकाचा क्रम हा फायबॉनॅकी सेकुनेससारखाच एक क्रम आहे ज्याची व्याख्या खालीलप्रमाणे केली आहेः \nफायबफायब (0) = = 0 \nफायबफायब (1) = = 0 \nफायबफायब (2) = = 1 \nफायबफायब (एन) = = फायबफायब (एन-1) + फायबफायब (एन-2) + फायबफायब (एन-3). \nफायबफायब क्रमांकाच्या अनुक्रमाच्या एन-व्या घटकाची कार्यक्षमतेने गणना करण्यासाठी कृपया एक कार्य लिहा. \n>>> फायबफायब (1) \n0. \n>>> फायबफायब (5) \n4. \n>>> फायबफायब (8) \n24.", "entry_point": "fibfib", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/27", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = vowels_count(\"abcde\");\nlet expected_1 = 2;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = vowels_count(\"Alone\");\nlet expected_2 = 3;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = vowels_count(\"key\");\nlet expected_3 = 2;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = vowels_count(\"bye\");\nlet expected_4 = 1;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = vowels_count(\"keY\");\nlet expected_5 = 2;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = vowels_count(\"bYe\");\nlet expected_6 = 1;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = vowels_count(\"ACEDY\");\nlet expected_7 = 3;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "एक स्वर गणना कार्य लिहा जे दर्शविणारी स्ट्रिंग घेते \nइनपुट म्हणून एक शब्द आणि स्ट्रिंगमधील स्वरांची संख्या परत करतो. \nया प्रकरणात स्वर'अ','ई','आय','ओ','यू'आहेत. येथे,'वाय'देखील एक आहे. \nस्वर, परंतु जेव्हा तो दिलेल्या शब्दाच्या शेवटी असतो तेव्हाच. \n\nउदाहरणादाखलः \n>>> स्वरांची गणना (\"ए. बी. सी. डी\".) \n2. \n>>> स्वरांची गणना (\"ACEDY\") \n3.", "entry_point": "vowels_count", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/28", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = search([5, 5, 5, 5, 1]);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = search([4, 1, 4, 1, 4, 4]);\nlet expected_2 = 4;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = search([3, 3]);\nlet expected_3 = -1;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = search([8, 8, 8, 8, 8, 8, 8, 8]);\nlet expected_4 = 8;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = search([2, 3, 3, 2, 2]);\nlet expected_5 = 2;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = search([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]);\nlet expected_6 = 1;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = search([3, 2, 8, 2]);\nlet expected_7 = 2;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]);\nlet expected_8 = 1;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = search([8, 8, 3, 6, 5, 6, 4]);\nlet expected_9 = -1;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = search([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]);\nlet expected_10 = 1;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = search([1, 9, 10, 1, 3]);\nlet expected_11 = 1;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = search([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]);\nlet expected_12 = 5;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = search([1]);\nlet expected_13 = 1;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = search([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]);\nlet expected_14 = 4;\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\nlet actual_15 = search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]);\nlet expected_15 = 2;\nassert.deepEqual(actual_15, expected_15, \"Exception --- test case 14 failed to pass\");\n\nlet actual_16 = search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]);\nlet expected_16 = 1;\nassert.deepEqual(actual_16, expected_16, \"Exception --- test case 15 failed to pass\");\n\nlet actual_17 = search([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]);\nlet expected_17 = 4;\nassert.deepEqual(actual_17, expected_17, \"Exception --- test case 16 failed to pass\");\n\nlet actual_18 = search([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]);\nlet expected_18 = 4;\nassert.deepEqual(actual_18, expected_18, \"Exception --- test case 17 failed to pass\");\n\nlet actual_19 = search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]);\nlet expected_19 = 2;\nassert.deepEqual(actual_19, expected_19, \"Exception --- test case 18 failed to pass\");\n\nlet actual_20 = search([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]);\nlet expected_20 = -1;\nassert.deepEqual(actual_20, expected_20, \"Exception --- test case 19 failed to pass\");\n\nlet actual_21 = search([10]);\nlet expected_21 = -1;\nassert.deepEqual(actual_21, expected_21, \"Exception --- test case 20 failed to pass\");\n\nlet actual_22 = search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]);\nlet expected_22 = 2;\nassert.deepEqual(actual_22, expected_22, \"Exception --- test case 21 failed to pass\");\n\nlet actual_23 = search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]);\nlet expected_23 = 1;\nassert.deepEqual(actual_23, expected_23, \"Exception --- test case 22 failed to pass\");\n\nlet actual_24 = search([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]);\nlet expected_24 = 1;\nassert.deepEqual(actual_24, expected_24, \"Exception --- test case 23 failed to pass\");\n\nlet actual_25 = search([3, 10, 10, 9, 2]);\nlet expected_25 = -1;\nassert.deepEqual(actual_25, expected_25, \"Exception --- test case 24 failed to pass\");\n\n", "language": "typescript", "description": "तुम्हाला सकारात्मक पूर्णांकांची रिकामी नसलेली यादी दिली जाते. त्यापेक्षा मोठा असलेला सर्वात मोठा पूर्णांक परत करा. \nशून्य, आणि त्याची वारंवारता पूर्णांकाच्या मूल्यापेक्षा जास्त किंवा समान असते. \nपूर्णांकाची वारंवारता म्हणजे ती यादीत किती वेळा दिसते. \nअसे कोणतेही मूल्य अस्तित्वात नसल्यास,-1 परत करा. \nउदाहरणेः \nशोध ([4,1,2,2,3,1]) = = 2 \nशोध ([1,2,3,3,4,4]) = = 3 \nशोध ([5,5,4,4]) = =-1", "entry_point": "search", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/29", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = triangle_area(3,4,5);\nlet expected_1 = 6.0;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = triangle_area(1,2,10);\nlet expected_2 = -1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = triangle_area(4,8,5);\nlet expected_3 = 8.18;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = triangle_area(2,2,2);\nlet expected_4 = 1.73;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = triangle_area(1,2,3);\nlet expected_5 = -1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = triangle_area(10,5,7);\nlet expected_6 = 16.25;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = triangle_area(2,6,3);\nlet expected_7 = -1;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = triangle_area(1,1,1);\nlet expected_8 = 0.43;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = triangle_area(2,2,10);\nlet expected_9 = -1;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "त्रिकोणाच्या तीन बाजूंची लांबी दिलेली. त्याचे क्षेत्रफळ परत करा \nजर तीन बाजूंनी वैध त्रिकोण तयार झाला तर त्रिकोण 2 दशांश बिंदूंवर गोल केला जातो. \nअन्यथा परतावा-1 \nजेव्हा कोणत्याही दोन बाजूंची बेरीज जास्त असते तेव्हा तीन बाजू वैध त्रिकोण बनवतात. \nतिसऱ्या बाजूला. \nउदाहरणादाखलः \nत्रिभुज क्षेत्र (3,4,5) = = 6.00 \nत्रिभुज क्षेत्र (1,2,10) = =-1", "entry_point": "triangle_area", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/30", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = will_it_fly([3, 2, 3],9);\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = will_it_fly([1, 2],5);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = will_it_fly([3],5);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = will_it_fly([3, 2, 3],1);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = will_it_fly([1, 2, 3],6);\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = will_it_fly([5],5);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "एखादे कार्य लिहा जे q वस्तू उडत असेल तर खरे आणि अन्यथा खोटे परत करेल. \nजर वस्तू क्यू संतुलित असेल (ती एक पॅलिन्ड्रोमिक यादी आहे) आणि त्याच्या घटकांची बेरीज जास्तीत जास्त संभाव्य वजन डब्ल्यू पेक्षा कमी किंवा समान असेल तर ती उडेल. \n\nउदाहरणादाखलः \nतो उडणार का ([1,2], 5) \n#1 + 2 हे जास्तीत जास्त संभाव्य वजनापेक्षा कमी आहे, परंतु ते असंतुलित आहे. \n\nतो उडणार का ([3,2,3], 1) खोटे \n#हे संतुलित आहे, परंतु 3 + 2 + 3 हे जास्तीत जास्त संभाव्य वजनापेक्षा जास्त आहे. \n\nविल इट फ्लाय ([3,2,3], 9) \n#3 + 2 + 3 हे जास्तीत जास्त संभाव्य वजनापेक्षा कमी आहे आणि ते संतुलित आहे. \n\nविल इट फ्लाय ([3], 5) ट्रू \n#3 हे जास्तीत जास्त संभाव्य वजनापेक्षा कमी आहे आणि ते संतुलित आहे.", "entry_point": "will_it_fly", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/31", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_multiply_prime(5);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_multiply_prime(30);\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_multiply_prime(8);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_multiply_prime(10);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_multiply_prime(125);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_multiply_prime(105);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_multiply_prime(126);\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = is_multiply_prime(729);\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = is_multiply_prime(891);\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = is_multiply_prime(1001);\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "जर दिलेली संख्या 3 अभाज्य संख्यांचा गुणाकार असेल तर असे कार्य लिहा जे खरे ठरेल. \nआणि अन्यथा खोटे. \n(अ) हे 100 पेक्षा कमी आहे हे जाणून घेणे. \nउदाहरणादाखलः \nगुणाकार _ प्राइम (30) = = खरे आहे \n30 = 2 * 3 * 5", "entry_point": "is_multiply_prime", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/32", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = decimal_to_binary(0);\nlet expected_1 = \"db0db\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = decimal_to_binary(32);\nlet expected_2 = \"db100000db\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = decimal_to_binary(103);\nlet expected_3 = \"db1100111db\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = decimal_to_binary(15);\nlet expected_4 = \"db1111db\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "तुम्हाला दशांश स्वरूपात एक संख्या दिली जाईल आणि तुमचे काम त्याचे रूपांतर करणे आहे. \nद्वैती स्वरूप. कार्याने एक स्ट्रिंग परत करावी, ज्यामध्ये प्रत्येक वर्ण द्वैती दर्शवितो \nसंख्या. स्ट्रिंगमधील प्रत्येक अक्षर'0'किंवा'1'असेल. \n\nस्ट्रिंगच्या सुरुवातीला आणि शेवटी'डी. बी.'अशी दोन अतिरिक्त अक्षरे असतील. \nस्वरूपामध्ये मदत करण्यासाठी अतिरिक्त अक्षरे आहेत. \n\nउदाहरणेः \nदशांश _ ते _ द्वैती (15) #\"db1111db\" परत करते \nदशांश _ ते _ द्वैती (32) #\"db100000db\" परत करते", "entry_point": "decimal_to_binary", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/33", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_happy(\"a\");\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_happy(\"aa\");\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_happy(\"abcd\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_happy(\"aabb\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_happy(\"adb\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_happy(\"xyy\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_happy(\"iopaxpoi\");\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = is_happy(\"iopaxioi\");\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "तुम्हाला एक स्ट्रिंग s दिली जाते. \nस्ट्रिंग आनंदी आहे की नाही हे तपासणे हे तुमचे काम आहे. \nजर स्ट्रिंगची लांबी किमान 3 असेल आणि प्रत्येक 3 सलग अक्षरे वेगळी असतील तर ती आनंदी असते. \nउदाहरणार्थ, \nआनंदी (अ) => खोटे आहे \nआहे _ आनंदी (एए) => खोटे \nआनंदी आहे (ए. बी. सी. डी.) => खरे \nआनंदी आहे (आब्ब) => खोटे \nआनंदी आहे (ADB) => खरे \nआनंदी आहे (xyy) => खोटे", "entry_point": "is_happy", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/34", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = numerical_letter_grade([4.0, 3, 1.7, 2, 3.5]);\nlet expected_1 = [\"A+\", \"B\", \"C-\", \"C\", \"A-\"];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = numerical_letter_grade([1.2]);\nlet expected_2 = [\"D+\"];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = numerical_letter_grade([0.5]);\nlet expected_3 = [\"D-\"];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = numerical_letter_grade([0.0]);\nlet expected_4 = [\"E\"];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = numerical_letter_grade([1, 0.3, 1.5, 2.8, 3.3]);\nlet expected_5 = [\"D\", \"D-\", \"C-\", \"B\", \"B+\"];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = numerical_letter_grade([0, 0.7]);\nlet expected_6 = [\"E\", \"D-\"];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "हा सत्राचा शेवटचा आठवडा असतो आणि शिक्षकांना गुण द्यावे लागतात. \nविद्यार्थ्यांना. शिक्षक ग्रेडिंगसाठी स्वतःचे अल्गोरिदम तयार करत आहेत. \nफक्त एकच अडचण आहे की, तिने ग्रेडिंगसाठी वापरलेला कोड गमावला आहे. \nतिने तुम्हाला काही विद्यार्थ्यांसाठी जी. पी. ए. ची यादी दिली आहे आणि तुम्हाला लिहावे लागेल. \nएक कार्य जे खालील तक्ता वापरून अक्षर श्रेणीची यादी तयार करू शकतेः \nजी. पी. ए.। अक्षर श्रेणी \n4. 0 अ + \n> 3.7 अ \n> 3.3 अ-\n> 3 बी + \n> 2.7 बी \n> 2.3 ब-\n> 2 सी + \n> 1.7 से. \n> 1.3 सी-\n> 1 डी + \n> 0.7 डी \n> 0.00 डी-\n0. 0 ई \n\nउदाहरणादाखलः \nश्रेणी समीकरण ([4.0,3,1.7,2,3.5]) = => ['ए +','बी','सी-','सी','ए -']", "entry_point": "numerical_letter_grade", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/35", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = prime_length(\"Hello\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = prime_length(\"abcdcba\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = prime_length(\"kittens\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = prime_length(\"orange\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = prime_length(\"wow\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = prime_length(\"world\");\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = prime_length(\"MadaM\");\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = prime_length(\"Wow\");\nlet expected_8 = true;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = prime_length(\"\");\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = prime_length(\"HI\");\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = prime_length(\"go\");\nlet expected_11 = true;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = prime_length(\"gogo\");\nlet expected_12 = false;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = prime_length(\"aaaaaaaaaaaaaaa\");\nlet expected_13 = false;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = prime_length(\"Madam\");\nlet expected_14 = true;\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\nlet actual_15 = prime_length(\"M\");\nlet expected_15 = false;\nassert.deepEqual(actual_15, expected_15, \"Exception --- test case 14 failed to pass\");\n\nlet actual_16 = prime_length(\"0\");\nlet expected_16 = false;\nassert.deepEqual(actual_16, expected_16, \"Exception --- test case 15 failed to pass\");\n\n", "language": "typescript", "description": "एक कार्य लिहा जे स्ट्रिंग घेते आणि स्ट्रिंग असल्यास खरे परत करते \nलांबी ही अभाज्य संख्या आहे किंवा अन्यथा चुकीची आहे \nउदाहरणे \nप्राइम लांबी ('हॅलो') = = खरे \nप्राइम लांबी ('एबीसीडीसीबीए') = = खरे \nप्राइम लांबी ('मांजरीचे पिल्लू') = = खरे \nअविभाज्य लांबी ('नारिंगी') = = चुकीची", "entry_point": "prime_length", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/36", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = solve(1000);\nlet expected_1 = \"1\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = solve(150);\nlet expected_2 = \"110\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = solve(147);\nlet expected_3 = \"1100\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = solve(333);\nlet expected_4 = \"1001\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = solve(963);\nlet expected_5 = \"10010\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "एक सकारात्मक पूर्णांक N दिल्यास, त्याच्या अंकांची एकूण बेरीज बायनरीमध्ये परत करा. \n\nउदाहरणादाखल \nएन = 1000 साठी, अंकांची बेरीज 1 असेल तर उत्पादन \"1\" असावे. \nएन = 150 साठी, अंकांची बेरीज 6 असेल आणि उत्पादन \"110\" असावे. \nएन = 147 साठी, अंकांची बेरीज 12 असेल तर उत्पादन \"1100\" असावे. \n\nपरिवर्तनशीलः \n@N पूर्णांक \nनिर्बंधः 0 ≤ एन ≤ 10000. \nउत्पादनः \nद्वैती क्रमांकाची एक स्ट्रिंग", "entry_point": "solve", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/37", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],1);\nlet expected_1 = [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],2);\nlet expected_2 = [[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],1);\nlet expected_3 = [[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = get_row([],1);\nlet expected_4 = [];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = get_row([[1]],2);\nlet expected_5 = [];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = get_row([[], [1], [1, 2, 3]],3);\nlet expected_6 = [[2, 2]];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "तुम्हाला नेस्टेड यादी म्हणून द्विमितीय माहिती दिली जाते, \nजे मॅट्रिक्ससारखेच आहे, तथापि, मॅट्रिक्सच्या विपरीत, \nप्रत्येक ओळीत वेगवेगळ्या स्तंभांची संख्या असू शकते. \nदिलेल्या lst आणि पूर्णांक x मध्ये, यादीतील पूर्णांक x शोधा, \nआणि टुपल्सची परत यादी, [(x1, y1), (x2, y2)...] अशी की \nप्रत्येक टुपल हा एक निर्देशांक आहे-(पंक्ती, स्तंभ), जो 0 ने सुरू होतो. \nनिर्देशांक सुरुवातीला चढत्या क्रमाने ओळींनुसार क्रमवारी लावा. \nतसेच, पंक्तीचे निर्देशांक स्तंभांनुसार उतरत्या क्रमाने क्रमवारीत करा. \n\nउदाहरणेः \nपंक्ती मिळवा (_ r) ([\n[1,2,3, 4,5,6], \n[1,2,3, 4,1,6], \n[1,2,3, 4,5,1] \n], 1) = = [(0,0), (1,4), (1,0), (2,5), (2,0)] \nमिळवा _ पंक्ती ([], 1) = = [] \nमिळवा _ पंक्ती ([[], [1], [1,2,3]], 3) = = [(2,2)]", "entry_point": "get_row", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/38", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = next_smallest([1, 2, 3, 4, 5]);\nlet expected_1 = 2;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = next_smallest([5, 1, 4, 3, 2]);\nlet expected_2 = 2;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = next_smallest([]);\nlet expected_3 = undefined;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = next_smallest([1, 1]);\nlet expected_4 = undefined;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = next_smallest([1, 1, 1, 1, 0]);\nlet expected_5 = 1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = next_smallest([1, 1]);\nlet expected_6 = undefined;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = next_smallest([-35, 34, 12, -45]);\nlet expected_7 = -35;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "तुम्हाला पूर्णांकांची यादी दिली जाते. \nयादीतील दुसरा सर्वात लहान घटक परत करणारे पुढील _ सर्वात लहान () हे कार्य लिहा. \nअसा कोणताही घटक नसल्यास शून्य परत करा. \n\nपुढील _ सर्वात लहान ([1,2,3,4,5]) = = 2 \nपुढील _ सर्वात लहान ([5,1,4,3,2]) = = 2 \nपुढील _ सर्वात लहान ([]) = = काहीही नाही \nपुढील _ सर्वात लहान ([1,1]) = = काहीही नाही", "entry_point": "next_smallest", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/39", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_bored(\"Hello world\");\nlet expected_1 = 0;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_bored(\"Is the sky blue?\");\nlet expected_2 = 0;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_bored(\"I love It !\");\nlet expected_3 = 1;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_bored(\"bIt\");\nlet expected_4 = 0;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_bored(\"I feel good today. I will be productive. will kill It\");\nlet expected_5 = 2;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_bored(\"You and I are going for a walk\");\nlet expected_6 = 0;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "तुम्हाला शब्दांची एक मालिका दिली जाईल आणि तुमचे काम संख्या मोजणे आहे. \nकंटाळवाणेपणा. कंटाळवाणेपणा हे \"मी\" या शब्दाने सुरू होणारे वाक्य आहे. \nवाक्ये '.', '?'किंवा '!'द्वारे सीमांकित केली जातात. \n\nउदाहरणार्थ, \n>>> कंटाळले आहे (\"हॅलो वर्ल्ड\") \n0. \n>>> कंटाळले आहे (\"आकाश निळे आहे. सूर्य चमकतो आहे. मला हे हवामान आवडते\") \n1.", "entry_point": "is_bored", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/40", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]);\nlet expected_1 = 10;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]);\nlet expected_2 = 25;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\nlet expected_3 = 13;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]);\nlet expected_4 = 11;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = skjkasdkd([0, 81, 12, 3, 1, 21]);\nlet expected_5 = 3;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = skjkasdkd([0, 8, 1, 2, 1, 7]);\nlet expected_6 = 7;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = skjkasdkd([8191]);\nlet expected_7 = 19;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = skjkasdkd([8191, 123456, 127, 7]);\nlet expected_8 = 19;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = skjkasdkd([127, 97, 8192]);\nlet expected_9 = 10;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "तुम्हाला पूर्णांकांची यादी दिली जाते. \nतुम्हाला सर्वात मोठे मूळ मूल्य शोधावे लागेल आणि त्याच्या अंकांची बेरीज परत करावी लागेल. \n\nउदाहरणेः \nlst = [0,3,2, 1,3,5, 7,4,5, 5,5,2, 181,32,4, 32,3,2, 32,324,4, 3] साठी आउटपुट 10 असावे. \nlst = [1,0,1, 8,2,4597, 2,1,3, 40,1,2, 1,2,4, 2,5,1] साठी आउटपुट 25 असावे. \nlst = [1,3,1, 32,5107,34, 83278,109,163, 23,2323,32, 30,1,9, 3] साठी आउटपुट 13 असावे. \nlst = [0,724,32, 71,99,32, 6,0,5, 91,83,0, 5,6] साठी आउटपुट 11 असावे. \nlst = [0,81,12, 3,1,21] साठी आउटपुट 3 असावे. \nlst = [0,8,1, 2,1,7] साठी आउटपुट 7 असावे.", "entry_point": "skjkasdkd", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/41", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = check_dict_case(new Map<any, any>([[\"p\", \"pineapple\"], [\"b\", \"banana\"]]));\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = check_dict_case(new Map<any, any>([[\"p\", \"pineapple\"], [\"A\", \"banana\"], [\"B\", \"banana\"]]));\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = check_dict_case(new Map<any, any>([[\"p\", \"pineapple\"], [5, \"banana\"], [\"a\", \"apple\"]]));\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = check_dict_case(new Map<any, any>([[\"Name\", \"John\"], [\"Age\", \"36\"], [\"City\", \"Houston\"]]));\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = check_dict_case(new Map<any, any>([[\"STATE\", \"NC\"], [\"ZIP\", \"12345\"]]));\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = check_dict_case(new Map<any, any>([[\"fruit\", \"Orange\"], [\"taste\", \"Sweet\"]]));\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = check_dict_case(new Map<any, any>([]));\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "शब्दकोश दिल्यास, जर सर्व किल्ली खालच्या भागात स्ट्रिंग असतील तर खरे परत करा \nकेस किंवा सर्व किल्ली मोठ्या केस मध्ये स्ट्रिंग आहेत, अन्यथा खोटे परत करा. \n'फॉल्स'हे फंक्शन रिटर्न करावे म्हणजे दिलेला शब्दकोश रिकामा आहे. \nउदाहरणेः \nचेक _ डिक्ट _ केस ({\"a\": \"सफरचंद\", \"b\": \"केळी\"}) ने खरे परतावे. \nचेक _ डिक्ट _ केस ({\"a\": \"सफरचंद\", \"A\": \"केळी\", \"B\": \"केळी\"}) ने चुकीचे परतावे. \nचेक _ डिक्ट _ केस ({\"a\": \"सफरचंद\", 8: \"केळी\", \"a\": \"सफरचंद\"}) ने चुकीचे परतावे. \nचेक _ डिक्ट _ केस ({\"नाव\": \"जॉन\", \"वय\": \"36\", \"शहर\": \"ह्यूस्टन\"}) ने फॉल्स परत केले पाहिजे. \nचेक _ डिक्ट _ केस ({\"STATE\": \"NC\", \"ZIP\": \"12345\"}) ने खरे परतावे.", "entry_point": "check_dict_case", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/42", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = closest_integer(\"10\");\nlet expected_1 = 10;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = closest_integer(\"14.5\");\nlet expected_2 = 15;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = closest_integer(\"-15.5\");\nlet expected_3 = -16;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = closest_integer(\"15.3\");\nlet expected_4 = 15;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = closest_integer(\"0\");\nlet expected_5 = 0;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "संख्येचे प्रतिनिधित्व करणारे मूल्य (स्ट्रिंग) घेणारे कार्य तयार करा \nआणि त्याला सर्वात जवळचा पूर्णांक परत करतो. जर संख्या समदूर असेल तर \nदोन पूर्णांकांपासून, शून्यापासून दूर गोल करा. \n\nउदाहरणे \n>>> सर्वात जवळचा पूर्णांक (\"10\") \n10. \n>>> सर्वात जवळचा पूर्णांक (\"15.3\") \n15. \n\nटीपः \nशून्यापासून दूर पूर्णांक करणे म्हणजे जर दिलेली संख्या समदूर असेल तर \nदोन पूर्णांकांमधून, तुम्ही ज्याला परत केले पाहिजे ते आहे \nशून्यापासून सर्वात दूर. उदाहरणार्थ सर्वात जवळचा पूर्णांक (\"14.5\") असायला हवा. \n15 परत करा आणि सर्वात जवळचा पूर्णांक (\"-14.5\")-15 परत करावा.", "entry_point": "closest_integer", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/43", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = make_a_pile(3);\nlet expected_1 = [3, 5, 7];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = make_a_pile(4);\nlet expected_2 = [4, 6, 8, 10];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = make_a_pile(5);\nlet expected_3 = [5, 7, 9, 11, 13];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = make_a_pile(6);\nlet expected_4 = [6, 8, 10, 12, 14, 16];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = make_a_pile(8);\nlet expected_5 = [8, 10, 12, 14, 16, 18, 20, 22];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "एक सकारात्मक पूर्णांक n दिल्यास, तुम्हाला दगडांच्या n स्तरांचा ढीग तयार करावा लागेल. \nपहिल्या स्तरावर एन दगड आहेत. \nपुढील स्तरावरील दगडांची संख्या अशी आहेः \n- n विषम असल्यास पुढील विषम संख्या. \n- जर n सम असेल तर पुढील सम संख्या. \nसूचीतील प्रत्येक स्तरावरील दगडांची संख्या परत करा, जेथे घटक निर्देशांकात आहे. \ni पातळीवरील दगडांची संख्या दर्शविते (i + 1). \n\nउदाहरणेः \n>>> _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[3,5,7]", "entry_point": "make_a_pile", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/44", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = words_string(\"Hi, my name is John\");\nlet expected_1 = [\"Hi\", \"my\", \"name\", \"is\", \"John\"];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = words_string(\"One, two, three, four, five, six\");\nlet expected_2 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = words_string(\"Hi, my name\");\nlet expected_3 = [\"Hi\", \"my\", \"name\"];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = words_string(\"One,, two, three, four, five, six,\");\nlet expected_4 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = words_string(\"\");\nlet expected_5 = [];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = words_string(\"ahmed     , gamal\");\nlet expected_6 = [\"ahmed\", \"gamal\"];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "तुम्हाला अल्पविराम किंवा मोकळ्या जागांनी विभक्त केलेल्या शब्दांची एक स्ट्रिंग दिली जाईल. तुमचे कार्य आहे \nस्ट्रिंगचे शब्दांमध्ये विभाजन करणे आणि शब्दांची एक श्रेणी परत करणे. \n\nउदाहरणार्थ, \nशब्द _ स्ट्रिंग (\"हाय, माझे नाव जॉन आहे\") = = [\"हाय\", \"माझे\", \"नाव\", \"आहे\", \"जॉन\"] \nशब्द _ स्ट्रिंग (\"एक, दोन, तीन, चार, पाच, सहा\") = = [\"एक\", \"दोन\", \"तीन\", \"चार\", \"पाच\", \"सहा\"]", "entry_point": "words_string", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/45", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = choose_num(12,15);\nlet expected_1 = 14;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = choose_num(13,12);\nlet expected_2 = -1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = choose_num(33,12354);\nlet expected_3 = 12354;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = choose_num(5234,5233);\nlet expected_4 = -1;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = choose_num(6,29);\nlet expected_5 = 28;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = choose_num(27,10);\nlet expected_6 = -1;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = choose_num(7,7);\nlet expected_7 = -1;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = choose_num(546,546);\nlet expected_8 = 546;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "हे कार्य x आणि y या दोन सकारात्मक संख्या घेते आणि परत करते \n[x, y] सर्वसमावेशक श्रेणीतील सर्वात मोठी सम पूर्णांक संख्या. \nअशी कोणतीही संख्या नाही, तर कार्य-1 परत आले पाहिजे. \n\nउदाहरणार्थ, \nसंख्या निवडा (12,15) = 14 \nसंख्या निवडा (13,12) =-1", "entry_point": "choose_num", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/46", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = rounded_avg(1,5);\nlet expected_1 = \"0b11\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = rounded_avg(7,13);\nlet expected_2 = \"0b1010\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = rounded_avg(964,977);\nlet expected_3 = \"0b1111001010\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = rounded_avg(996,997);\nlet expected_4 = \"0b1111100100\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = rounded_avg(560,851);\nlet expected_5 = \"0b1011000010\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = rounded_avg(185,546);\nlet expected_6 = \"0b101101110\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = rounded_avg(362,496);\nlet expected_7 = \"0b110101101\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = rounded_avg(350,902);\nlet expected_8 = \"0b1001110010\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = rounded_avg(197,233);\nlet expected_9 = \"0b11010111\";\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = rounded_avg(7,5);\nlet expected_10 = -1;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = rounded_avg(5,1);\nlet expected_11 = -1;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = rounded_avg(5,5);\nlet expected_12 = \"0b101\";\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\n", "language": "typescript", "description": "तुम्हाला दोन सकारात्मक पूर्णांक n आणि m दिले आहेत आणि तुमचे कार्य गणना करणे आहे \nn ते m पर्यंतच्या पूर्णांकांची सरासरी (n आणि m सह). \nसर्वात जवळच्या पूर्णांकाच्या उत्तराला गोल करा आणि त्याचे बायनरीमध्ये रूपांतर करा. \nजर n हा m पेक्षा मोठा असेल तर-1 परत करा. \nउदाहरणादाखलः \nगोलाकार _ ए. व्ही. जी. (1,5) => \"0बी11\" \nगोलाकार _ ए. व्ही. जी. (7,5) =>-1 \nगोलाकार _ ए. व्ही. जी. (10,20) => \"0बी1111\" \nगोलाकार _ ए. व्ही. जी. (20,33) => \"0b11010\"", "entry_point": "rounded_avg", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/47", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = f(5);\nlet expected_1 = [1, 2, 6, 24, 15];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = f(7);\nlet expected_2 = [1, 2, 6, 24, 15, 720, 28];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = f(1);\nlet expected_3 = [1];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = f(3);\nlet expected_4 = [1, 2, 6];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "फंक्शन f ची अंमलबजावणी करा जे n ला पॅरामीटर म्हणून घेते, \nआणि आकार n ची यादी अशा प्रकारे परत करते, की जर i सम असेल तर निर्देशांक i वरील घटकाचे मूल्य हे i चे फॅक्टोरियल असेल. \nकिंवा अन्यथा 1 ते i पर्यंतच्या संख्यांची बेरीज. \nमी 1 पासून सुरुवात करतो. \ni चा फॅक्टोरियल म्हणजे 1 ते i (1 * 2 *... * i) पर्यंतच्या संख्यांचा गुणाकार. \nउदाहरणादाखलः \nf (5) = = [1,2,6,24,15]", "entry_point": "f", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/48", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = even_odd_palindrome(123);\nlet expected_1 = [8, 13];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = even_odd_palindrome(12);\nlet expected_2 = [4, 6];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = even_odd_palindrome(3);\nlet expected_3 = [1, 2];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = even_odd_palindrome(63);\nlet expected_4 = [6, 8];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = even_odd_palindrome(25);\nlet expected_5 = [5, 6];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = even_odd_palindrome(19);\nlet expected_6 = [4, 6];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = even_odd_palindrome(9);\nlet expected_7 = [4, 5];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = even_odd_palindrome(1);\nlet expected_8 = [0, 1];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "एक सकारात्मक पूर्णांक n दिल्यास, सम आणि विषम संख्या असलेले टुपल परत करा \nपूर्णांक पॅलिंड्रोम्स जे (1, एन) श्रेणीत येतात, सर्वसमावेशक. \n\nउदाहरण 1: \n\nइनपुटः 3 \nउत्पादनः (1,2) \nस्पष्टीकरणः \nपूर्णांक पॅलिंड्रोम 1,2,3 आहेत. त्यापैकी एक सम आहे आणि त्यापैकी दोन विषम आहेत. \n\nउदाहरण 2: \n\nइनपुटः 12 \nउत्पादनः (4,6) \nस्पष्टीकरणः \n1, 2, 3, 4, 5, 6, 7, 8, 9, 11 हे पूर्णांक पॅलिंड्रोम आहेत. त्यापैकी चार सम आहेत आणि त्यापैकी 6 विषम आहेत. \n\nटीपः \n1. 1 <= n <= 10 ^ 3 \n2. परत आलेल्या टुपलमध्ये अनुक्रमे सम आणि विषम पूर्णांक पॅलिंड्रोम्सची संख्या असते.", "entry_point": "even_odd_palindrome", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/49", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = move_one_ball([3, 4, 5, 1, 2]);\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = move_one_ball([3, 5, 10, 1, 2]);\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = move_one_ball([4, 3, 1, 2]);\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = move_one_ball([3, 5, 4, 1, 2]);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = move_one_ball([]);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "आमच्याकडे'arr'हा N पूर्णांक arr [1], arr [2],..., arr [N] चा अॅरे आहे. \nरचनेतील संख्या यादृच्छिकपणे क्रमबद्ध केल्या जातील. हे ठरवणे हे तुमचे काम आहे \nसादरीकरण करून कमी न होणाऱ्या क्रमाने अॅरेची क्रमवारी लावणे शक्य आहे. \nदिलेल्या अॅरेवर खालील ऑपरेशनः \nतुम्हाला कितीही वेळा योग्य शिफ्ट ऑपरेशन करण्याची परवानगी आहे. \n\nवन राईट शिफ्ट ऑपरेशन म्हणजे अॅरेच्या सर्व घटकांना एकाने हलवणे. \nयोग्य दिशेने स्थान. आरेचा शेवटचा घटक येथे हलविला जाईल \nअॅरेमधील प्रारंभिक स्थान म्हणजे 0 व्या निर्देशांकात. \n\nवरील ऑपरेशन करून क्रमवारी लावलेली अॅरे मिळवणे शक्य असल्यास \nनंतर'खरे'परत करा अन्यथा'खोटे'परत करा. \nजर दिलेला अॅरे रिकामा असेल तर खरे परत करा. \n\nटीपः दिलेल्या यादीमध्ये अद्वितीय घटक असण्याची हमी आहे. \n\nउदाहरणादाखलः \n\nमूव्ह वन बॉल ([3,4,5,1,2]) = => खरे \nस्पष्टीकरणः 2 योग्य शिफ्ट ऑपरेशन्समध्ये कामगिरी करून, नॉन-डीक्रीझिंग ऑर्डर करू शकते \nदिलेल्या अॅरेसाठी साध्य केले जाईल. \nमूव्ह वन बॉल ([3,5,4,1,2]) = => खोटे \nस्पष्टीकरणः दिलेल्या मागणीसाठी कमी न होणारी ऑर्डर मिळवणे शक्य नाही. \nकोणत्याही संख्येने योग्य शिफ्ट ऑपरेशन्स करून अॅरे.", "entry_point": "move_one_ball", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/50", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = exchange([1, 2, 3, 4],[1, 2, 3, 4]);\nlet expected_1 = \"YES\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = exchange([1, 2, 3, 4],[1, 5, 3, 4]);\nlet expected_2 = \"NO\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = exchange([1, 2, 3, 4],[2, 1, 4, 3]);\nlet expected_3 = \"YES\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = exchange([5, 7, 3],[2, 6, 4]);\nlet expected_4 = \"YES\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = exchange([5, 7, 3],[2, 6, 3]);\nlet expected_5 = \"NO\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = exchange([3, 2, 6, 1, 8, 9],[3, 5, 5, 1, 1, 1]);\nlet expected_6 = \"NO\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = exchange([100, 200],[200, 200]);\nlet expected_7 = \"YES\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "या समस्येमध्ये, तुम्ही एक कार्य अंमलात आणाल जे संख्यांच्या दोन याद्या घेते, \nआणि घटकांची देवाणघेवाण करणे शक्य आहे की नाही हे ठरवते \nत्यांच्या दरम्यान lst1 ही केवळ समसंख्यांची यादी बनवणे. \nlst1 आणि lst2 दरम्यान अदलाबदल झालेल्या घटकांच्या संख्येवर कोणतीही मर्यादा नाही. \nएल. एस. टी. 1 आणि एल. एस. टी. 2 दरम्यान घटकांची देवाणघेवाण करणे शक्य असल्यास \nlst1 चे सर्व घटक सम होण्यासाठी,'होय'परत करा. \nअन्यथा,'नाही'परत करा. \nउदाहरणार्थ, \nविनिमय ([1,2,3,4], [1,2,3,4]) => \"होय\" \nविनिमय ([1,2,3,4], [1,5,3,4]) => \"नाही\" \nइनपुट याद्या रिकाम्या नसतील असे गृहित धरले जाते.", "entry_point": "exchange", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/51", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = reverse_delete(\"abcde\",\"ae\");\nlet expected_1 = [\"bcd\", false];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = reverse_delete(\"abcdef\",\"b\");\nlet expected_2 = [\"acdef\", false];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = reverse_delete(\"abcdedcba\",\"ab\");\nlet expected_3 = [\"cdedc\", true];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = reverse_delete(\"dwik\",\"w\");\nlet expected_4 = [\"dik\", false];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = reverse_delete(\"a\",\"a\");\nlet expected_5 = [\"\", true];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = reverse_delete(\"abcdedcba\",\"\");\nlet expected_6 = [\"abcdedcba\", true];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = reverse_delete(\"abcdedcba\",\"v\");\nlet expected_7 = [\"abcdedcba\", true];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = reverse_delete(\"vabba\",\"v\");\nlet expected_8 = [\"abba\", true];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = reverse_delete(\"mamma\",\"mia\");\nlet expected_9 = [\"\", true];\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "कार्य. \nआम्हाला दोन स्ट्रिंग s आणि c दिल्या आहेत, तुम्हाला s मधील सर्व अक्षरे हटवावी लागतील जी c मधील कोणत्याही अक्षराच्या बरोबरीची आहेत. \nत्यानंतर निकाल स्ट्रिंग पॅलिंड्रोम आहे का ते तपासा. \nजर ती पुढे वाचते तशीच मागे वाचली तर त्याला पॅलिंड्रोम म्हणतात. \nतुम्ही चेकसाठी निकालाची स्ट्रिंग आणि खरे/खोटे असलेले टुपल परत केले पाहिजे. \nउदाहरणादाखल \nएस = \"एबीसीडी\", सी = \"एई\" साठी, परिणाम ('बीसीडी', खोटा) असावा. \nएस = \"ए. बी. सी. डी. एफ\". साठी, सी = \"बी\" परिणाम असावा ('ए. सी. डी. एफ.', खोटे) \nएस = \"ए. बी. सी. डी. सी. बी. ए\"., सी = \"ए. बी\". साठी, परिणाम ('सी. डी. डी. सी.', खरे) असावा.", "entry_point": "reverse_delete", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/52", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],1);\nlet expected_1 = 6;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],2);\nlet expected_2 = 5;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = max_fill([[0, 0, 0], [0, 0, 0]],5);\nlet expected_3 = 0;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = max_fill([[1, 1, 1, 1], [1, 1, 1, 1]],2);\nlet expected_4 = 4;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = max_fill([[1, 1, 1, 1], [1, 1, 1, 1]],9);\nlet expected_5 = 2;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "तुम्हाला विहिरींचे आयताकृती जाळे दिले जाते. प्रत्येक ओळ एकाच विहिरीचे प्रतिनिधित्व करते. \nआणि एका पंक्तीतील प्रत्येक 1 हे पाण्याचे एकच एकक दर्शवते. \nप्रत्येक विहिरीत एक संबंधित बादली असते जी त्यातून पाणी काढण्यासाठी वापरली जाऊ शकते. \nआणि सर्व बादल्या समान क्षमतेच्या असतात. \nविहिरी रिकाम्या करण्यासाठी बादल्या वापरणे हे तुमचे काम आहे. \nतुम्हाला किती वेळा बादल्या कमी करायच्या आहेत ते सांगा. \n\nउदाहरण 1: \nइनपुटः \nग्रीडः [[0, 0,1,0], [0,1,0, 0], [1,1,1, 1]] \nबकेट क्षमता (_ c): 1 \nउत्पादनः 6 \n\nउदाहरण 2: \nइनपुटः \nग्रीडः [[0,0,1, 1], [0,0,0, 0], [1,1,1, 1], [0, 1,1,1]] \nबकेट क्षमता (_ c): 2 \nउत्पादनः 5 \n\nउदाहरण 3: \nइनपुटः \nग्रीडः [0,0,0], [0,0,0] \nबकेट क्षमता (_ c): 5 \nउत्पादनः 0 \n\nनिर्बंधः \n* सर्व विहिरींची लांबी समान असते. \n* 1 <= grid.length <= 10 ^ 2 \n* 1 <= ग्रिड [:, 1]. लांबी <= 10 ^ 2 \nग्रिड [i] [j]-> 0। 1 \n* 1 <= क्षमता <= 10", "entry_point": "max_fill", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/53", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = select_words(\"Mary had a little lamb\",4);\nlet expected_1 = [\"little\"];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = select_words(\"Mary had a little lamb\",3);\nlet expected_2 = [\"Mary\", \"lamb\"];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = select_words(\"simple white space\",2);\nlet expected_3 = [];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = select_words(\"Hello world\",4);\nlet expected_4 = [\"world\"];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = select_words(\"Uncle sam\",3);\nlet expected_5 = [\"Uncle\"];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = select_words(\"\",4);\nlet expected_6 = [];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = select_words(\"a b c d e f\",1);\nlet expected_7 = [\"b\", \"c\", \"d\", \"f\"];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "स्ट्रिंग s आणि नैसर्गिक संख्या n दिल्यास, तुम्हाला अंमलबजावणी करण्याचे काम सोपवण्यात आले आहे. \nएक कार्य जे स्ट्रिंग s मधील सर्व शब्दांची यादी परत करते ज्यामध्ये अचूकपणे समाविष्ट आहे \nn व्यंजन, क्रमाने हे शब्द स्ट्रिंग s मध्ये दिसतात. \nजर स्ट्रिंग s रिकामी असेल तर फंक्शनने रिकामी यादी परत करावी. \nटीपः तुम्ही असे गृहीत धरू शकता की इनपुट स्ट्रिंगमध्ये फक्त अक्षरे आणि जागा आहेत. \nउदाहरणेः \nशब्द निवडा (\"मेरीला एक लहान कोकरा होता\", 4) = => [\"लहान\"] \nशब्द निवडा (\"मेरीला एक लहान कोकरा होता\", 3) = => [\"मेरी\", \"कोकरा\"] \nनिवडा शब्द (\"साधी पांढरी जागा\", 2) = => [] \nनिवडा शब्द (\"हॅलो वर्ल्ड\", 4) = => [\"वर्ल्ड\"] \nशब्द निवडा (\"अंकल सॅम\", 3) = => [\"अंकल\"]", "entry_point": "select_words", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/54", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = maximum([-3, -4, 5],3);\nlet expected_1 = [-4, -3, 5];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = maximum([4, -4, 4],2);\nlet expected_2 = [4, 4];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = maximum([-3, 2, 1, 2, -1, -2, 1],1);\nlet expected_3 = [2];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = maximum([123, -123, 20, 0, 1, 2, -3],3);\nlet expected_4 = [2, 20, 123];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = maximum([-123, 20, 0, 1, 2, -3],4);\nlet expected_5 = [0, 1, 2, 20];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = maximum([5, 15, 0, 3, -13, -8, 0],7);\nlet expected_6 = [-13, -8, 0, 0, 3, 5, 15];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = maximum([-1, 0, 2, 5, 3, -10],2);\nlet expected_7 = [3, 5];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = maximum([1, 0, 5, -7],1);\nlet expected_8 = [5];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = maximum([4, -4],2);\nlet expected_9 = [-4, 4];\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = maximum([-10, 10],2);\nlet expected_10 = [-10, 10];\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = maximum([1, 2, 3, -23, 243, -400, 0],0);\nlet expected_11 = [];\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\n", "language": "typescript", "description": "पूर्णांकांची एक आर. आर. आणि एक सकारात्मक पूर्णांक के दिल्यास, क्रमवारी लावलेली यादी परत करा. \nए. आर. आर. मध्ये कमाल के संख्येसह लांबी के. \n\nउदाहरण 1: \n\nइनपुटः arr = [-3,-4,5], k = 3 \nउत्पादनः [-4,-3,5] \n\nउदाहरण 2: \n\nइनपुटः arr = [4,-4,4], k = 2 \nउत्पादनः [4,4] \n\nउदाहरण 3: \n\nइनपुटः arr = [-3,2,1,2,-1,-2,1], k = 1 \nउत्पादनः [2] \n\nटीपः \n1. अॅरेची लांबी [1000] च्या श्रेणीत असेल. \n2. रचनेतील घटक [-1000] च्या श्रेणीत असतील. \n3. 0 <= k <= लेन (arr)", "entry_point": "maximum", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/55", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = add_elements([1, -2, -3, 41, 57, 76, 87, 88, 99],3);\nlet expected_1 = -4;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = add_elements([111, 121, 3, 4000, 5, 6],2);\nlet expected_2 = 0;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = add_elements([11, 21, 3, 90, 5, 6, 7, 8, 9],4);\nlet expected_3 = 125;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = add_elements([111, 21, 3, 4000, 5, 6, 7, 8, 9],4);\nlet expected_4 = 24;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = add_elements([1],1);\nlet expected_5 = 1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "पूर्णांक ए. आर. आर. आणि पूर्णांक के. ची रिकामी नसलेली श्रेणी दिल्यास, परत करा \nए. आर. आर. च्या पहिल्या के घटकांमधून जास्तीत जास्त दोन अंक असलेल्या घटकांची बेरीज. \n\nउदाहरणादाखलः \n\nइनपुटः arr = [111,21,3, 4000,5,6, 7,8,9], k = 4 \nउत्पादनः 24 #21 + 3 ची बेरीज \n\nनिर्बंधः \n1. 1 <= लेन (ए. आर. आर.) <= 100 \n2. 1 <= k <= लेन (arr)", "entry_point": "add_elements", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/56", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = intersection([1, 2],[2, 3]);\nlet expected_1 = \"NO\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = intersection([-1, 1],[0, 4]);\nlet expected_2 = \"NO\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = intersection([-3, -1],[-5, 5]);\nlet expected_3 = \"YES\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = intersection([-2, 2],[-4, 0]);\nlet expected_4 = \"YES\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = intersection([-11, 2],[-1, -1]);\nlet expected_5 = \"NO\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = intersection([1, 2],[3, 5]);\nlet expected_6 = \"NO\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = intersection([1, 2],[1, 2]);\nlet expected_7 = \"NO\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = intersection([-2, -2],[-3, -2]);\nlet expected_8 = \"NO\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "तुम्हाला दोन अंतर दिले जातात, \nजेथे प्रत्येक मध्यांतर हे पूर्णांकांची जोडी असते. उदाहरणार्थ, मध्यांतर = (प्रारंभ, शेवट) = (1,2). \nदिलेले अंतर बंद असतात ज्याचा अर्थ असा आहे की मध्यांतर (प्रारंभ, शेवट) \nत्यात सुरुवात आणि शेवट या दोन्हींचा समावेश आहे. \nदिलेल्या प्रत्येक मध्यांतरासाठी, असे गृहीत धरले जाते की त्याची सुरुवात त्याच्या शेवटापेक्षा कमी किंवा समान आहे. \nया दोघांच्या छेदनबिंदूची लांबी किती आहे हे ठरवणे हे तुमचे काम आहे. \nमध्यांतर ही एक अभाज्य संख्या आहे. \nउदाहरणार्थ, अंतरांचे छेदनबिंदू (1,3), (2,4) हे (2,3) आहे. \nज्याची लांबी 1 आहे, जी अभाज्य संख्या नाही. \nछेदनबिंदूची लांबी जर मूळ संख्या असेल, तर'होय'परत करा. \nअन्यथा,'नाही'परत करा. \nजर दोन मध्यांतर एकमेकांना छेदत नसतील, तर'नाही'परत करा. \n\n[इनपुट/आउटपुट] नमुनेः \nछेदनबिंदू ((1,2,3)) = =>'नाही'\nछेदनबिंदू ((-1,1), (0,4)) = => \"नाही\" \nछेदनबिंदू ((-3,-1), (-5,5)) = => \"होय\"", "entry_point": "intersection", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/57", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = tri(3);\nlet expected_1 = [1, 3, 2.0, 8.0];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = tri(4);\nlet expected_2 = [1, 3, 2.0, 8.0, 3.0];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = tri(5);\nlet expected_3 = [1, 3, 2.0, 8.0, 3.0, 15.0];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = tri(6);\nlet expected_4 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = tri(7);\nlet expected_5 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = tri(8);\nlet expected_6 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = tri(9);\nlet expected_7 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = tri(20);\nlet expected_8 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = tri(0);\nlet expected_9 = [1];\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = tri(1);\nlet expected_10 = [1, 3];\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "प्रत्येकाला फिबोनाची क्रम माहीत आहे, त्याचा गणितशास्त्रज्ञांनी सखोल अभ्यास केला होता. \nगेल्या दोन शतके. तथापि, लोकांना जे माहित नाही ते म्हणजे ट्रिबोनाची क्रमवारी. \nट्रायबोनाची क्रमवारी पुनरावृत्तीद्वारे परिभाषित केली जातेः \nत्रि (1) = 3 \nत्रि (n) = 1 + n/2, जर n सम असेल. \nत्रि (n) = त्रि (n-1) + त्रि (n-2) + त्रि (n + 1), जर n विषम असेल. \nउदाहरणार्थ, \nत्रि (2) = 1 + (2/2) = 2 \nत्रि (4) = 3 \nत्रि (3) = त्रि (2) + त्रि (1) + त्रि (4) \n= 2 + 3 + 3 = 8 \nतुम्हाला एक नकारात्मक नसलेला पूर्णांक क्रमांक n दिला आहे, तुम्हाला त्याची यादी परत करावी लागेल \nट्रिबोनाची अनुक्रमाच्या पहिल्या n + 1 संख्या. \nउदाहरणेः \nत्रि (3) = [1,3,2,8]", "entry_point": "tri", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/58", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = digits(5);\nlet expected_1 = 5;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = digits(54);\nlet expected_2 = 5;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = digits(120);\nlet expected_3 = 1;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = digits(5014);\nlet expected_4 = 5;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = digits(98765);\nlet expected_5 = 315;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = digits(5576543);\nlet expected_6 = 2625;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = digits(2468);\nlet expected_7 = 0;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "सकारात्मक पूर्णांक n दिल्यास, विषम अंकांचे गुणाकार परत करा. \nसर्व अंक सम असल्यास 0 परत करा. \nउदाहरणार्थ, \nअंक (1) = = 1 \nअंक (4) = = 0 \nअंक (235) = = 15", "entry_point": "digits", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/59", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_nested(\"[[]]\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_nested(\"[]]]]]]][[[[[]\");\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_nested(\"[][]\");\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_nested(\"[]\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_nested(\"[[[[]]]]\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_nested(\"[]]]]]]]]]]\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_nested(\"[][][[]]\");\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = is_nested(\"[[]\");\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = is_nested(\"[]]\");\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = is_nested(\"[[]][[\");\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = is_nested(\"[[][]]\");\nlet expected_11 = true;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = is_nested(\"\");\nlet expected_12 = false;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = is_nested(\"[[[[[[[[\");\nlet expected_13 = false;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = is_nested(\"]]]]]]]]\");\nlet expected_14 = false;\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\n", "language": "typescript", "description": "एक कार्य तयार करा जे स्ट्रिंगला इनपुट म्हणून घेते ज्यामध्ये फक्त चौरस कंस असतात. \nजर आणि केवळ कंसांचा वैध पाठपुरावा असेल तरच कार्य खरे परत आले पाहिजे \nजेथे पुढील भागामध्ये किमान एक कंस नेस्ट केलेला असतो. \n\nनेस्टेड आहे ('[[]]') खरे आहे \nis _ nested ('[]]]]] [[[[]') खोटे आहे \nनेस्टेड आहे ('[] []') खोटे \nनेस्टेड आहे ('[]') खोटे \nनेस्टेड आहे ('[[] []]') खरे आहे \nनेस्टेड आहे ('[[]] [[') खरे आहे", "entry_point": "is_nested", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/60", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = sum_squares([1, 2, 3]);\nlet expected_1 = 14;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = sum_squares([1.0, 2, 3]);\nlet expected_2 = 14;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = sum_squares([1, 3, 5, 7]);\nlet expected_3 = 84;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = sum_squares([1.4, 4.2, 0]);\nlet expected_4 = 29;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = sum_squares([-2.4, 1, 1]);\nlet expected_5 = 6;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = sum_squares([100, 1, 15, 2]);\nlet expected_6 = 10230;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = sum_squares([10000, 10000]);\nlet expected_7 = 200000000;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = sum_squares([-1.4, 4.6, 6.3]);\nlet expected_8 = 75;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = sum_squares([-1.4, 17.9, 18.9, 19.9]);\nlet expected_9 = 1086;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = sum_squares([0]);\nlet expected_10 = 0;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = sum_squares([-1]);\nlet expected_11 = 1;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = sum_squares([-1, 1, 0]);\nlet expected_12 = 2;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\n", "language": "typescript", "description": "तुम्हाला संख्यांची यादी दिली जाते. \nतुम्हाला दिलेल्या यादीतील वर्गसंख्यांची बेरीज परत करावी लागेल, \nसूचीतील प्रत्येक घटकाला प्रथम वरच्या पूर्णांक (कमाल मर्यादा) पर्यंत गोल करा. \nउदाहरणेः \nlst = [1,2,3] साठी आउटपुट 14 असावे. \nlst = [1,4,9] साठी आउटपुट 98 असावे. \nlst = [1,3,5, 7] साठी उत्पादन 84 असावे. \nlst = [1.4,4.2, 0] साठी उत्पादन 29 असावे. \nlst = [-2.4,1, 1] साठी आउटपुट 6 असावे.", "entry_point": "sum_squares", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/61", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = check_if_last_char_is_a_letter(\"apple\");\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = check_if_last_char_is_a_letter(\"apple pi e\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = check_if_last_char_is_a_letter(\"eeeee\");\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = check_if_last_char_is_a_letter(\"A\");\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = check_if_last_char_is_a_letter(\"Pumpkin pie \");\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = check_if_last_char_is_a_letter(\"Pumpkin pie 1\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = check_if_last_char_is_a_letter(\"\");\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = check_if_last_char_is_a_letter(\"eeeee e \");\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = check_if_last_char_is_a_letter(\"apple pie\");\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = check_if_last_char_is_a_letter(\"apple pi e \");\nlet expected_10 = false;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "शेवटचे अक्षर खरे असेल तर परत करणारे कार्य तयार करा \nदिलेल्या स्ट्रिंगचे वर्णमाला वर्ण आहे आणि ते नाही \nशब्दाचा एक भाग, आणि अन्यथा खोटा. \nटीपः \"शब्द\" हा जागेने विभक्त केलेल्या वर्णांचा समूह आहे. \n\nउदाहरणेः \nतपासा _ जर _ शेवटचे _ चार _ हे _ अ _ अक्षर आहे (\"सफरचंद पाई\") \nतपासा _ जर _ शेवटचे _ चार _ हे _ अ _ अक्षर आहे (\"सफरचंद पाई ई\") \nतपासा _ जर _ शेवटचे _ चार _ हे _ अ _ अक्षर आहे (\"सफरचंद पाई ई\") \nतपासा _ जर _ शेवटचे _ चार _ हे _ अ _ अक्षर आहे (\"\") खोटे", "entry_point": "check_if_last_char_is_a_letter", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/62", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = can_arrange([1, 2, 4, 3, 5]);\nlet expected_1 = 3;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = can_arrange([1, 2, 4, 5]);\nlet expected_2 = -1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = can_arrange([1, 4, 2, 5, 6, 7, 8, 9, 10]);\nlet expected_3 = 2;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = can_arrange([4, 8, 5, 7, 3]);\nlet expected_4 = 4;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = can_arrange([]);\nlet expected_5 = -1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "एखाद्या घटकाची सर्वात मोठी अनुक्रमणिका परत करणारे कार्य तयार करा जे \nतो त्याच्या ताबडतोब आधीच्या घटकापेक्षा मोठा किंवा समान नसेल. जर \nअसा कोणताही घटक अस्तित्वात नसेल तर-1 परत करा. दिलेल्या अॅरेमध्ये समाविष्ट होणार नाही \nदुहेरी मूल्ये. \n\nउदाहरणेः \nकॅन अरेंज ([1,2,4, 3,5]) = 3 \nकॅन अरेंज ([1,2,3]) =-1", "entry_point": "can_arrange", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/63", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = largest_smallest_integers([2, 4, 1, 3, 5, 7]);\nlet expected_1 = [undefined, 1];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = largest_smallest_integers([2, 4, 1, 3, 5, 7, 0]);\nlet expected_2 = [undefined, 1];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = largest_smallest_integers([1, 3, 2, 4, 5, 6, -2]);\nlet expected_3 = [-2, 1];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = largest_smallest_integers([4, 5, 3, 6, 2, 7, -7]);\nlet expected_4 = [-7, 2];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = largest_smallest_integers([7, 3, 8, 4, 9, 2, 5, -9]);\nlet expected_5 = [-9, 2];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = largest_smallest_integers([]);\nlet expected_6 = [undefined, undefined];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = largest_smallest_integers([0]);\nlet expected_7 = [undefined, undefined];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = largest_smallest_integers([-1, -3, -5, -6]);\nlet expected_8 = [-1, undefined];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = largest_smallest_integers([-1, -3, -5, -6, 0]);\nlet expected_9 = [-1, undefined];\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = largest_smallest_integers([-6, -4, -4, -3, 1]);\nlet expected_10 = [-3, 1];\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = largest_smallest_integers([-6, -4, -4, -3, -100, 1]);\nlet expected_11 = [-3, 1];\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\n", "language": "typescript", "description": "टुपल (अ, ब) परत करणारे कार्य तयार करा, जेथे'अ'आहे \nनकारात्मक पूर्णांकांपैकी सर्वात मोठा, आणि'ब'सर्वात लहान आहे \nसूचीतील सकारात्मक पूर्णांक. \nजर कोणतेही नकारात्मक किंवा सकारात्मक पूर्णांक नसतील, तर त्यांना शून्य म्हणून परत करा. \n\nउदाहरणेः \nसर्वात मोठे _ सर्वात लहान _ पूर्णांक ([2,4,1,3,5,7]) = = (काहीही नाही, 1) \nसर्वांत मोठे _ सर्वात लहान _ पूर्णांक ([]) = = (काहीही नाही, काहीही नाही) \nसर्वांत मोठे _ सर्वात लहान _ पूर्णांक ([0]) = = (काहीही नाही, काहीही नाही)", "entry_point": "largest_smallest_integers", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/64", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = special_factorial(4);\nlet expected_1 = 288;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = special_factorial(5);\nlet expected_2 = 34560;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = special_factorial(7);\nlet expected_3 = 125411328000;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = special_factorial(1);\nlet expected_4 = 1;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "ब्राझिलियन फॅक्टोरियलची व्याख्या अशी केली जातेः \nब्राझिलियन _ फॅक्टोरियल (एन) = एन! * (एन-1)! * (एन-2)! *... * 1! \nजेथे n> 0 \n\nउदाहरणार्थ, \n>>> स्पेशल _ फॅक्टोरियल (4) \n288 \n\nफंक्शनला इनपुट म्हणून एक पूर्णांक प्राप्त होईल आणि त्याने विशेष परत केले पाहिजे. \nया पूर्णांकाचे फॅक्टोरियल.", "entry_point": "special_factorial", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/65", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = words_in_sentence(\"This is a test\");\nlet expected_1 = \"is\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = words_in_sentence(\"lets go for swimming\");\nlet expected_2 = \"go for\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = words_in_sentence(\"there is no place available here\");\nlet expected_3 = \"there is no place\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = words_in_sentence(\"Hi I am Hussein\");\nlet expected_4 = \"Hi am Hussein\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = words_in_sentence(\"go for it\");\nlet expected_5 = \"go for it\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = words_in_sentence(\"here\");\nlet expected_6 = \"\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = words_in_sentence(\"here is\");\nlet expected_7 = \"is\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "तुम्हाला वाक्याचे प्रतिनिधित्व करणारी एक स्ट्रिंग दिली जाते, \nवाक्यात जागेने वेगळे केलेले काही शब्द आहेत, \nआणि तुम्हाला मूळ वाक्यातील शब्द असलेली एक स्ट्रिंग परत करावी लागेल, \nज्याची लांबी ही अभाज्य संख्या आहे, \nनवीन अक्षरातील शब्दांचा क्रम मूळ अक्षरासारखाच असावा. \n\nउदाहरण 1: \nइनपुटः वाक्य = \"ही एक चाचणी आहे\" \nआउटपुटः \"आहे\" \n\nउदाहरण 2: \nइनपुटः वाक्य = \"चला पोहायला जाऊया\" \nआउटपुटः \"साठी जा\" \n\nनिर्बंधः \n* 1 <= लेन (वाक्य) <= 100 \n* वाक्यात फक्त अक्षरे असतात", "entry_point": "words_in_sentence", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/66", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = simplify(\"1/5\",\"5/1\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = simplify(\"1/6\",\"2/1\");\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = simplify(\"5/1\",\"3/1\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = simplify(\"7/10\",\"10/2\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = simplify(\"2/10\",\"50/10\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = simplify(\"7/2\",\"4/2\");\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = simplify(\"11/6\",\"6/1\");\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = simplify(\"2/3\",\"5/2\");\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = simplify(\"5/2\",\"3/5\");\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = simplify(\"2/4\",\"8/4\");\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = simplify(\"2/4\",\"4/2\");\nlet expected_11 = true;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = simplify(\"1/5\",\"5/1\");\nlet expected_12 = true;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = simplify(\"1/5\",\"1/5\");\nlet expected_13 = false;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\n", "language": "typescript", "description": "अभिव्यक्ती सोपी करणारे कार्य अंमलात आणणे हे तुमचे काम आहे. \nx * n. जर x * n पूर्ण संख्येचे मूल्यांकन करत असेल आणि चुकीचे असेल तर कार्य खरे परत करते. \nअन्यथा. x आणि n दोन्ही, एका अपूर्णांकाचे स्ट्रिंग प्रतिनिधित्व आहेत आणि त्यांचे खालील स्वरूप आहे, \n<न्यूमरेटर> <डिनॉमिनेटर> जेथे न्यूमरेटर आणि डिनॉमिनेटर दोन्ही सकारात्मक पूर्ण संख्या आहेत. \n\nतुम्ही असे गृहीत धरू शकता की x आणि n हे वैध अपूर्णांक आहेत आणि त्यांना विभाजक म्हणून शून्य नाही. \n\nसरलीकरण करा (\"1/5\", \"5/1\") = खरे \nसरलीकरण करा (\"1/6\", \"2/1\") = चुकीचे \nसोपे करा (\"7/10\", \"10/2\") = चुकीचे", "entry_point": "simplify", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/67", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = order_by_points([1, 11, -1, -11, -12]);\nlet expected_1 = [-1, -11, 1, -12, 11];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = order_by_points([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]);\nlet expected_2 = [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = order_by_points([]);\nlet expected_3 = [];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = order_by_points([1, -11, -32, 43, 54, -98, 2, -3]);\nlet expected_4 = [-3, -32, -98, -11, 1, 2, 43, 54];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = order_by_points([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);\nlet expected_5 = [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = order_by_points([0, 6, 6, -76, -21, 23, 4]);\nlet expected_6 = [-76, -21, 0, 4, 23, 6, 6];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "पूर्णांकांची दिलेली यादी क्रमवारी लावणारे कार्य लिहा. \nत्यांच्या अंकांच्या बेरीजनुसार चढत्या क्रमाने. \nटीपः त्यांच्या अंकांची समान बेरीज असलेल्या अनेक वस्तू असल्यास, \nमूळ यादीतील त्यांच्या निर्देशांकाच्या आधारे त्यांना ऑर्डर करा. \n\nउदाहरणार्थ, \n>> ऑर्डर _ बाय _ पॉईंट्स ([1,11,-1,11,-12]) = = [-1,11,1,-12,11] \n>>> ऑर्डर _ बाय _ पॉइंट्स ([]) = = []", "entry_point": "order_by_points", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/68", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = specialFilter([5, -2, 1, -5]);\nlet expected_1 = 0;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = specialFilter([15, -73, 14, -15]);\nlet expected_2 = 1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = specialFilter([33, -2, -3, 45, 21, 109]);\nlet expected_3 = 2;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = specialFilter([43, -12, 93, 125, 121, 109]);\nlet expected_4 = 4;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = specialFilter([71, -2, -33, 75, 21, 19]);\nlet expected_5 = 3;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = specialFilter([1]);\nlet expected_6 = 0;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = specialFilter([]);\nlet expected_7 = 0;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "इनपुट आणि रिटर्न म्हणून संख्यांची एक श्रेणी घेणारे कार्य लिहा. \nअॅरेमधील घटकांची संख्या जी 10 पेक्षा जास्त आहे आणि दोन्ही \nसंख्येचे पहिले आणि शेवटचे अंक विषम (1,3,5,7,9) असतात. \nउदाहरणार्थ, \nविशेष फिल्टर ([15,-73,14,-15]) => 1 \nविशेष फिल्टर ([33,-2,-3,45,21,109]) => 2", "entry_point": "specialFilter", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/69", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = get_max_triples(5);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = get_max_triples(6);\nlet expected_2 = 4;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = get_max_triples(10);\nlet expected_3 = 36;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = get_max_triples(100);\nlet expected_4 = 53361;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "तुम्हाला एक सकारात्मक पूर्णांक n दिला जातो. तुम्हाला n लांबीचा एक पूर्णांक अ तयार करावा लागेल. \nप्रत्येक i (1 ≤ i ≤ n) साठी, a [i] = i * i-i + 1 चे मूल्य. \na च्या त्रिकांची संख्या (a [i], a [j], a [k]) परत करा जेथे i <j <k, \nआणि a [i] + a [j] + a [k] हा 3 चा गुणाकार आहे. \n\nउदाहरणादाखलः \nइनपुटः n = 5 \nउत्पादनः 1 \nस्पष्टीकरणः \nअ = [1,3,7,13,21] \nएकमेव वैध तिहेरी (1,7,13) आहे.", "entry_point": "get_max_triples", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/70", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = bf(\"Jupiter\",\"Neptune\");\nlet expected_1 = [\"Saturn\", \"Uranus\"];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = bf(\"Earth\",\"Mercury\");\nlet expected_2 = [\"Venus\"];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = bf(\"Mercury\",\"Uranus\");\nlet expected_3 = [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = bf(\"Neptune\",\"Venus\");\nlet expected_4 = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = bf(\"Earth\",\"Earth\");\nlet expected_5 = [];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = bf(\"Mars\",\"Earth\");\nlet expected_6 = [];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = bf(\"Jupiter\",\"Makemake\");\nlet expected_7 = [];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "आपल्या सौरमालेत आठ ग्रह आहेतः सूर्याच्या सर्वात जवळचे \nबुध आहे, पुढचा शुक्र आहे, मग पृथ्वी, मंगळ, गुरु, शनि, \nयुरेनस, नेपच्यून. \nग्रह 1 आणि ग्रह 2 अशी दोन ग्रहांची नावे घेणारे कार्य लिहा. \nया कार्याने ज्या सर्व ग्रहांच्या कक्षा आहेत अशा सर्व ग्रहांचा समावेश असलेला टुपल परत केला पाहिजे. \n1 ग्रहाची कक्षा आणि 2 ग्रहाची कक्षा यांच्या दरम्यान स्थित, क्रमानुसार \nसूर्याची जवळीक. \nजर ग्रह 1 किंवा ग्रह 2 असेल तर कार्याने रिकामे टुपल परत केले पाहिजे \nग्रहांची नावे योग्य नाहीत. \nउदाहरणे \nbf (\"गुरू\", \"नेपच्यून\") = => (\"शनि\", \"युरेनस\") \nbf (\"पृथ्वी\", \"बुध\") = => (\"शुक्र\") \nbf (\"बुध\", \"युरेनस\") = => (\"शुक्र\", \"पृथ्वी\", \"मंगळ\", \"गुरु\", \"शनि\")", "entry_point": "bf", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/71", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = x_or_y(7,34,12);\nlet expected_1 = 34;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = x_or_y(15,8,5);\nlet expected_2 = 5;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = x_or_y(3,33,5212);\nlet expected_3 = 33;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = x_or_y(1259,3,52);\nlet expected_4 = 3;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = x_or_y(7919,-1,12);\nlet expected_5 = -1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = x_or_y(3609,1245,583);\nlet expected_6 = 583;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = x_or_y(91,56,129);\nlet expected_7 = 129;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = x_or_y(6,34,1234);\nlet expected_8 = 1234;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = x_or_y(1,2,0);\nlet expected_9 = 0;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = x_or_y(2,2,0);\nlet expected_10 = 2;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "एक साधा प्रोग्राम ज्याने n असल्यास x चे मूल्य परत केले पाहिजे \nएक अभाज्य संख्या आणि अन्यथा y चे मूल्य परत केले पाहिजे. \n\nउदाहरणेः \nx _ किंवा _ y साठी (7,34,12) = = 34 \nx _ किंवा _ y साठी (15,8,5) = = 5", "entry_point": "x_or_y", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/72", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = double_the_difference([]);\nlet expected_1 = 0;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = double_the_difference([5, 4]);\nlet expected_2 = 25;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = double_the_difference([0.1, 0.2, 0.3]);\nlet expected_3 = 0;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = double_the_difference([-10, -20, -30]);\nlet expected_4 = 0;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = double_the_difference([-1, -2, 8]);\nlet expected_5 = 0;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = double_the_difference([0.2, 3, 5]);\nlet expected_6 = 34;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = double_the_difference([-99, -97, -95, -93, -91, -89, -87, -85, -83, -81, -79, -77, -75, -73, -71, -69, -67, -65, -63, -61, -59, -57, -55, -53, -51, -49, -47, -45, -43, -41, -39, -37, -35, -33, -31, -29, -27, -25, -23, -21, -19, -17, -15, -13, -11, -9, -7, -5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99]);\nlet expected_7 = 166650;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "आकड्यांची यादी दिल्यास, आकड्यांच्या वर्गांची बेरीज परत करा. \nविषम असलेल्या यादीमध्ये. पूर्णांक नसलेल्या किंवा नकारात्मक असलेल्या संख्यांकडे दुर्लक्ष करा. \n\nदुहेरी _ फरक ([1,3,2,0]) = = 1 + 9 + 0 + 0 = 10 \nदुहेरी _ फरक ([-1,0]) = = 0 \nदुहेरी फरक ([9,-2]) = = 81 \nदुहेरी _ फरक ([0]) = = 0 \n\nइनपुट यादी रिकामी असल्यास, 0 परत करा.", "entry_point": "double_the_difference", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/73", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = Strongest_Extension(\"Watashi\",[\"tEN\", \"niNE\", \"eIGHt8OKe\"]);\nlet expected_1 = \"Watashi.eIGHt8OKe\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = Strongest_Extension(\"Boku123\",[\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]);\nlet expected_2 = \"Boku123.YEs.WeCaNe\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = Strongest_Extension(\"__YESIMHERE\",[\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]);\nlet expected_3 = \"__YESIMHERE.NuLl__\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = Strongest_Extension(\"K\",[\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]);\nlet expected_4 = \"K.TAR\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = Strongest_Extension(\"__HAHA\",[\"Tab\", \"123\", \"781345\", \"-_-\"]);\nlet expected_5 = \"__HAHA.123\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = Strongest_Extension(\"YameRore\",[\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]);\nlet expected_6 = \"YameRore.okIWILL123\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = Strongest_Extension(\"finNNalLLly\",[\"Die\", \"NowW\", \"Wow\", \"WoW\"]);\nlet expected_7 = \"finNNalLLly.WoW\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = Strongest_Extension(\"_\",[\"Bb\", \"91245\"]);\nlet expected_8 = \"_.Bb\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = Strongest_Extension(\"Sp\",[\"671235\", \"Bb\"]);\nlet expected_9 = \"Sp.671235\";\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "तुम्हाला एका वर्गाचे नाव (एक स्ट्रिंग) आणि विस्तारांची यादी दिली जाईल. \nवर्गामध्ये अतिरिक्त वर्ग भरण्यासाठी विस्तारांचा वापर केला जाणार आहे. \nविस्ताराची ताकद खालीलप्रमाणे आहेः CAP ही मोठ्या अक्षराची संख्या असू द्या. \nविस्ताराच्या नावातील अक्षरे, आणि एस. एम. ही लहान अक्षरांची संख्या असू द्या \nएक्स्टेंशनच्या नावात, कॅप-एस. एम. या अपूर्णांकाद्वारे सामर्थ्य दिले जाते. \nतुम्ही सर्वात मजबूत विस्तार शोधला पाहिजे आणि यात एक स्ट्रिंग परत केली पाहिजे. \nस्वरूपः ClassName.StrongestExtensionName. \nजर समान ताकदीचे दोन किंवा अधिक विस्तार असतील, तर तुम्ही \nयादीत प्रथम येणाऱ्या व्यक्तीची निवड करा. \nउदाहरणार्थ, जर तुम्हाला वर्ग आणि यादी म्हणून'स्लाइसेस'दिले गेले असतील तर \nविस्तारः ['SERVINGSliCes','चीज','स्टुफॅड'] मग तुम्ही \n'SERVINGSliCes'हा सर्वात मजबूत विस्तार असल्याने'Slices.SErviNGSliCes'परत करा \n(त्याची ताकद-1 आहे). \nउदाहरणादाखलः \nस्ट्रॉंगेस्ट _ एक्स्टेंशनसाठी ('माय _ क्लास', ['एए','बी','सीसी']) = ='my_class.AA'", "entry_point": "Strongest_Extension", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/74", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = cycpattern_check(\"xyzw\",\"xyw\");\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = cycpattern_check(\"yello\",\"ell\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = cycpattern_check(\"whattup\",\"ptut\");\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = cycpattern_check(\"efef\",\"fee\");\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = cycpattern_check(\"abab\",\"aabb\");\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = cycpattern_check(\"winemtt\",\"tinem\");\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "तुम्हाला 2 शब्द देण्यात आले आहेत. जर दुसरा शब्द किंवा त्यातील कोणतेही परिभ्रमण पहिल्या शब्दातील सबस्ट्रिंग असेल तर तुम्हाला खरे परतावे लागेल. \nसायकपॅटर्न _ चेक (\"ए. बी. सी. डी\"., \"ए. बी. डी\".) => खोटे \nसायकपॅटर्न तपासा (\"हॅलो\", \"एल\") => खरे \nसायकपॅटर्न _ चेक (\"व्हासअप\", \"psus\") => खोटे \nसायकपॅटर्न _ चेक (\"अबाब\", \"बा\") => खरे \nसायकपॅटर्न _ चेक (\"ईएफईएफ\", \"ईएफईएफ\") => खोटे \nसायकपॅटर्न _ चेक (\"हिमेन्स\", \"सिमेन\") => खरे", "entry_point": "cycpattern_check", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/75", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = int_to_mini_roman(19);\nlet expected_1 = \"xix\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = int_to_mini_roman(152);\nlet expected_2 = \"clii\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = int_to_mini_roman(251);\nlet expected_3 = \"ccli\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = int_to_mini_roman(426);\nlet expected_4 = \"cdxxvi\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = int_to_mini_roman(500);\nlet expected_5 = \"d\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = int_to_mini_roman(1);\nlet expected_6 = \"i\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = int_to_mini_roman(4);\nlet expected_7 = \"iv\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = int_to_mini_roman(43);\nlet expected_8 = \"xliii\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = int_to_mini_roman(90);\nlet expected_9 = \"xc\";\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = int_to_mini_roman(94);\nlet expected_10 = \"xciv\";\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = int_to_mini_roman(532);\nlet expected_11 = \"dxxxii\";\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = int_to_mini_roman(900);\nlet expected_12 = \"cm\";\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = int_to_mini_roman(994);\nlet expected_13 = \"cmxciv\";\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = int_to_mini_roman(1000);\nlet expected_14 = \"m\";\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\n", "language": "typescript", "description": "एक सकारात्मक पूर्णांक दिल्यास, त्याचा रोमन अंकी समतुल्य स्ट्रिंग म्हणून मिळवा, \nआणि ते लहान अक्षरात परत करा. \nनिर्बंधः 1 <= संख्या <= 1000 \n\nउदाहरणेः \n>> int _ to _ मिनी _ रोमन (19) = ='xix'\n>> इंट _ टू _ मिनी _ रोमन (152) = ='क्लाई'\n>> int _ to _ मिनी _ रोमन (426) = ='cdxxvi'", "entry_point": "int_to_mini_roman", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/76", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = right_angle_triangle(3,4,5);\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = right_angle_triangle(1,2,3);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = right_angle_triangle(10,6,8);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = right_angle_triangle(2,2,2);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = right_angle_triangle(7,24,25);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = right_angle_triangle(10,5,7);\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = right_angle_triangle(5,12,13);\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = right_angle_triangle(15,8,17);\nlet expected_8 = true;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = right_angle_triangle(48,55,73);\nlet expected_9 = true;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = right_angle_triangle(1,1,1);\nlet expected_10 = false;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = right_angle_triangle(2,2,10);\nlet expected_11 = false;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\n", "language": "typescript", "description": "त्रिकोणाच्या तीन बाजूंची लांबी दिली. जर त्या तीनही असतील तर खरे परत करा. \nबाजू उजव्या कोनीय त्रिकोण तयार करतात, अन्यथा खोटे. \nउजव्या कोणाचा त्रिकोण हा एक त्रिकोण आहे ज्यामध्ये एक कोन उजव्या कोनात किंवा उजव्या कोनात असतो. \n90 अंश. \nउदाहरणादाखलः \nसमकोण त्रिकोण (3,4,5) = = खरे \nसमकोण त्रिकोण (1,2,3) = = चुकीचा", "entry_point": "right_angle_triangle", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/77", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = solve(\"AsDf\");\nlet expected_1 = \"aSdF\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = solve(\"1234\");\nlet expected_2 = \"4321\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = solve(\"ab\");\nlet expected_3 = \"AB\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = solve(\"#a@C\");\nlet expected_4 = \"#A@c\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = solve(\"#AsdfW^45\");\nlet expected_5 = \"#aSDFw^45\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = solve(\"#6@2\");\nlet expected_6 = \"2@6#\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = solve(\"#$a^D\");\nlet expected_7 = \"#$A^d\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = solve(\"#ccc\");\nlet expected_8 = \"#CCC\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "तुम्हाला एक स्ट्रिंग s दिली जाते. \nजर एस [आय] हे एक अक्षर असेल तर त्याचे प्रकरण खालून वर किंवा उलट करा, \nअन्यथा ते जसे आहे तसे ठेवा. \nजर स्ट्रिंगमध्ये अक्षरे नसतील तर स्ट्रिंग उलट करा. \nफंक्शनने परिणामी स्ट्रिंग परत करावी. \nउदाहरणे \nनिराकरण (\"1234\") = \"4321\" \nसोडवा (\"अब\") = \"एबी\" \nसोडवा (\"#a @C\") = \"#A @c\"", "entry_point": "solve", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/78", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = string_to_md5(\"Hello world\");\nlet expected_1 = \"3e25960a79dbc69b674cd4ec67a72c62\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = string_to_md5(\"\");\nlet expected_2 = undefined;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = string_to_md5(\"A B C\");\nlet expected_3 = \"0ef78513b0cb8cef12743f5aeb35f888\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = string_to_md5(\"password\");\nlet expected_4 = \"5f4dcc3b5aa765d61d8327deb882cf99\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "स्ट्रिंग'टेक्स्ट'दिल्यास, त्याची md5 हॅश समतुल्य स्ट्रिंग परत करा. \nजर'टेक्स्ट'ही रिकामी स्ट्रिंग असेल तर शून्य परत करा. \n\n>> स्ट्रिंग _ ते _ md5 ('हॅलो वर्ल्ड') = ='3e25960a79dbc69b674cd4ec67a72c62'", "entry_point": "string_to_md5", "canonical_solution": null, "natural_language": "Marathi"}
{"task_id": "typescript/79", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = generate_integers(2,10);\nlet expected_1 = [2, 4, 6, 8];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = generate_integers(10,2);\nlet expected_2 = [2, 4, 6, 8];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = generate_integers(132,2);\nlet expected_3 = [2, 4, 6, 8];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = generate_integers(17,89);\nlet expected_4 = [];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "a आणि b हे दोन सकारात्मक पूर्णांक दिल्यास, a मधील सम अंक परत करा. \nआणि ब, चढत्या क्रमाने. \n\nउदाहरणार्थ, \nजनरेट _ इंटिजर्स (2,8) => [2,4,6,8] \nजनरेट _ इंटिजर्स (8,2) => [2,4,6,8] \nपूर्णांक निर्माण करा (10,14) => []", "entry_point": "generate_integers", "canonical_solution": null, "natural_language": "Marathi"}
