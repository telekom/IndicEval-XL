{"task_id": "python/0", "entry_point": "below_zero", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n", "language": "python", "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n", "description": "آپ کو بینک اکاؤنٹ میں جمع اور نکلوانے کی کارروائیوں کی ایک فہرست دی جاتی ہے جو اس سے شروع ہوتی ہے \nصفر بیلنس۔ آپ کا کام یہ معلوم کرنا ہے کہ آیا کسی بھی وقت اکاؤنٹ کا بیلنس صفر سے نیچے آتا ہے، اور \nاس وقت فنکشن کو درست واپس کرنا چاہیے۔ بصورت دیگر اسے غلط واپس کرنا چاہیے۔ \n>>> نیچے _ صفر ([1، 2، 3]) \nجھوٹا۔ \n>>> نیچے _ صفر ([1، 2،-4، 5]) \nسچ ہے۔", "natural_language": "Urdu"}
{"task_id": "python/1", "entry_point": "sum_product", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n", "language": "python", "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n", "description": "انٹیجرز کی دی گئی فہرست کے لیے، ایک ٹپل واپس کریں جس میں ایک مجموعہ اور فہرست میں موجود تمام انٹیجرز کا پروڈکٹ ہو۔ \nخالی رقم 0 کے برابر ہونی چاہیے اور خالی پروڈکٹ 1 کے برابر ہونا چاہیے۔ \n>>> sum _ product ([]) \n(0، 1) \n>>> sum _ product ([1، 2، 3، 4]) \n(10، 24)", "natural_language": "Urdu"}
{"task_id": "python/2", "entry_point": "string_xor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n", "language": "python", "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n", "description": "ان پٹ دو تار a اور b ہیں جو صرف 1s اور 0s پر مشتمل ہیں۔ \nان ان پٹ پر بائنری XOR انجام دیں اور نتیجہ بھی ایک سٹرنگ کے طور پر واپس کریں۔ \n>>> سٹرنگ _ xor ('010'،'110') \n'100'", "natural_language": "Urdu"}
{"task_id": "python/3", "entry_point": "longest", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n", "language": "python", "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "description": "سٹرنگ کی فہرست میں سے سب سے لمبا واپس کریں۔ متعدد ہونے کی صورت میں پہلا واپس کریں۔ \nایک ہی لمبائی کے تار۔ اگر ان پٹ فہرست خالی ہے تو کالعدم واپس کریں۔ \n>>> طویل ترین ([]) \n\n>>> طویل ترین (['a'،'b'،'c']) \n\"اے\" \n>>> طویل ترین (['a'،'bb'،'ccc']) \n'سی سی سی'", "natural_language": "Urdu"}
{"task_id": "python/4", "entry_point": "greatest_common_divisor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n", "language": "python", "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n", "description": "دو عدد a اور b کا سب سے بڑا مشترکہ تقسیم کار واپس کریں \n>>> سب سے بڑا _ عام _ تقسیم کنندہ (3, 5) \n1. \n>>> سب سے بڑا _ عام _ تقسیم کنندہ (25، 15) \n5.", "natural_language": "Urdu"}
{"task_id": "python/5", "entry_point": "sort_numbers", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n", "language": "python", "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n", "description": "ان پٹ'صفر'سے'نو'تک کے اعداد کی ایک جگہ کی حد بند تار ہے۔ \nدرست انتخاب'صفر'،'ایک'،'دو'،'تین'،'چار'،'پانچ'،'چھ'،'سات'،'آٹھ'اور'نو'ہیں۔ \nسب سے چھوٹے سے لے کر سب سے بڑے تک ترتیب شدہ نمبروں کے ساتھ سٹرنگ واپس کریں \n>>> نمبر ترتیب دیں ('تین ایک پانچ') \n'ایک تین پانچ'", "natural_language": "Urdu"}
{"task_id": "python/6", "entry_point": "rescale_to_unit", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n", "language": "python", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "description": "اعداد کی فہرست (کم از کم دو عناصر کی) کو دیکھتے ہوئے، اس فہرست میں لکیری تبدیلی لاگو کریں، \nاس طرح کہ سب سے چھوٹا عدد 0 ہو جائے گا اور سب سے بڑا عدد 1 ہو جائے گا۔ \n>>> ری سیل _ ٹو _ یونٹ ([1. 0, 2. 0, 3. 0, 4. 0, 5. 0]) \n[0. 0, 0. 25, 0. 0, 0. 75, 1. 0]", "natural_language": "Urdu"}
{"task_id": "python/7", "entry_point": "flip_case", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n", "language": "python", "canonical_solution": "    return string.swapcase()\n", "description": "دی گئی سٹرنگ کے لیے، چھوٹے حروف کو بڑے حروف میں اور بڑے حروف کو چھوٹے حروف میں پلٹائیں۔ \n>>> فلپ _ کیس ('ہیلو') \n\"ہیلو\"", "natural_language": "Urdu"}
{"task_id": "python/8", "entry_point": "get_positive", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n", "language": "python", "canonical_solution": "    return [e for e in l if e > 0]\n", "description": "فہرست میں صرف مثبت نمبر واپس کریں۔ \n>>> مثبت حاصل کریں ([-1, 2,-4, 5, 6]) \n[2، 5، 6] \n>>> مثبت حاصل کریں ([5، 3،-5، 2،-3، 3، 9، 0، 123، 1،-10]) \n[5، 3، 2، 3، 9، 123، 1]", "natural_language": "Urdu"}
{"task_id": "python/9", "entry_point": "is_prime", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n", "language": "python", "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n", "description": "اگر دیا ہوا نمبر پرائم ہے تو سچ واپس کریں، اور بصورت دیگر غلط۔ \n>>> is _ Prime (6) \nجھوٹا۔ \n>>> is _ Prime (101) \nسچ ہے۔ \n>>> is _ Prime (11) \nسچ ہے۔ \n>>> is _ Prime (13441) \nسچ ہے۔ \n>>> is _ Prime (61) \nسچ ہے۔ \n>>> is _ پرائم ہے (4) \nجھوٹا۔ \n>>> is _ Prime (1) \nجھوٹا۔", "natural_language": "Urdu"}
{"task_id": "python/10", "entry_point": "unique", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n", "language": "python", "canonical_solution": "    return sorted(list(set(l)))\n", "description": "فہرست میں ترتیب شدہ منفرد عناصر کو واپس کریں \n>>> منفرد ([5، 3، 5، 2، 3، 3، 9، 0، 123]) \n[0، 2، 3، 5، 9، 123]", "natural_language": "Urdu"}
{"task_id": "python/11", "entry_point": "prime_fib", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n", "language": "python", "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n", "description": "پرائم _ فائب n-th نمبر واپس کرتا ہے جو کہ فبونیکی نمبر ہے اور یہ بھی پرائم ہے۔ \n>>> پرائم _ فائب (1) \n2. \n>>> پرائم _ فائب (2) \n3 \n>>> پرائم _ فائب (3) \n5. \n>>> پرائم _ فائب (4) \n13 \n>>> پرائم _ فائب (5) \n89", "natural_language": "Urdu"}
{"task_id": "python/12", "entry_point": "triples_sum_to_zero", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n", "description": "ٹرپل _ سم _ ٹو _ زیرو انٹیجرز کی فہرست کو ان پٹ کے طور پر لیتا ہے۔ \nیہ سچ واپس کرتا ہے اگر فہرست میں تین الگ الگ عناصر ہیں \nصفر کا مجموعہ، اور بصورت دیگر غلط۔ \n\n>>> ٹرپل _ سم _ ٹو _ زیرو ([1، 3، 5، 0]) \nجھوٹا۔ \n>>> ٹرپل _ سم _ ٹو _ زیرو ([1، 3،-2، 1]) \nسچ ہے۔ \n>>> ٹرپل _ سم _ ٹو _ زیرو ([1، 2، 3، 7]) \nجھوٹا۔ \n>>> ٹرپل _ سم _ ٹو _ زیرو ([2، 4،-5، 3، 9، 7]) \nسچ ہے۔ \n>>> ٹرپل _ سم _ سے _ صفر ([1]) \nجھوٹا۔", "natural_language": "Urdu"}
{"task_id": "python/13", "entry_point": "pairs_sum_to_zero", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n", "language": "python", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "description": "pair _ sum _ to _ zero ان پٹ کے طور پر انٹیجرز کی فہرست لیتا ہے۔ \nاگر فہرست میں دو الگ الگ عناصر ہیں تو یہ سچ واپس کرتا ہے \nصفر کا مجموعہ، اور بصورت دیگر غلط۔ \n>>> جوڑے _ سم _ سے _ صفر ([1، 3، 5، 0]) \nجھوٹا۔ \n>>> جوڑے _ سم _ سے _ صفر ([1، 3،-2، 1]) \nجھوٹا۔ \n>>> جوڑے _ سم _ سے _ صفر ([1، 2، 3، 7]) \nجھوٹا۔ \n>>> جوڑے _ سم _ سے _ صفر ([2، 4،-5، 3، 5، 7]) \nسچ ہے۔ \n>>> جوڑے _ سم _ سے _ صفر ([1]) \nجھوٹا۔", "natural_language": "Urdu"}
{"task_id": "python/14", "entry_point": "fib4", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n", "language": "python", "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n", "description": "فب 4 نمبر کی ترتیب فبونیکی سیکونیس سے ملتی جلتی ایک ترتیب ہے جس کی تعریف اس طرح کی گئی ہے: \nfib4 (0)-> 0 \nfib4 (1)-> 0 \nفائبر 4 (2)-> 2 \nfib4 (3)-> 0 \nfib4 (n)-> fib4 (n-1) + fib4 (n-2) + fib4 (n-3) + fib4 (n-4)۔ \nبراہ کرم فائب 4 نمبر کی ترتیب کے n-th عنصر کو مؤثر طریقے سے شمار کرنے کے لیے فنکشن لکھیں۔ ریکرشن کا استعمال نہ کریں۔ \n>>> فب 4 (5) \n4. \n>>> فب 4 (6) \n8. \n>>> فب 4 (7) \n14", "natural_language": "Urdu"}
{"task_id": "python/15", "entry_point": "median", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n", "language": "python", "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n", "description": "فہرست ایل میں عناصر کا میڈین واپس کریں۔ \n>>> میڈین ([3، 1، 2، 4، 5]) \n3 \n>>> میڈین ([-10، 4، 6، 1000، 10، 20]) \n15. 0", "natural_language": "Urdu"}
{"task_id": "python/16", "entry_point": "is_palindrome", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n", "description": "چیک کرتا ہے کہ آیا دی گئی سٹرنگ پیلینڈروم ہے \n>>> is _ palindrom (\") ہے \nسچ ہے۔ \n>>> is _ palindrom ('ابا') ہے \nسچ ہے۔ \n>>> is _ palindrom ('aaaaa') ہے \nسچ ہے۔ \n>>> is _ palindrom ('zbcd') ہے \nجھوٹا۔", "natural_language": "Urdu"}
{"task_id": "python/17", "entry_point": "remove_vowels", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n", "language": "python", "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n", "description": "ہٹائیں _ سر ایک فنکشن ہے جو سٹرنگ لیتا ہے اور بغیر سروں کے سٹرنگ واپس کرتا ہے۔ \n>>> سروں کو ہٹا دیں (\") \n\"\n>>> سروں کو ہٹائیں (\"abcdef\\nghijklm\") \n'بی سی ڈی ایف\\این جی ایچ کے ایل ایم'\n>>> سروں کو ہٹا دیں ('اے بی سی ڈی ایف') \n'بی سی ڈی ایف'\n>>> سروں کو ہٹائیں ('aaaaaa') \n\"\n>>> سر ہٹائیں ('آبا') \n'بی'\n>>> سر ہٹائیں ('zbcd') \n'زیز بی سی ڈی'", "natural_language": "Urdu"}
{"task_id": "python/18", "entry_point": "below_threshold", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n", "language": "python", "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n", "description": "اگر فہرست l میں موجود تمام اعداد حد t سے نیچے ہیں تو درست واپس کریں۔ \n>>> نیچے _ حد ([1، 2، 4، 10]، 100) \nسچ ہے۔ \n>>> نیچے _ حد ([1، 20، 4، 10]، 5) \nجھوٹا۔", "natural_language": "Urdu"}
{"task_id": "python/19", "entry_point": "add", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n", "language": "python", "canonical_solution": "    return x + y\n", "description": "دو اعداد x اور y شامل کریں \n>>> شامل کریں (2، 3) \n5. \n>>> شامل کریں (5، 7) \n12", "natural_language": "Urdu"}
{"task_id": "python/20", "entry_point": "same_chars", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n", "language": "python", "canonical_solution": "    return set(s0) == set(s1)\n", "description": "چیک کریں کہ آیا دو الفاظ میں ایک جیسے حروف ہیں۔ \n>>> وہی _ چارز ('eabcdzzzz'،'dddzzzzzuddeddabc') \nسچ ہے۔ \n>>> ایک جیسے حروف ('اے بی سی ڈی'،'ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی \nسچ ہے۔ \n>>> وہی _ چارس ('ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی اے بی سی'،'اے بی سی ڈی') \nسچ ہے۔ \n>>> ایک جیسے حروف ('eabcd'،'ddddddabc') \nجھوٹا۔ \n>>> ایک جیسے حروف ('اے بی سی ڈی'،'ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی ڈی \nجھوٹا۔ \n>>> وہی _ چارز ('eabcdzzzz'،'dddzzzzzdddddabc') \nجھوٹا۔", "natural_language": "Urdu"}
{"task_id": "python/21", "entry_point": "fib", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "description": "n-th فبونیکی نمبر واپس کریں۔ \n>>> فائبر (10) \n55 \n>>> فائبر (1) \n1. \n>>> فائبر (8) \n21", "natural_language": "Urdu"}
{"task_id": "python/22", "entry_point": "common", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n", "language": "python", "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "description": "واپسی نے دو فہرستوں کے لیے منفرد مشترکہ عناصر کو ترتیب دیا۔ \n>>> عام ([1، 4، 3، 34، 653، 2، 5]، [5، 7، 1، 5، 9، 653، 121]) \n[1، 5، 653] \n>>> عام ([5، 3، 2، 8]، [3، 2]) \n[2، 3]", "natural_language": "Urdu"}
{"task_id": "python/23", "entry_point": "largest_prime_factor", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n", "language": "python", "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n", "description": "n کا سب سے بڑا پرائم فیکٹر واپس کریں۔ فرض کریں کہ n> 1 ہے اور یہ پرائم نہیں ہے۔ \n>>> سب سے بڑا _ پرائم _ فیکٹر (13195) \n29 \n>>> سب سے بڑا _ پرائم _ فیکٹر (2048) \n2.", "natural_language": "Urdu"}
{"task_id": "python/24", "entry_point": "sum_to_n", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n", "language": "python", "canonical_solution": "    return sum(range(n + 1))\n", "description": "sum _ to _ n ایک فنکشن ہے جو 1 سے n تک کے نمبروں کا مجموعہ ہے۔ \n>>> sum _ to _ n (30) \n465 \n>>> sum _ to _ n (100) \n5050 \n>>> sum _ to _ n (5) \n15 \n>>> sum _ to _ n (10) \n55 \n>>> sum _ to _ n (1) \n1.", "natural_language": "Urdu"}
{"task_id": "python/25", "entry_point": "derivative", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n", "language": "python", "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n", "description": "xs کسی کثیر الجہتی کے کوفشنٹس کی نمائندگی کرتا ہے۔ \nxs [0] + xs [1] * x + xs [2] * x ^ 2 +.... \nاس کثیر الجہتی کا اسی شکل میں مشتق واپس کریں۔ \n>>> مشتق ([3، 1، 2، 4، 5]) \n[1، 4، 12، 20] \n>>> مشتق ([1، 2، 3]) \n[2، 6]", "natural_language": "Urdu"}
{"task_id": "python/26", "entry_point": "fibfib", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n", "description": "فب فب نمبر سیکوینس فبونیکی سیکوینس سے ملتی جلتی ترتیب ہے جس کی تعریف اس طرح کی گئی ہے: \nfibfib (0) = = 0 \nfibfib (1) = = 0 \nفبفب (2) = = 1 \nfibfib (n) = = fibfib (n-1) + fibfib (n-2) + fibfib (n-3)۔ \nبراہ کرم فائب فائیب نمبر کی ترتیب کے n-th عنصر کو مؤثر طریقے سے شمار کرنے کے لیے ایک فنکشن لکھیں۔ \n>>> فبفب (1) \n0 \n>>> فبفب (5) \n4. \n>>> فبفب (8) \n24", "natural_language": "Urdu"}
{"task_id": "python/27", "entry_point": "vowels_count", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n", "description": "ایک فنکشن ویولز _ کاؤنٹ لکھیں جو ایک سٹرنگ کی نمائندگی کرتا ہے \nایک لفظ بطور ان پٹ اور سٹرنگ میں سروں کی تعداد واپس کرتا ہے۔ \nاس صورت میں آوازیں'a'،'e'،'i'،'o'،'u'ہیں۔ یہاں،'y'بھی a ہے۔ \nسر، لیکن صرف اس صورت میں جب یہ دیئے گئے لفظ کے آخر میں ہو۔ \n\nمثال: \n>>> ویولز _ کاؤنٹ (\"اے بی سی ڈی ای\") \n2. \n>>> ویولز _ کاؤنٹ (\"ACEDY\") \n3", "natural_language": "Urdu"}
{"task_id": "python/28", "entry_point": "search", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n", "language": "python", "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n", "description": "آپ کو مثبت انٹیجرز کی ایک خالی فہرست دی جاتی ہے۔ سب سے بڑا انٹیجر واپس کریں جو اس سے بڑا ہے۔ \nصفر، اور اس کی تعدد خود عدد کی قدر سے زیادہ یا اس کے برابر ہوتی ہے۔ \nکسی عدد کی تعدد وہ تعداد ہے جو فہرست میں ظاہر ہوتی ہے۔ \nاگر ایسی کوئی قیمت موجود نہیں ہے تو-1 واپس کریں۔ \nمثالیں: \nتلاش ([4، 1، 2، 2، 3، 1]) = = 2 \nتلاش ([1، 2، 2، 3، 3، 4، 4]) = = 3 \nتلاش ([5، 5، 4، 4، 4]) = =-1", "natural_language": "Urdu"}
{"task_id": "python/29", "entry_point": "triangle_area", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n", "language": "python", "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n", "description": "مثلث کے تینوں اطراف کی لمبائی کو دیکھتے ہوئے۔ کا رقبہ واپس کریں \nمثلث کو 2 اعشاریہ پوائنٹس پر گول کیا جاتا ہے اگر تینوں اطراف ایک درست مثلث بناتے ہیں۔ \nورنہ واپسی-1 \nتین اطراف ایک درست مثلث بناتے ہیں جب کسی بھی دو اطراف کا مجموعہ زیادہ ہوتا ہے \nتیسری طرف سے. \nمثال: \nمثلث _ رقبہ (3، 4، 5) = = 6 \nمثلث _ رقبہ (1، 2، 10) = =-1", "natural_language": "Urdu"}
{"task_id": "python/30", "entry_point": "will_it_fly", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n", "language": "python", "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n", "description": "ایک فنکشن لکھیں جو سچ کا جواب دے اگر آبجیکٹ q اڑ جائے گا، اور دوسری صورت میں غلط۔ \nآبجیکٹ q اڑ جائے گا اگر یہ متوازن ہو (یہ ایک پیلینڈرومک لسٹ ہے) اور اس کے عناصر کا مجموعہ زیادہ سے زیادہ ممکنہ وزن ڈبلیو سے کم یا اس کے برابر ہو۔ \n\nمثال: \nول _ اٹ _ فلائی ([1، 2]، 5) غلط \n#1 + 2 زیادہ سے زیادہ ممکنہ وزن سے کم ہے، لیکن یہ غیر متوازن ہے۔ \n\nول _ اٹ _ فلائی ([3، 2، 3]، 1) غلط \n#یہ متوازن ہے، لیکن 3 + 2 + 3 زیادہ سے زیادہ ممکنہ وزن سے زیادہ ہے۔ \n\nول _ اٹ _ فلائی ([3، 2، 3]، 9) سچ ہے \n#3 + 2 + 3 زیادہ سے زیادہ ممکنہ وزن سے کم ہے، اور یہ متوازن ہے۔ \n\nول _ اٹ _ فلائی ([3]، 5) سچ ہے \n#3 زیادہ سے زیادہ ممکنہ وزن سے کم ہے، اور یہ متوازن ہے۔", "natural_language": "Urdu"}
{"task_id": "python/31", "entry_point": "is_multiply_prime", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n", "language": "python", "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n", "description": "ایک فنکشن لکھیں جو درست واپسی کرے اگر دیا گیا نمبر 3 پرائم نمبروں کا ضرب ہے۔ \nاور بصورت دیگر غلط۔ \nیہ جاننا کہ (a) 100 سے کم ہے۔ \nمثال: \nکیا _ ضرب _ پرائم (30) = = درست ہے \n30 = 2 * 3 * 5", "natural_language": "Urdu"}
{"task_id": "python/32", "entry_point": "decimal_to_binary", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n", "description": "آپ کو اعشاریہ شکل میں ایک نمبر دیا جائے گا اور آپ کا کام اسے اعشاریہ میں تبدیل کرنا ہے۔ \nبائنری فارمیٹ۔ فنکشن کو ایک سٹرنگ واپس کرنی چاہیے، جس میں ہر حرف بائنری کی نمائندگی کرتا ہے۔ \nنمبر۔ سٹرنگ میں ہر حرف'0'یا'1'ہوگا۔ \n\nسٹرنگ کے شروع میں اور آخر میں چند اضافی حروف'ڈی بی'ہوں گے۔ \nفارمیٹ میں مدد کے لیے اضافی حروف موجود ہیں۔ \n\nمثالیں: \nاعشاریہ _ سے _ بائنری (15) #\"db1111db\" واپس کرتا ہے \nاعشاریہ _ سے _ بائنری (32) #\"db100000db\" واپس کرتا ہے", "natural_language": "Urdu"}
{"task_id": "python/33", "entry_point": "is_happy", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n", "language": "python", "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n", "description": "آپ کو ایک سٹرنگ s دی گئی ہے۔ \nآپ کا کام یہ چیک کرنا ہے کہ تار خوش ہے یا نہیں۔ \nایک تار خوش ہوتا ہے اگر اس کی لمبائی کم از کم 3 ہو اور ہر 3 مسلسل حروف الگ ہوں۔ \nمثال کے طور پر: \nخوش ہے (a) => غلط ہے \nخوش ہے (اے اے) => غلط ہے \nخوش ہے (اے بی سی ڈی) => سچ ہے \nخوش ہے (اے اے بی بی) => غلط \nخوش ہے (ADB) => سچ ہے \nخوش ہے (xyy) => غلط ہے", "natural_language": "Urdu"}
{"task_id": "python/34", "entry_point": "numerical_letter_grade", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "description": "یہ سمسٹر کا آخری ہفتہ ہوتا ہے اور استاد کو گریڈ دینا ہوتے ہیں۔ \nطلباء کے لیے۔ استاد درجہ بندی کے لیے اپنا الگورتھم خود بنا رہے ہیں۔ \nواحد مسئلہ یہ ہے کہ اس نے وہ کوڈ کھو دیا ہے جو اس نے گریڈنگ کے لیے استعمال کیا تھا۔ \nاس نے آپ کو کچھ طلباء کے لیے جی پی اے کی فہرست دی ہے اور آپ کو لکھنا ہے \nایک فنکشن جو درج ذیل ٹیبل کا استعمال کرتے ہوئے لیٹر گریڈ کی فہرست نکال سکتا ہے: \nجی پی اے۔ لیٹر گریڈ \n4. 0 اے + \n> 3. 7 اے \n> 3. 3 اے-\n> 3. 0 بی + \n> 2. 7 بی \n> 2. 3 بی-\n> 2. 0 سی + \n> 1. 7 سی \n> 1. 3 سی-\n> 1. 0 ڈی + \n> 0. 7 ڈی \n> 0. 0 ڈی-\n0. 0 ای \n\nمثال: \nگریڈ _ مساوات ([4. 0, 3, 1.7, 2, 3. 5]) = => ['A +','B','C-','C','A -']", "natural_language": "Urdu"}
{"task_id": "python/35", "entry_point": "prime_length", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n", "language": "python", "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "description": "ایک فنکشن لکھیں جو سٹرنگ لے اور ٹرو واپس کرے اگر سٹرنگ \nلمبائی ایک پرائم نمبر ہے یا بصورت دیگر غلط \nمثالیں \nپرائم _ لمبائی ('ہیلو') = = درست \nپرائم _ لینتھ ('اے بی سی ڈی سی بی اے') = = درست \nپرائم _ لمبائی ('بلی کے بچے') = = درست \nپرائم _ لمبائی ('نارنجی') = = غلط", "natural_language": "Urdu"}
{"task_id": "python/36", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n", "language": "python", "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n", "description": "ایک مثبت عدد N کو دیکھتے ہوئے، اس کے ہندسوں کا کل مجموعہ بائنری میں واپس کریں۔ \n\nمثال \nN = 1000 کے لیے، ہندسوں کا مجموعہ 1 ہوگا اور آؤٹ پٹ \"1\" ہونا چاہیے۔ \nN = 150 کے لیے، ہندسوں کا مجموعہ 6 ہوگا اور آؤٹ پٹ \"110\" ہونا چاہیے۔ \nN = 147 کے لیے، ہندسوں کا مجموعہ 12 ہوگا اور آؤٹ پٹ \"1100\" ہونا چاہیے۔ \n\nمتغیرات: \n@N عدد \nرکاوٹیں: 0 ≤ N ≤ 10000۔ \nآؤٹ پٹ: \nبائنری نمبر کا ایک سٹرنگ", "natural_language": "Urdu"}
{"task_id": "python/37", "entry_point": "get_row", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "description": "آپ کو ایک 2 جہتی ڈیٹا دیا جاتا ہے، بطور نیسٹڈ لسٹس، \nجو میٹرکس سے ملتا جلتا ہے، تاہم، میٹرکس کے برعکس، \nہر صف میں کالموں کی ایک مختلف تعداد ہو سکتی ہے۔ \nlst، اور عدد x کو دیکھتے ہوئے، فہرست میں عدد x تلاش کریں، \nاور ٹپل کی واپسی کی فہرست، [(x1, y1), (x2, y2)...] اس طرح کہ \nہر ٹپل ایک کوآرڈینیٹ ہے-(صف، کالم)، جو 0 سے شروع ہوتا ہے۔ \nکوآرڈینیٹس کو ابتدائی طور پر قطاروں کے لحاظ سے چڑھتے ہوئے ترتیب میں ترتیب دیں۔ \nنیز، قطار کے نقاط کو کالموں کے لحاظ سے نزولی ترتیب میں ترتیب دیں۔ \n\nمثالیں: \nحاصل کرو ([\n[1,2,3، 4,5,6]، \n[1,2,3، 4,1,6]، \n[1,2,3، 4,5,1] \n]، 1) = = [(0، 0)، (1، 4)، (1، 0)، (2، 5)، (2، 0)] \nحاصل کرو ([]، 1) = = [] \nحاصل کرو ([[]، [1]، [1، 2، 3]]، 3) = = [(2، 2)]", "natural_language": "Urdu"}
{"task_id": "python/38", "entry_point": "next_smallest", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "description": "آپ کو انٹیجرز کی فہرست دی جاتی ہے۔ \nایک فنکشن نیکسٹ _ لیسٹسٹ () لکھیں جو فہرست کا دوسرا سب سے چھوٹا عنصر واپس کرے۔ \nاگر ایسا کوئی عنصر نہیں ہے تو کالعدم واپس کریں۔ \n\nاگلا _ سب سے چھوٹا ([1، 2، 3، 4، 5]) = = 2 \nاگلا _ سب سے چھوٹا ([5، 1، 4، 3، 2]) = = 2 \nاگلا _ سب سے چھوٹا ([]) = = کوئی نہیں \nاگلا _ سب سے چھوٹا ([1, 1]) = = کوئی نہیں", "natural_language": "Urdu"}
{"task_id": "python/39", "entry_point": "is_bored", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "description": "آپ کو الفاظ کی ایک تار دی جائے گی، اور آپ کا کام تعداد شمار کرنا ہے \nبوریت۔ بوریت ایک جملہ ہے جو لفظ \"میں\" سے شروع ہوتا ہے۔ \nجملوں کی حد بندی '.'،'؟'یا '!'سے کی جاتی ہے۔ \n\nمثال کے طور پر: \n>>> ہے _ بور (\"ہیلو ورلڈ\") \n0 \n>>> بور ہے (\"آسمان نیلا ہے۔ سورج چمک رہا ہے۔ مجھے یہ موسم پسند ہے\") \n1.", "natural_language": "Urdu"}
{"task_id": "python/40", "entry_point": "skjkasdkd", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n", "language": "python", "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "description": "آپ کو انٹیجرز کی فہرست دی جاتی ہے۔ \nآپ کو سب سے بڑی پرائم ویلیو تلاش کرنے اور اس کے ہندسوں کا مجموعہ واپس کرنے کی ضرورت ہے۔ \n\nمثالیں: \nlst = [0,3,2، 1,3,5، 7,4,5، 5,5,2، 181,32,4، 32,3,2، 32,324,4، 3] کے لیے آؤٹ پٹ 10 ہونا چاہیے۔ \nlst = [1,0,1، 8,2,4597، 2,1,3، 40,1,2، 1,2,4، 2,5,1] کے لیے آؤٹ پٹ 25 ہونا چاہیے۔ \nlst = [1,3,1، 32,5107,34، 83278,109,163، 23,2323,32، 30,1,9، 3] کے لیے آؤٹ پٹ 13 ہونا چاہیے۔ \nlst = [0,724,32، 71,99,32، 6,0,5، 91,83,0، 5, 6] کے لیے آؤٹ پٹ 11 ہونا چاہیے۔ \nlst = [0,81,12، 3,1,21] کے لیے آؤٹ پٹ 3 ہونا چاہیے۔ \nlst = [0,8,1، 2,1,7] کے لیے آؤٹ پٹ 7 ہونا چاہیے۔", "natural_language": "Urdu"}
{"task_id": "python/41", "entry_point": "check_dict_case", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n", "language": "python", "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n", "description": "لغت دی گئی ہے، اگر تمام چابیاں نچلے حصے میں تار ہیں تو سچ واپس کریں \nکیس یا تمام چابیاں اپر کیس میں سٹرنگ ہیں، ورنہ فالس واپس کریں۔ \nفنکشن لوٹنا چاہیے غلط ہے کہ دی گئی لغت خالی ہے۔ \nمثالیں: \nچیک _ ڈکٹ _ کیس ({\"a\": \"سیب\"، \"b\": \"کیلا\"}) کو درست ہونا چاہیے۔ \nچیک _ ڈکٹ _ کیس ({\"a\": \"سیب\"، \"A\": \"کیلا\"، \"B\": \"کیلا\"}) کو غلط واپس کرنا چاہیے۔ \nچیک _ ڈکٹ _ کیس ({\"a\": \"سیب\"، 8: \"کیلا\"، \"a\": \"سیب\"}) کو غلط واپس کرنا چاہیے۔ \nچیک _ ڈکٹ _ کیس ({\"نام\": \"جان\"، \"ایج\": \"36\"، \"سٹی\": \"ہیوسٹن\"}) کو فالس واپس کرنا چاہیے۔ \nچیک _ ڈکٹ _ کیس ({\"اسٹیٹ\": \"این سی\"، \"زپ\": \"12345\"}) کو درست ہونا چاہیے۔", "natural_language": "Urdu"}
{"task_id": "python/42", "entry_point": "closest_integer", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n", "language": "python", "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "description": "ایک فنکشن بنائیں جو ایک نمبر کی نمائندگی کرنے والی قدر (سٹرنگ) لیتا ہے \nاور اس کے قریب ترین عدد واپس کرتا ہے۔ اگر عدد مساوی فاصلے پر ہے \nدو انٹیجرز سے، اسے صفر سے دور گول کریں۔ \n\nمثالیں \n>>> قریب ترین عدد (\"10\") \n10. \n>>> قریب ترین عدد (\"15. 3\") \n15 \n\nنوٹ: \nصفر سے دور گول کرنے کا مطلب ہے کہ اگر دیا ہوا نمبر مساوی فاصلے پر ہے \nدو انٹیجرز میں سے، جو آپ کو واپس کرنا چاہیے وہ وہی ہے جو \nصفر سے سب سے دور۔ مثال کے طور پر قریب ترین عدد (\"14. 5\") ہونا چاہیے۔ \n15 واپس کریں اور قریب ترین عدد (\"-14. 5\") کو-15 واپس کرنا چاہیے۔", "natural_language": "Urdu"}
{"task_id": "python/43", "entry_point": "make_a_pile", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return [n + 2*i for i in range(n)]\n", "description": "ایک مثبت عدد n کو دیکھتے ہوئے، آپ کو پتھروں کی n سطحوں کا ڈھیر بنانا ہوگا۔ \nپہلی سطح پر این پتھر ہیں۔ \nاگلی سطح پر پتھروں کی تعداد یہ ہے: \n- اگلا عجیب عدد اگر n عجیب ہے۔ \n- اگلا یکساں عدد اگر n یکساں ہو۔ \nفہرست میں ہر سطح پر پتھروں کی تعداد واپس کریں، جہاں اشاریہ پر عنصر ہے \ni سطح میں پتھروں کی تعداد کی نمائندگی کرتا ہے (i + 1)۔ \n\nمثالیں: \n>>> بناؤ _ a _ ڈھیر (3) \n[3، 5، 7]", "natural_language": "Urdu"}
{"task_id": "python/44", "entry_point": "words_string", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n", "language": "python", "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n", "description": "آپ کو الفاظ کی ایک تار دی جائے گی جسے کوما یا خالی جگہوں سے الگ کیا جائے گا۔ آپ کا کام ہے \nسٹرنگ کو الفاظ میں تقسیم کرنا اور الفاظ کی ایک صف واپس کرنا۔ \n\nمثال کے طور پر: \nالفاظ _ سٹرنگ (\"ہیلو، میرا نام جان ہے\") = = [\"ہیلو\"، \"میرا\"، \"نام\"، \"ہے\"، \"جان\"] \nالفاظ _ سٹرنگ (\"ایک، دو، تین، چار، پانچ، چھ\") = = [\"ایک\"، \"دو\"، \"تین\"، \"چار\"، \"پانچ\"، \"چھ\"]", "natural_language": "Urdu"}
{"task_id": "python/45", "entry_point": "choose_num", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n", "language": "python", "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n", "description": "یہ فنکشن دو مثبت اعداد x اور y لیتا ہے اور واپس کرتا ہے \nسب سے بڑا یکساں عدد جو [x, y] کی حد میں ہے۔ اگر \nایسا کوئی نمبر نہیں ہے، پھر فنکشن-1 واپس آنا چاہیے۔ \n\nمثال کے طور پر: \nچنئے _ num (12، 15) = 14 \nچنئے _ num (13، 12) =-1", "natural_language": "Urdu"}
{"task_id": "python/46", "entry_point": "rounded_avg", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n", "language": "python", "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "description": "آپ کو دو مثبت عدد n اور m دیے گئے ہیں، اور آپ کا کام حساب لگانا ہے \nn سے m تک کے انٹیجرز کی اوسط (بشمول n اور m)۔ \nقریب ترین عدد کے جواب کو گول کریں اور اسے بائنری میں تبدیل کریں۔ \nاگر n، m سے بڑا ہے، تو-1 واپس کریں۔ \nمثال: \nگول _ اے وی جی (1، 5) => \"0b11\" \nگول _ اے وی جی (7، 5) =>-1 \nگول _ اے وی جی (10، 20) => \"0b1111\" \nگول _ اے وی جی (20، 33) => \"0b11010\"", "natural_language": "Urdu"}
{"task_id": "python/47", "entry_point": "f", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n", "language": "python", "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n", "description": "فنکشن f کو لاگو کریں جو n کو پیرامیٹر کے طور پر لیتا ہے، \nاور سائز n کی فہرست واپس کرتا ہے، اس طرح کہ انڈیکس i پر عنصر کی قیمت i کی فیکٹوریئل ہے اگر i مساوی ہے \nیا 1 سے i تک کے اعداد کا مجموعہ۔ \nمیں 1 سے شروع کرتا ہوں۔ \ni کا فیکٹوریئل 1 سے i (1 * 2 *... * i) تک کے اعداد کا ضرب ہے۔ \nمثال: \nf (5) = = [1، 2، 6، 24، 15]", "natural_language": "Urdu"}
{"task_id": "python/48", "entry_point": "even_odd_palindrome", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n", "description": "ایک مثبت عدد n کو دیکھتے ہوئے، ایک ٹپل واپس کریں جس کی تعداد یکساں اور طاق ہو۔ \nانٹیجر پیلینڈروم جو (1، n) کی حد میں آتے ہیں، بشمول۔ \n\nمثال 1: \n\nان پٹ: 3 \nپیداوار: (1، 2) \nوضاحت: \nانٹیجر پیلینڈروم 1، 2، 3 ہیں۔ ان میں سے ایک یکساں ہے، اور ان میں سے دو عجیب ہیں۔ \n\nمثال 2: \n\nان پٹ: 12 \nپیداوار: (4، 6) \nوضاحت: \nانٹیجر پیلینڈروم 1، 2، 3، 4، 5، 6، 7، 8، 9، 11 ہیں۔ ان میں سے چار یکساں ہیں، اور ان میں سے 6 عجیب ہیں۔ \n\nنوٹ: \n1. 1 <= n <= 10 ^ 3 \n2۔ واپس آنے والے ٹپل میں بالترتیب یکساں اور عجیب عدد پیلینڈروم کی تعداد ہوتی ہے۔", "natural_language": "Urdu"}
{"task_id": "python/49", "entry_point": "move_one_ball", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n", "language": "python", "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n", "description": "ہمارے پاس N انٹیجرز arr [1]، arr [2]،...، arr [N] کی ایک صف'arr'ہے۔ \nصف میں نمبروں کو تصادفی طور پر ترتیب دیا جائے گا۔ آپ کا کام اس بات کا تعین کرنا ہے کہ آیا \nکارکردگی کا مظاہرہ کرکے غیر کم ہونے والی ترتیب میں صف بندی کرنا ممکن ہے \nدی گئی صف پر درج ذیل عمل: \nآپ کو کسی بھی وقت صحیح شفٹ آپریشن کرنے کی اجازت ہے۔ \n\nون رائٹ شفٹ آپریشن کا مطلب ہے صف کے تمام عناصر کو ایک سے منتقل کرنا۔ \nصحیح سمت میں پوزیشن۔ صف کے آخری عنصر کو منتقل کر دیا جائے گا \nصف میں ابتدائی پوزیشن یعنی 0 ویں انڈیکس۔ \n\nاگر مذکورہ بالا آپریشن انجام دے کر ترتیب شدہ صف حاصل کرنا ممکن ہے \nپھر سچ واپس کریں ورنہ غلط واپس کریں۔ \nاگر دی گئی صف خالی ہے تو ٹرو واپس کریں۔ \n\nنوٹ: دی گئی فہرست میں منفرد عناصر ہونے کی ضمانت ہے۔ \n\nمثال کے طور پر: \n\nمنتقل _ ایک _ گیند ([3، 4، 5، 1، 2]) = => درست \nوضاحت: 2 دائیں شفٹ کی کارروائیوں میں کارکردگی کا مظاہرہ کرنے سے، غیر کم ہونے والا آرڈر کر سکتا ہے \nدی گئی صف کے لیے حاصل کیا جائے۔ \nموو _ ون _ بال ([3، 5، 4، 1، 2]) = => غلط \nوضاحت: دیئے گئے آرڈر کے لیے نان ڈکریزنگ آرڈر حاصل کرنا ممکن نہیں ہے۔ \nکسی بھی تعداد میں صحیح شفٹ آپریشن انجام دے کر صف۔", "natural_language": "Urdu"}
{"task_id": "python/50", "entry_point": "exchange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n", "language": "python", "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n", "description": "اس مسئلے میں، آپ ایک فنکشن نافذ کریں گے جو نمبروں کی دو فہرستیں لیتا ہے، \nاور اس بات کا تعین کرتا ہے کہ آیا عناصر کا تبادلہ کرنا ممکن ہے \nان کے درمیان lst1 کو صرف یکساں اعداد کی فہرست بنانے کے لیے۔ \nlst1 اور lst2 کے درمیان تبادلے شدہ عناصر کی تعداد کی کوئی حد نہیں ہے۔ \nاگر lst1 اور lst2 کے درمیان عناصر کا تبادلہ کرنا ممکن ہے \nlst1 کے تمام عناصر کو یکساں ہونے کے لیے، \"ہاں\" واپس کریں۔ \nورنہ \"نہیں\" واپس کریں۔ \nمثال کے طور پر: \nتبادلہ ([1، 2، 3، 4]، [1، 2، 3، 4]) => \"ہاں\" \nتبادلہ ([1، 2، 3، 4]، [1، 5، 3، 4]) => \"نہیں\" \nیہ فرض کیا جاتا ہے کہ ان پٹ فہرستیں خالی نہیں ہوں گی۔", "natural_language": "Urdu"}
{"task_id": "python/51", "entry_point": "reverse_delete", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n", "language": "python", "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n", "description": "کام \nہمیں دو تار s اور c دیے گئے ہیں، آپ کو s کے تمام حروف کو حذف کرنا ہوگا جو c کے کسی بھی کردار کے برابر ہیں۔ \nپھر چیک کریں کہ آیا نتیجہ کا سٹرنگ پیلینڈروم ہے۔ \nایک تار کو پیلینڈروم کہا جاتا ہے اگر یہ آگے کی طرح پیچھے کی طرف پڑھتا ہے۔ \nآپ کو ایک ٹپل واپس کرنا چاہیے جس میں نتیجہ کی تار اور چیک کے لیے درست/غلط ہو۔ \nمثال \nایس = \"اے بی سی ڈی\"، سی = \"اے ای\" کے لیے نتیجہ ہونا چاہیے ('بی سی ڈی'، غلط) \ns = \"abcdef\" کے لیے، c = \"b\" نتیجہ ہونا چاہیے ('acdef'، غلط) \ns = \"abcdedcba\"، c = \"ab\" کے لیے نتیجہ ہونا چاہیے ('cdedc'، سچ)", "natural_language": "Urdu"}
{"task_id": "python/52", "entry_point": "max_fill", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n", "language": "python", "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n", "description": "آپ کو کنوؤں کا ایک آئتاکار گرڈ دیا جاتا ہے۔ ہر قطار ایک کنویں کی نمائندگی کرتی ہے، \nاور ایک صف میں ہر 1 پانی کی ایک اکائی کی نمائندگی کرتا ہے۔ \nہر کنویں میں ایک متعلقہ بالٹی ہوتی ہے جسے اس سے پانی نکالنے کے لیے استعمال کیا جا سکتا ہے۔ \nاور تمام بالٹیوں کی صلاحیت ایک جیسی ہوتی ہے۔ \nآپ کا کام کنویں خالی کرنے کے لیے بالٹیوں کا استعمال کرنا ہے۔ \nجتنی بار آپ کو بالٹیاں کم کرنے کی ضرورت ہے اس کی تعداد کا تعین کریں۔ \n\nمثال 1: \nان پٹ: \nگرڈ: [[0,0,1، 0]، [0,1,0، 0]، [1,1,1، 1] \nبالٹی کی صلاحیت (_ c): 1 \nپیداوار: 6 \n\nمثال 2: \nان پٹ: \nگرڈ: [[0، 0,1,1]، [0,0,0، 0]، [1,1,1، 1]، [0,1,1، 1] \nبالٹی کی صلاحیت: 2 \nپیداوار: 5 \n\nمثال 3: \nان پٹ: \nگرڈ: [[0,0,0]، [0,0,0] \nبالٹی کی صلاحیت: 5 \nآؤٹ پٹ: 0 \n\nرکاوٹیں: \n* تمام کنوؤں کی لمبائی ایک جیسی ہوتی ہے \n* 1 <= grid.length <= 10 ^ 2 \n* 1 <= گرڈ [:، 1]. لمبائی <= 10 ^ 2 \nگرڈ [i] [j]-> 0 | 1 \n* 1 <= صلاحیت <= 10", "natural_language": "Urdu"}
{"task_id": "python/53", "entry_point": "select_words", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n", "language": "python", "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n", "description": "سٹرنگ s اور قدرتی نمبر n کو دیکھتے ہوئے، آپ کو عمل درآمد کرنے کا کام سونپا گیا ہے۔ \nایک فنکشن جو سٹرنگ s سے تمام الفاظ کی فہرست واپس کرتا ہے جس میں بالکل \nn مخطوطات، ترتیب میں یہ الفاظ سٹرنگ s میں ظاہر ہوتے ہیں۔ \nاگر سٹرنگ s خالی ہے تو فنکشن کو ایک خالی فہرست واپس کرنی چاہیے۔ \nنوٹ: آپ فرض کر سکتے ہیں کہ ان پٹ سٹرنگ میں صرف حروف اور خالی جگہیں ہیں۔ \nمثالیں: \nسلیکٹ _ ورڈز (\"مریم کے پاس ایک چھوٹا بھیڑ تھا\"، 4) = => [\"چھوٹا\"] \nمنتخب _ الفاظ (\"مریم کا ایک چھوٹا بھیڑ تھا\"، 3) = => [\"مریم\"، \"بھیڑ\"] \nسلیکٹ _ ورڈز (\"سادہ سفید جگہ\"، 2) = => [] \nسلیکٹ _ ورڈز (\"ہیلو ورلڈ\"، 4) = => [\"ورلڈ\"] \nسلیکٹ _ ورڈز (\"انکل سیم\"، 3) = => [\"انکل\"]", "natural_language": "Urdu"}
{"task_id": "python/54", "entry_point": "maximum", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n", "language": "python", "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n", "description": "انٹیجرز کی ایک صف arr اور ایک مثبت عدد k کو دیکھتے ہوئے، ایک ترتیب شدہ فہرست واپس کریں \narr میں زیادہ سے زیادہ k نمبروں کے ساتھ لمبائی k کا۔ \n\nمثال 1: \n\nان پٹ: arr = [-3،-4، 5]، k = 3 \nپیداوار: [-4،-3، 5] \n\nمثال 2: \n\nان پٹ: arr = [4،-4، 4]، k = 2 \nپیداوار: [4, 4] \n\nمثال 3: \n\nان پٹ: arr = [-3، 2، 1، 2،-1،-2، 1]، k = 1 \nپیداوار: [2] \n\nنوٹ: \nصف کی لمبائی [1, 1000] کی حد میں ہوگی۔ \nصف میں موجود عناصر [-1000, 1000] کی حد میں ہوں گے۔ \n3. 0 <= k <= لین (arr)", "natural_language": "Urdu"}
{"task_id": "python/55", "entry_point": "add_elements", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n", "description": "انٹیجرز arr اور ایک انٹیجر k کی غیر خالی صف کو دیکھتے ہوئے، واپس کریں \narr کے پہلے k عناصر سے زیادہ سے زیادہ دو ہندسوں والے عناصر کا مجموعہ۔ \n\nمثال: \n\nان پٹ: arr = [111,21,3، 4000,5,6، 7,8,9]، k = 4 \nآؤٹ پٹ: 24 #21 + 3 کا مجموعہ \n\nرکاوٹیں: \n1. 1 <= لین (آر آر) <= 100 \n2. 1 <= k <= لین (arr)", "natural_language": "Urdu"}
{"task_id": "python/56", "entry_point": "intersection", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n", "language": "python", "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n", "description": "آپ کو دو وقفے دیے جاتے ہیں، \nجہاں ہر وقفہ عدد کا ایک جوڑا ہے۔ مثال کے طور پر، وقفہ = (آغاز، اختتام) = (1، 2)۔ \nدیئے گئے وقفے بند ہیں جس کا مطلب ہے کہ وقفہ (آغاز، اختتام) \nاس میں آغاز اور اختتام دونوں شامل ہیں۔ \nہر وقفے کے لیے یہ فرض کیا جاتا ہے کہ اس کا آغاز اس کے اختتام سے کم یا برابر ہے۔ \nآپ کا کام اس بات کا تعین کرنا ہے کہ آیا ان دونوں کے چوراہے کی لمبائی کتنی ہے \nوقفہ ایک پرائم نمبر ہے۔ \nمثال کے طور پر، وقفوں کا چوراہا (1، 3)، (2، 4) ہے (2، 3) \nجس کی لمبائی 1 ہے، جو پرائم نمبر نہیں ہے۔ \nاگر چوراہے کی لمبائی ایک پرائم نمبر ہے، تو \"ہاں\" واپس کریں، \nورنہ \"نہیں\" واپس کریں۔ \nاگر دونوں وقفے ایک دوسرے کو نہیں کاٹتے ہیں، تو \"نہیں\" واپس کریں۔ \n\n[ان پٹ/آؤٹ پٹ] نمونے: \nچوراہا ((1، 2)، (2، 3)) = => \"نہیں\" \nچوراہا ((-1، 1)، (0، 4)) = => \"نہیں\" \nچوراہا (-3،-1)، (-5، 5)) = => \"ہاں\"", "natural_language": "Urdu"}
{"task_id": "python/57", "entry_point": "tri", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n", "language": "python", "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n", "description": "ہر کوئی فبونیکی ترتیب کو جانتا ہے، اس کا ریاضی دانوں نے گہرائی سے مطالعہ کیا تھا \nپچھلی دو صدیوں۔ تاہم، جو لوگ نہیں جانتے وہ ٹربوناچی ترتیب ہے۔ \nٹرائبوناکسی ترتیب کی تعریف تکرار سے کی جاتی ہے: \nتری (1) = 3 \nمثلث (n) = 1 + n/2، اگر n مساوی ہو۔ \nاگر n عجیب ہے تو سہ رخی (n) = سہ رخی (n-1) + سہ رخی (n-2) + سہ رخی (n + 1)۔ \nمثال کے طور پر: \nمثلث (2) = 1 + (2/2) = 2 \nتری (4) = 3 \nٹرائی (3) = ٹرائی (2) + ٹرائی (1) + ٹرائی (4) \n= 2 + 3 + 3 = 8 \nآپ کو ایک غیر منفی عدد نمبر n دیا جاتا ہے، آپ کو اس کی فہرست واپس کرنی ہوگی \nٹربونیکی ترتیب کے پہلے n + 1 نمبر۔ \nمثالیں: \nتری (3) = [1، 3، 2، 8]", "natural_language": "Urdu"}
{"task_id": "python/58", "entry_point": "digits", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n", "language": "python", "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n", "description": "مثبت عدد n کو دیکھتے ہوئے، عجیب ہندسوں کا پروڈکٹ واپس کریں۔ \n0 واپس کریں اگر تمام ہندسے یکساں ہوں۔ \nمثال کے طور پر: \nہندسوں (1) = = 1 \nہندسوں (4) = = 0 \nہندسوں (235) = = 15", "natural_language": "Urdu"}
{"task_id": "python/59", "entry_point": "is_nested", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n", "language": "python", "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n", "description": "ایک فنکشن بنائیں جو ایک سٹرنگ کو ان پٹ کے طور پر لے جس میں صرف مربع بریکٹ ہوں۔ \nفنکشن کو ٹرو واپس کرنا چاہیے اگر اور صرف اس صورت میں جب بریکٹ کا درست تسلسل ہو۔ \nجہاں بعد میں کم از کم ایک بریکٹ کو گھونسلہ بنایا جاتا ہے۔ \n\nis _ nested ('[[]]') سچ ہے \nis _ nested ('[]]]]] [[[[]') غلط ہے \nis _ nested ('[] []') غلط ہے \nis _ nested ('[]') غلط ہے \nis _ nested ('[[] []]') سچ ہے \nis _ nested ('[[]] [[') سچ ہے", "natural_language": "Urdu"}
{"task_id": "python/60", "entry_point": "sum_squares", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n", "description": "آپ کو نمبروں کی فہرست دی جاتی ہے۔ \nآپ کو دی گئی فہرست میں مربع نمبروں کا مجموعہ واپس کرنے کی ضرورت ہے، \nفہرست میں ہر عنصر کو پہلے اوپری انٹ (چھت) پر گول کریں۔ \nمثالیں: \nlst = [1,2,3] کے لیے آؤٹ پٹ 14 ہونا چاہیے۔ \nlst = [1,4,9] کے لیے آؤٹ پٹ 98 ہونا چاہیے۔ \nlst = [1,3,5، 7] کے لیے آؤٹ پٹ 84 ہونا چاہیے۔ \nlst = [1.4,4.2، 0] کے لیے آؤٹ پٹ 29 ہونا چاہیے۔ \nlst = [-2.4,1، 1] کے لیے آؤٹ پٹ 6 ہونا چاہیے۔", "natural_language": "Urdu"}
{"task_id": "python/61", "entry_point": "check_if_last_char_is_a_letter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n", "description": "ایک فنکشن بنائیں جو آخری حرف کی صورت میں ٹرو واپس کرے \nدی گئی سٹرنگ کا حروف تہجی ہے اور نہیں ہے \nلفظ کا ایک حصہ، اور دوسری صورت میں غلط۔ \nنوٹ: \"لفظ\" حروف کا ایک مجموعہ ہے جو خلا سے الگ ہوتا ہے۔ \n\nمثالیں: \nچیک کریں _ اگر _ آخری _ چار _ ہے _ a _ حرف (\"ایپل پائی\") غلط \nچیک کریں _ اگر _ آخری _ چار _ ہے _ a _ حرف (\"ایپل پائی ای\") سچ ہے \nچیک کریں _ اگر _ آخری _ چار _ ہے _ a _ حرف (\"ایپل پائی ای\") غلط \nچیک کریں _ اگر _ آخری _ چار _ ہے _ a _ حرف (\"\") غلط", "natural_language": "Urdu"}
{"task_id": "python/62", "entry_point": "can_arrange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n", "language": "python", "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n", "description": "ایک فنکشن بنائیں جو کسی عنصر کا سب سے بڑا انڈیکس واپس کرے جو \nاس سے فوری طور پر پہلے والے عنصر سے بڑا یا برابر نہیں ہے۔ اگر \nایسا کوئی عنصر موجود نہیں ہے تو واپسی-1۔ دی گئی صف پر مشتمل نہیں ہوگا \nڈپلیکیٹ ویلیوز۔ \n\nمثالیں: \ncan _ अरेंज کر سکتے ہیں ([1,2,4، 3, 5]) = 3 \ncan _ अरेंज کر سکتے ہیں ([1,2,3]) =-1", "natural_language": "Urdu"}
{"task_id": "python/63", "entry_point": "largest_smallest_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "language": "python", "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "description": "ایک فنکشن بنائیں جو ٹپل (a، b) واپس کرے، جہاں'a'ہے \nمنفی عددوں میں سب سے بڑا، اور'b'سب سے چھوٹا ہے \nفہرست میں مثبت عدد۔ \nاگر کوئی منفی یا مثبت عدد نہیں ہیں، تو انہیں None کے طور پر واپس کریں۔ \n\nمثالیں: \nسب سے بڑے _ چھوٹے _ عدد ([2، 4، 1، 3، 5، 7]) = = (کوئی نہیں، 1) \nسب سے بڑے _ چھوٹے _ عدد ([]) = = (کوئی نہیں، کوئی نہیں) \nسب سے بڑے _ چھوٹے _ عدد ([0]) = = (کوئی نہیں، کوئی نہیں)", "natural_language": "Urdu"}
{"task_id": "python/64", "entry_point": "special_factorial", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n", "language": "python", "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "description": "برازیلی فیکٹوریئل کی تعریف اس طرح کی گئی ہے: \nبرازیلین _ فیکٹوریئل (n) = n! * (n-1)! * (n-2)! *... * 1! \nجہاں n> 0 \n\nمثال کے طور پر: \n>>> اسپیشل _ فیکٹوریئل (4) \n288 \n\nفنکشن کو ان پٹ کے طور پر ایک انٹیجر ملے گا اور اسے خصوصی واپس کرنا چاہیے \nاس عدد کا فیکٹوریئل۔", "natural_language": "Urdu"}
{"task_id": "python/65", "entry_point": "words_in_sentence", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n", "language": "python", "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n", "description": "آپ کو ایک سٹرنگ دی جاتی ہے جو کسی جملے کی نمائندگی کرتی ہے، \nجملے میں کچھ الفاظ ہوتے ہیں جو ایک جگہ سے الگ ہوتے ہیں، \nاور آپ کو ایک تار واپس کرنا ہوگا جس میں اصل جملے کے الفاظ شامل ہوں، \nجن کی لمبائی پرائم نمبرز ہیں، \nنئے سٹرنگ میں الفاظ کی ترتیب اصل کی طرح ہی ہونی چاہیے۔ \n\nمثال 1: \nان پٹ: جملہ = \"یہ ایک امتحان ہے\" \nآؤٹ پٹ: \"ہے\" \n\nمثال 2: \nان پٹ: جملہ = \"چلو تیراکی کے لیے چلیں\" \nآؤٹ پٹ: \"کے لیے جائیں\" \n\nرکاوٹیں: \n* 1 <= لین (جملہ) <= 100 \n* جملے میں صرف حروف ہوتے ہیں", "natural_language": "Urdu"}
{"task_id": "python/66", "entry_point": "simplify", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n", "language": "python", "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n", "description": "آپ کا کام ایک فنکشن کو نافذ کرنا ہے جو اظہار کو آسان بنائے گا \nx * n۔ فنکشن درست واپس کرتا ہے اگر x * n کسی پورے نمبر کا اندازہ کرتا ہے اور غلط \nبصورت دیگر۔ x اور n دونوں، ایک فریکشن کی سٹرنگ نمائندگی ہیں، اور ان کی شکل درج ذیل ہے، \n<numerator> <ڈینومینیٹر> جہاں numerator اور ڈینومینیٹر دونوں مثبت مکمل اعداد ہیں۔ \n\nآپ فرض کر سکتے ہیں کہ x، اور n درست فریکشن ہیں، اور ان میں ڈینومینیٹر کے طور پر صفر نہیں ہے۔ \n\nآسان بنائیں (\"1/5\"، \"5/1\") = درست \nآسان بنائیں (\"1/6\"، \"2/1\") = غلط \nآسان بنائیں (\"7/10\"، \"10/2\") = غلط", "natural_language": "Urdu"}
{"task_id": "python/67", "entry_point": "order_by_points", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n", "description": "ایک فنکشن لکھیں جو انٹیجرز کی دی گئی فہرست کو ترتیب دے \nان کے ہندسوں کے مجموعے کے مطابق چڑھتے ہوئے ترتیب میں۔ \nنوٹ: اگر کئی آئٹمز ہیں جن کے ہندسوں کا مجموعہ ایک جیسا ہے، \nاصل فہرست میں ان کے اشاریہ کی بنیاد پر انہیں آرڈر کریں۔ \n\nمثال کے طور پر: \n>>> آرڈر _ بائی _ پوائنٹس ([1، 11،-1،-11،-12]) = = [-1،-11، 1،-12، 11] \n>>> آرڈر _ بائی _ پوائنٹس ([]) = = []", "natural_language": "Urdu"}
{"task_id": "python/68", "entry_point": "specialFilter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n", "language": "python", "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n", "description": "ایک فنکشن لکھیں جو نمبروں کی صف کو ان پٹ اور ریٹرن کے طور پر لے \nصف میں عناصر کی تعداد جو 10 سے زیادہ ہے اور دونوں \nکسی عدد کے پہلے اور آخری ہندسے عجیب ہوتے ہیں (1، 3، 5، 7، 9)۔ \nمثال کے طور پر: \nاسپیشل فلٹر ([15،-73، 14،-15]) => 1 \nاسپیشل فلٹر ([33،-2،-3، 45، 21، 109]) => 2", "natural_language": "Urdu"}
{"task_id": "python/69", "entry_point": "get_max_triples", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n", "language": "python", "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n", "description": "آپ کو ایک مثبت عدد n دیا جاتا ہے۔ آپ کو n لمبائی کا ایک عدد صف a بنانا ہوگا۔ \nہر ایک i (1 ≤ i ≤ n) کے لیے، a [i] = i * i-i + 1 کی قدر۔ \na کے تین گنا (a [i]، a [j]، a [k]) کی تعداد واپس کریں جہاں i <j <k، \nاور a [i] + a [j] + a [k] 3 کا ضرب ہے۔ \n\nمثال: \nان پٹ: n = 5 \nپیداوار: 1 \nوضاحت: \na = [1، 3، 7، 13، 21] \nواحد درست ٹرپل (1، 7، 13) ہے۔", "natural_language": "Urdu"}
{"task_id": "python/70", "entry_point": "bf", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n", "language": "python", "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n", "description": "ہمارے نظام شمسی میں آٹھ سیارے ہیں: سورج کے قریب ترین \nمرکری ہے، اگلا وینس ہے، پھر زمین، مریخ، مشتری، سیارہ، \nیورینس، نیپٹون۔ \nایک فنکشن لکھیں جو دو سیاروں کے ناموں کو سیارے 1 اور سیارے 2 کے طور پر لیتا ہے۔ \nفنکشن کو ایک ٹپل واپس کرنا چاہیے جس میں وہ تمام سیارے ہوں جن کے مدار ہیں \nسیارہ 1 کے مدار اور سیارہ 2 کے مدار کے درمیان واقع ہے، جس کے ذریعہ ترتیب دی گئی ہے \nسورج سے قربت۔ \nفنکشن کو خالی ٹپل واپس کرنا چاہیے اگر سیارہ 1 یا سیارہ 2 \nسیاروں کے نام درست نہیں ہیں۔ \nمثالیں \nbf (\"جپٹر\"، \"نیپٹون\") = => (\"سیٹرن\"، \"یورینس\") \nbf (\"زمین\"، \"مرکری\") = => (\"وینس\") \nbf (\"مرکری\"، \"یورینس\") = => (\"وینس\"، \"ارتھ\"، \"مارس\"، \"جپٹر\"، \"سیٹرن\")", "natural_language": "Urdu"}
{"task_id": "python/71", "entry_point": "x_or_y", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n", "language": "python", "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n", "description": "ایک سادہ پروگرام جو x کی قیمت واپس کرے اگر n ہے \nایک پرائم نمبر ہے اور اسے دوسری صورت میں y کی قیمت واپس کرنی چاہیے۔ \n\nمثالیں: \nx _ یا _ y کے لیے (7، 34، 12) = = 34 \nx _ یا _ y کے لیے (15، 8، 5) = = 5", "natural_language": "Urdu"}
{"task_id": "python/72", "entry_point": "double_the_difference", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n", "description": "اعداد کی فہرست کو دیکھتے ہوئے، اعداد کے مربعوں کا مجموعہ واپس کریں \nاس فہرست میں جو عجیب ہیں۔ ان نمبروں کو نظر انداز کریں جو منفی ہیں یا انٹیجر نہیں ہیں۔ \n\nڈبل _ دی _ فرق ([1، 3، 2، 0]) = = 1 + 9 + 0 + 0 = 10 \nڈبل _ دی _ فرق ([-1،-2، 0]) = = 0 \nڈبل _ دی _ فرق ([9,-2]) = = 81 \nڈبل _ دی _ فرق ([0]) = = 0 \n\nاگر ان پٹ لسٹ خالی ہے تو 0 واپس کریں۔", "natural_language": "Urdu"}
{"task_id": "python/73", "entry_point": "Strongest_Extension", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n\n", "language": "python", "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n", "description": "آپ کو ایک کلاس کا نام (ایک سٹرنگ) اور ایکسٹینشنز کی فہرست دی جائے گی۔ \nایکسٹینشنز کو کلاس میں اضافی کلاسز لوڈ کرنے کے لیے استعمال کیا جانا ہے۔ \nتوسیع کی طاقت مندرجہ ذیل ہے: سی اے پی کو بڑے حرف کا نمبر ہونے دیں۔ \nتوسیع کے نام میں حروف، اور ایس ایم کو چھوٹے حروف کی تعداد ہونے دیں \nتوسیع کے نام میں، طاقت کا حصہ CAP-एसएम کے ذریعے دیا جاتا ہے۔ \nآپ کو سب سے مضبوط ایکسٹینشن تلاش کرنی چاہیے اور اس میں ایک سٹرنگ واپس کرنی چاہیے۔ \nفارمیٹ: ClassName.StrongestExtensionName۔ \nاگر ایک ہی طاقت کے ساتھ دو یا زیادہ توسیعات ہیں، تو آپ کو چاہیے \nفہرست میں سب سے پہلے آنے والے کا انتخاب کریں۔ \nمثال کے طور پر، اگر آپ کو کلاس اور فہرست کے طور پر \"سلائسز\" دیا گیا ہے \nتوسیعات: ['SERVINGSliCes'،'چیز'،'سٹوفڈ'] پھر آپ کو کرنا چاہیے \nواپسی'Slices.SErviNGSliCes'چونکہ'SERVINGSliCes'سب سے مضبوط توسیع ہے \n(اس کی طاقت-1 ہے)۔ \nمثال: \nمضبوط ترین _ ایکسٹینشن کے لیے ('مائی _ کلاس'، ['AA'،'Be'،'CC']) = ='my_class.AA'", "natural_language": "Urdu"}
{"task_id": "python/74", "entry_point": "cycpattern_check", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n", "language": "python", "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n", "description": "آپ کو 2 الفاظ دیے گئے ہیں۔ اگر دوسرا لفظ یا اس کی کوئی گردش پہلے لفظ میں سبسٹرنگ ہے تو آپ کو سچ واپس کرنے کی ضرورت ہے۔ \nسائیک پیٹرن _ چیک (\"اے بی سی ڈی\"، \"اے بی ڈی\") => غلط \nسائیک پیٹرن _ چیک (\"ہیلو\"، \"ایل\") => درست \nسائیک پیٹرن _ چیک (\"وس اپ\"، \"psus\") => غلط \nسائیک پیٹرن _ چیک (\"اباب\"، \"با\") => درست \nسائیک پیٹرن _ چیک (\"ایفیف\"، \"ایفیف\") => غلط \nسائیک پیٹرن _ چیک (\"ہیمینس\"، \"سیمین\") => درست", "natural_language": "Urdu"}
{"task_id": "python/75", "entry_point": "int_to_mini_roman", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n", "description": "ایک مثبت عدد کو دیکھتے ہوئے، اس کے رومن ہندسے کے مساوی سٹرنگ کے طور پر حاصل کریں، \nاور اسے چھوٹے حروف میں واپس کر دیں۔ \nپابندیاں: 1 <= num <= 1000 \n\nمثالیں: \n>>> int _ to _ منی _ رومن (19) = ='xix'\n>>> int _ to _ منی _ رومن (152) = ='کلائی'\n>>> int _ to _ منی _ رومن (426) = ='cdxxvi'", "natural_language": "Urdu"}
{"task_id": "python/76", "entry_point": "right_angle_triangle", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n", "language": "python", "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n", "description": "مثلث کے تینوں اطراف کی لمبائی کو دیکھتے ہوئے۔ اگر تینوں ہوں تو درست واپس کریں۔ \nاطراف دائیں زاویہ مثلث بناتے ہیں، بصورت دیگر غلط۔ \nدائیں زاویہ والا مثلث ایک مثلث ہے جس میں ایک زاویہ صحیح زاویہ یا \n90 ڈگری۔ \nمثال: \nدائیں _ زاویہ _ مثلث (3، 4، 5) = = درست \nدائیں _ زاویہ _ مثلث (1، 2، 3) = = غلط", "natural_language": "Urdu"}
{"task_id": "python/77", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n", "language": "python", "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n", "description": "آپ کو ایک سٹرنگ s دی گئی ہے۔ \nاگر s [i] ایک حرف ہے، تو اس کے معاملے کو نچلے سے اوپری یا اس کے برعکس موڑ دیں، \nورنہ اسے جیسا ہے ویسا ہی رکھیں۔ \nاگر سٹرنگ میں کوئی حرف نہ ہوں تو سٹرنگ کو الٹ دیں۔ \nفنکشن کو نتیجہ خیز سٹرنگ واپس کرنی چاہیے۔ \nمثالیں \nحل کریں (\"1234\") = \"4321\" \nحل کریں (\"اب\") = \"اے بی\" \nحل کریں (\"#a @C\") = \"#A @c\"", "natural_language": "Urdu"}
{"task_id": "python/78", "entry_point": "string_to_md5", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n", "description": "سٹرنگ'ٹیکسٹ'کو دیکھتے ہوئے، اس کی ایم ڈی 5 ہیش کے مساوی سٹرنگ واپس کریں۔ \nاگر'ٹیکسٹ'ایک خالی سٹرنگ ہے، تو کالعدم واپس کریں۔ \n\n>>> سٹرنگ _ سے _ md5 ('ہیلو ورلڈ') = ='3e25960a79dbc69b674cd4ec67a72c62'", "natural_language": "Urdu"}
{"task_id": "python/79", "entry_point": "generate_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n", "description": "دو مثبت عددوں a اور b کو دیکھتے ہوئے، a کے درمیان کے یکساں ہندسوں کو واپس کریں۔ \nاور ب، چڑھتے ہوئے ترتیب میں۔ \n\nمثال کے طور پر: \nجنریٹ _ انٹیجرز (2، 8) => [2، 4، 6، 8] \nجنریٹ _ انٹیجرز (8، 2) => [2، 4، 6، 8] \nجنریٹ _ انٹیجرز (10، 14) => []", "natural_language": "Urdu"}
