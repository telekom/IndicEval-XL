{"task_id": "python/0", "entry_point": "below_zero", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n", "language": "python", "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n", "description": "ਤੁਹਾਨੂੰ ਬੈਂਕ ਖਾਤੇ ਵਿੱਚ ਜਮ੍ਹਾਂ ਅਤੇ ਨਿਕਾਸੀ ਕਾਰਜਾਂ ਦੀ ਇੱਕ ਸੂਚੀ ਦਿੱਤੀ ਜਾਂਦੀ ਹੈ ਜੋ ਇਸ ਨਾਲ ਸ਼ੁਰੂ ਹੁੰਦੀ ਹੈ। \nਜ਼ੀਰੋ ਬਕਾਇਆ। ਤੁਹਾਡਾ ਕੰਮ ਇਹ ਪਤਾ ਲਗਾਉਣਾ ਹੈ ਕਿ ਕੀ ਕਿਸੇ ਵੀ ਸਮੇਂ ਖਾਤੇ ਦਾ ਬਕਾਇਆ ਜ਼ੀਰੋ ਤੋਂ ਹੇਠਾਂ ਆ ਜਾਂਦਾ ਹੈ, ਅਤੇ \nਉਸ ਬਿੰਦੂ ਉੱਤੇ ਫੰਕਸ਼ਨ ਨੂੰ ਸਹੀ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ। ਨਹੀਂ ਤਾਂ ਇਸ ਨੂੰ ਗਲਤ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ। \n>>> ਹੇਠਾਂ _ ਜ਼ੀਰੋ ([1,2,3]) \nਝੂਠ ਬੋਲਦਾ ਹੈ। \n>>> ਹੇਠਾਂ _ ਜ਼ੀਰੋ ([1,2,-4,5]) \nਸੱਚ ਹੈ।", "natural_language": "Punjabi"}
{"task_id": "python/1", "entry_point": "sum_product", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n", "language": "python", "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n", "description": "ਪੂਰਨ ਅੰਕਾਂ ਦੀ ਦਿੱਤੀ ਗਈ ਸੂਚੀ ਲਈ, ਇੱਕ ਟੁਪਲ ਵਾਪਸ ਕਰੋ ਜਿਸ ਵਿੱਚ ਇੱਕ ਸੂਚੀ ਵਿੱਚ ਸਾਰੇ ਪੂਰਨ ਅੰਕਾਂ ਦਾ ਜੋਡ਼ ਅਤੇ ਇੱਕ ਗੁਣਨਫਲ ਹੁੰਦਾ ਹੈ। \nਖਾਲੀ ਜੋਡ਼ 0 ਦੇ ਬਰਾਬਰ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ ਅਤੇ ਖਾਲੀ ਗੁਣਨਫਲ 1 ਦੇ ਬਰਾਬਰ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ। \n>>> sum _ product ([]) \n(0,1) \n>>> sum _ product ([1,2,3,4]) \n(10,24)", "natural_language": "Punjabi"}
{"task_id": "python/2", "entry_point": "string_xor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n", "language": "python", "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n", "description": "ਇੰਪੁੱਟ ਦੋ ਸਤਰ a ਅਤੇ b ਹੁੰਦੇ ਹਨ ਜਿਸ ਵਿੱਚ ਸਿਰਫ 1s ਅਤੇ 0s ਹੁੰਦੇ ਹਨ। \nਇਹਨਾਂ ਇਨਪੁਟਸ ਉੱਤੇ ਬਾਈਨਰੀ XOR ਕਰੋ ਅਤੇ ਨਤੀਜਾ ਵੀ ਇੱਕ ਸਤਰ ਦੇ ਰੂਪ ਵਿੱਚ ਵਾਪਸ ਕਰੋ। \n>>> ਸਤਰ _ xor ('010','110') \n'100'", "natural_language": "Punjabi"}
{"task_id": "python/3", "entry_point": "longest", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n", "language": "python", "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "description": "ਸਤਰ ਦੀ ਸੂਚੀ ਵਿੱਚੋਂ, ਸਭ ਤੋਂ ਲੰਬਾ ਇੱਕ ਵਾਪਸ ਕਰੋ। ਮਲਟੀਪਲ ਦੇ ਮਾਮਲੇ ਵਿੱਚ ਪਹਿਲਾ ਇੱਕ ਵਾਪਸ ਕਰੋ \nਇੱਕੋ ਲੰਬਾਈ ਦੇ ਸਤਰ। ਜੇਕਰ ਇੰਪੁੱਟ ਸੂਚੀ ਖਾਲੀ ਹੈ ਤਾਂ ਨੱਲ ਵਾਪਸ ਕਰੋ। \n>>> ਸਭ ਤੋਂ ਲੰਬਾ ([]) \n\n>>> ਸਭ ਤੋਂ ਲੰਬਾ (['a','b','c']) \n'ਏ'\n>>> ਸਭ ਤੋਂ ਲੰਬਾ (['ਏ','ਬੀਬੀ','ਸੀਸੀਸੀ']) \n'ਸੀ. ਸੀ. ਸੀ.'", "natural_language": "Punjabi"}
{"task_id": "python/4", "entry_point": "greatest_common_divisor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n", "language": "python", "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n", "description": "ਦੋ ਪੂਰਨ ਅੰਕ a ਅਤੇ b ਦਾ ਸਭ ਤੋਂ ਵੱਡਾ ਸਾਂਝਾ ਡਿਵੀਜ਼ਰ ਵਾਪਸ ਕਰੋ \n>>> ਸਭ ਤੋਂ ਵੱਡਾ _ ਆਮ _ ਡਿਵੀਜ਼ਰ (3,5) \n1. \n>>> ਸਭ ਤੋਂ ਵੱਡਾ _ ਆਮ _ ਡਿਵੀਜ਼ਰ (25,15) \n5.", "natural_language": "Punjabi"}
{"task_id": "python/5", "entry_point": "sort_numbers", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n", "language": "python", "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n", "description": "ਇੰਪੁੱਟ'ਜ਼ੀਰੋ'ਤੋਂ'ਨੌ'ਤੱਕ ਸੰਖਿਆਵਾਂ ਦੀ ਇੱਕ ਸਪੇਸ-ਸੀਮਾਬੱਧ ਸਤਰ ਹੈ। \nਵੈਧ ਚੋਣਾਂ'ਜ਼ੀਰੋ','ਇੱਕ','ਦੋ','ਤਿੰਨ','ਚਾਰ','ਪੰਜ','ਛੇ','ਸੱਤ','ਅੱਠ'ਅਤੇ'ਨੌਂ'ਹਨ। \nਸਭ ਤੋਂ ਛੋਟੇ ਤੋਂ ਵੱਡੇ ਤੱਕ ਕ੍ਰਮਬੱਧ ਕੀਤੇ ਨੰਬਰਾਂ ਨਾਲ ਸਤਰ ਵਾਪਸ ਕਰੋ \n>>> ਨੰਬਰ ਕ੍ਰਮਬੱਧ ਕਰੋ ('ਤਿੰਨ ਇੱਕ ਪੰਜ') \n'ਇੱਕ ਤਿੰਨ ਪੰਜ'", "natural_language": "Punjabi"}
{"task_id": "python/6", "entry_point": "rescale_to_unit", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n", "language": "python", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "description": "ਸੰਖਿਆਵਾਂ ਦੀ ਸੂਚੀ (ਘੱਟੋ ਘੱਟ ਦੋ ਤੱਤਾਂ ਦੀ) ਦਿੱਤੀ ਗਈ ਹੈ, ਉਸ ਸੂਚੀ ਵਿੱਚ ਇੱਕ ਰੇਖਿਕ ਪਰਿਵਰਤਨ ਲਾਗੂ ਕਰੋ, \nਕਿ ਸਭ ਤੋਂ ਛੋਟੀ ਸੰਖਿਆ 0 ਹੋ ਜਾਵੇਗੀ ਅਤੇ ਸਭ ਤੋਂ ਵੱਡੀ ਸੰਖਿਆ 1 ਹੋ ਜਾਵੇਗੀ। \n>>> ਰੀਸਕੇਲ _ ਟੂ _ ਯੂਨਿਟ ([1, 2, 3, 4, 5]) \n[0,0,25,0,0.75,1.0]", "natural_language": "Punjabi"}
{"task_id": "python/7", "entry_point": "flip_case", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n", "language": "python", "canonical_solution": "    return string.swapcase()\n", "description": "ਦਿੱਤੀ ਗਈ ਸਤਰ ਲਈ, ਛੋਟੇ ਅੱਖਰਾਂ ਨੂੰ ਵੱਡੇ ਅੱਖਰ ਵਿੱਚ ਅਤੇ ਵੱਡੇ ਅੱਖਰਾਂ ਨੂੰ ਛੋਟੇ ਅੱਖਰ ਵਿੱਚ ਬਦਲੋ। \n>>> ਫਲਿੱਪ ਕੇਸ ('ਹੈਲੋ') \n'ਹੈਲੋ'", "natural_language": "Punjabi"}
{"task_id": "python/8", "entry_point": "get_positive", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n", "language": "python", "canonical_solution": "    return [e for e in l if e > 0]\n", "description": "ਸੂਚੀ ਵਿੱਚ ਸਿਰਫ ਸਕਾਰਾਤਮਕ ਨੰਬਰ ਵਾਪਸ ਕਰੋ। \n>>> ਪ੍ਰਾਪਤ ਕਰੋ _ ਸਕਾਰਾਤਮਕ ([-1,2,-4,5,6]) \n[2,5,6] \n>>> ਪ੍ਰਾਪਤ ਕਰੋ _ ਸਕਾਰਾਤਮਕ ([5,3,-5,2,-3,3,9,0,123,1,-10]) \n[5,3,2,3,9,123,1]", "natural_language": "Punjabi"}
{"task_id": "python/9", "entry_point": "is_prime", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n", "language": "python", "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n", "description": "ਜੇਕਰ ਕੋਈ ਦਿੱਤਾ ਗਿਆ ਨੰਬਰ ਪ੍ਰਾਈਮ ਹੈ ਤਾਂ ਸਹੀ ਵਾਪਸ ਕਰੋ, ਅਤੇ ਨਹੀਂ ਤਾਂ ਗਲਤ। \n>>> ਹੈ _ ਪ੍ਰਾਈਮ (6) \nਝੂਠ ਬੋਲਦਾ ਹੈ। \n= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \nਸੱਚ ਹੈ। \n>>> ਹੈ _ ਪ੍ਰਾਈਮ (11) \nਸੱਚ ਹੈ। \n= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \nਸੱਚ ਹੈ। \n>>> ਹੈ _ ਪ੍ਰਾਈਮ (61) \nਸੱਚ ਹੈ। \n>>> ਹੈ _ ਪ੍ਰਾਈਮ (4) \nਝੂਠ ਬੋਲਦਾ ਹੈ। \n>>> ਹੈ _ ਪ੍ਰਾਈਮ (1) \nਝੂਠ ਬੋਲਦਾ ਹੈ।", "natural_language": "Punjabi"}
{"task_id": "python/10", "entry_point": "unique", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n", "language": "python", "canonical_solution": "    return sorted(list(set(l)))\n", "description": "ਇੱਕ ਸੂਚੀ ਵਿੱਚ ਕ੍ਰਮਬੱਧ ਵਿਲੱਖਣ ਤੱਤ ਵਾਪਸ ਕਰੋ \n>>> ਵਿਲੱਖਣ ([5,3,5,2,3,3,9,0,123]) \n[0,2,3,5,9,123]", "natural_language": "Punjabi"}
{"task_id": "python/11", "entry_point": "prime_fib", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n", "language": "python", "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n", "description": "ਪ੍ਰਾਈਮ _ ਫਾਈਬ n-th ਨੰਬਰ ਦਿੰਦਾ ਹੈ ਜੋ ਕਿ ਇੱਕ ਫਿਬੋਨਾਚੀ ਨੰਬਰ ਹੈ ਅਤੇ ਇਹ ਪ੍ਰਾਈਮ ਵੀ ਹੈ। \n>>> ਪ੍ਰਾਈਮ _ ਫਾਈਬ (1) \n2. \n>>> ਪ੍ਰਾਈਮ _ ਫਾਈਬ (2) \n3. \n>>> ਪ੍ਰਾਈਮ _ ਫਾਈਬ (3) \n5. \n>>> ਪ੍ਰਾਈਮ _ ਫਾਈਬ (4) \n13. \n>>> ਪ੍ਰਾਈਮ _ ਫਾਈਬ (5) \n89.", "natural_language": "Punjabi"}
{"task_id": "python/12", "entry_point": "triples_sum_to_zero", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n", "description": "ਟਰਿਪਲਸ _ ਸਮ _ ਤੋਂ _ ਜ਼ੀਰੋ ਇੱਕ ਇੰਪੁੱਟ ਦੇ ਰੂਪ ਵਿੱਚ ਪੂਰਨ ਅੰਕਾਂ ਦੀ ਇੱਕ ਸੂਚੀ ਲੈਂਦਾ ਹੈ। \nਇਹ ਸਹੀ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੇਕਰ ਸੂਚੀ ਵਿੱਚ ਤਿੰਨ ਵੱਖਰੇ ਤੱਤ ਹਨ \nਜ਼ੀਰੋ ਤੱਕ ਜੋਡ਼, ਅਤੇ ਗਲਤ ਹੋਰ. \n\n>>> ਤਿੰਨ _ ਜੋਡ਼ _ ਤੋਂ _ ਜ਼ੀਰੋ ([1,3,5,0]) \nਝੂਠ ਬੋਲਦਾ ਹੈ। \n>>> ਤਿੰਨ _ ਜੋਡ਼ _ ਤੋਂ _ ਜ਼ੀਰੋ ([1,3,-2,1]) \nਸੱਚ ਹੈ। \n>>> ਤਿੰਨ _ ਜੋਡ਼ _ ਤੋਂ _ ਜ਼ੀਰੋ ([1,2,3,7]) \nਝੂਠ ਬੋਲਦਾ ਹੈ। \n>>> ਤਿੰਨ _ ਜੋਡ਼ _ ਤੋਂ _ ਜ਼ੀਰੋ ([2,4,-5,3,9,7]) \nਸੱਚ ਹੈ। \n>>> ਤਿੰਨ _ ਜੋਡ਼ _ ਤੋਂ _ ਜ਼ੀਰੋ ([1]) \nਝੂਠ ਬੋਲਦਾ ਹੈ।", "natural_language": "Punjabi"}
{"task_id": "python/13", "entry_point": "pairs_sum_to_zero", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n", "language": "python", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "description": "ਪੇਅਰਜ਼ _ ਸਮ _ ਤੋਂ _ ਜ਼ੀਰੋ ਇੱਕ ਇੰਪੁੱਟ ਦੇ ਰੂਪ ਵਿੱਚ ਪੂਰਨ ਅੰਕਾਂ ਦੀ ਇੱਕ ਸੂਚੀ ਲੈਂਦਾ ਹੈ। \nਇਹ ਸਹੀ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੇਕਰ ਸੂਚੀ ਵਿੱਚ ਦੋ ਵੱਖਰੇ ਤੱਤ ਹਨ \nਜ਼ੀਰੋ ਤੱਕ ਜੋਡ਼, ਅਤੇ ਗਲਤ ਹੋਰ. \n>>> ਜੋਡ਼ੇ _ ਜੋਡ਼ _ ਤੋਂ _ ਜ਼ੀਰੋ ([1,3,5,0]) \nਝੂਠ ਬੋਲਦਾ ਹੈ। \n>>> ਜੋਡ਼ੇ _ ਜੋਡ਼ _ ਤੋਂ _ ਜ਼ੀਰੋ ([1,3,-2,1]) \nਝੂਠ ਬੋਲਦਾ ਹੈ। \n>>> ਜੋਡ਼ੇ _ ਜੋਡ਼ _ ਤੋਂ _ ਜ਼ੀਰੋ ([1,2,3,7]) \nਝੂਠ ਬੋਲਦਾ ਹੈ। \n>>> ਜੋਡ਼ੇ _ ਜੋਡ਼ _ ਤੋਂ _ ਜ਼ੀਰੋ ([2,4,-5,3,5,7]) \nਸੱਚ ਹੈ। \n>>> ਜੋਡ਼ੇ _ ਜੋਡ਼ _ ਤੋਂ _ ਜ਼ੀਰੋ ([1]) \nਝੂਠ ਬੋਲਦਾ ਹੈ।", "natural_language": "Punjabi"}
{"task_id": "python/14", "entry_point": "fib4", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n", "language": "python", "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n", "description": "ਫਾਈਬ 4 ਨੰਬਰ ਕ੍ਰਮ ਫਾਈਬੋਨੈਕੀ ਸੇਕੁਨੇਸ ਦੇ ਸਮਾਨ ਇੱਕ ਕ੍ਰਮ ਹੈ ਜਿਸ ਨੂੰ ਹੇਠ ਲਿਖੇ ਅਨੁਸਾਰ ਪਰਿਭਾਸ਼ਿਤ ਕੀਤਾ ਗਿਆ ਹੈਃ \nਫਾਈਬ 4 (0)-> 0 \nਫਾਈਬ 4 (1)-> 0 \nਫਾਈਬ 4 (2)-> 2 \nਫਾਈਬ 4 (3)-> 0 \nਫਾਈਬ 4 (ਐੱਨ)-> ਫਾਈਬ 4 (ਐੱਨ-1) + ਫਾਈਬ 4 (ਐੱਨ-2) + ਫਾਈਬ 4 (ਐੱਨ-3) + ਫਾਈਬ 4 (ਐੱਨ-4)। \nਕ੍ਰਿਪਾ ਕਰਕੇ fib4 ਨੰਬਰ ਤਰਤੀਬ ਦੇ n-th ਤੱਤ ਦੀ ਕੁਸ਼ਲਤਾ ਨਾਲ ਗਣਨਾ ਕਰਨ ਲਈ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ। ਪੁਨਰਵਰਤਨ ਦੀ ਵਰਤੋਂ ਨਾ ਕਰੋ। \n>>> ਫਾਈਬ 4 (5) \n4. \n>>> ਫਾਈਬ 4 (6) \n8. \n>>> ਫਾਈਬ4 (7) \n14.", "natural_language": "Punjabi"}
{"task_id": "python/15", "entry_point": "median", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n", "language": "python", "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n", "description": "ਸੂਚੀ l ਵਿੱਚ ਤੱਤਾਂ ਦਾ ਮੀਡੀਅਨ ਵਾਪਸ ਕਰੋ। \n>>> ਮੀਡੀਅਨ ([3,1,2,4,5]) \n3. \n>>> ਮੀਡੀਅਨ ([-10,4,6,1000,10,20]) \n15. 0", "natural_language": "Punjabi"}
{"task_id": "python/16", "entry_point": "is_palindrome", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n", "description": "ਜਾਂਚ ਕਰਦਾ ਹੈ ਕਿ ਕੀ ਦਿੱਤੀ ਗਈ ਸਤਰ ਇੱਕ ਪਾਲੀਂਡਰੋਮ ਹੈ \n>>> ਇਸ _ ਪਾਲੀਂਡਰੋਮ (\") ਹੈ \nਸੱਚ ਹੈ। \n>>> ਇਸ _ ਪਾਲੀਂਡਰੋਮ ('ਅਬਾ') ਹੈ \nਸੱਚ ਹੈ। \n>>> is _ palindrom ('aaaaa') ਹੈ \nਸੱਚ ਹੈ। \n>>> is _ palindrom ('zbcd') ਹੈ \nਝੂਠ ਬੋਲਦਾ ਹੈ।", "natural_language": "Punjabi"}
{"task_id": "python/17", "entry_point": "remove_vowels", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n", "language": "python", "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n", "description": "ਹਟਾਉਣ _ ਸਵਰ ਇੱਕ ਫੰਕਸ਼ਨ ਹੈ ਜੋ ਸਤਰ ਲੈਂਦਾ ਹੈ ਅਤੇ ਬਿਨਾਂ ਸਵਰਾਂ ਦੇ ਸਤਰ ਵਾਪਸ ਕਰਦਾ ਹੈ। \n>>> ਸਵਰ ਹਟਾਓ (\") \n\"\n>>> ਸਵਰ ਹਟਾਓ (\"abcdef\\nghijklm\") \n'ਬੀ. ਸੀ. ਡੀ. ਐੱਫ. \\ਨ. ਜੀ. ਐੱਚ. ਕੇ. ਐੱਲ. ਐੱਮ.'\n>>> ਸਵਰ ਹਟਾਓ ('abcdef') \n'ਬੀ. ਸੀ. ਡੀ. ਐੱਫ.'\n>>> ਸਵਰ ਹਟਾਓ ('ਆਆਆ') \n\"\n>>> ਸਵਰ ਹਟਾਓ ('ਏਏਬੀਏਏ') \n'ਬੀ'\n>>> ਸਵਰ ਹਟਾਓ ('zbcd') \n'zbcd'", "natural_language": "Punjabi"}
{"task_id": "python/18", "entry_point": "below_threshold", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n", "language": "python", "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n", "description": "ਸਹੀ ਵਾਪਸ ਕਰੋ ਜੇਕਰ ਸੂਚੀ l ਵਿੱਚ ਸਾਰੇ ਨੰਬਰ ਥਰੈਸ਼ਹੋਲਡ t ਤੋਂ ਹੇਠਾਂ ਹਨ। \n>> ਥ੍ਰੈਸ਼ਹੋਲਡ ਤੋਂ ਹੇਠਾਂ ([1,2,4,10], 100) \nਸੱਚ ਹੈ। \n>> ਥ੍ਰੈਸ਼ਹੋਲਡ ਤੋਂ ਹੇਠਾਂ ([1,20,4,10], 5) \nਝੂਠ ਬੋਲਦਾ ਹੈ।", "natural_language": "Punjabi"}
{"task_id": "python/19", "entry_point": "add", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n", "language": "python", "canonical_solution": "    return x + y\n", "description": "ਦੋ ਨੰਬਰ x ਅਤੇ y ਜੋਡ਼ੋ \n>>> ਜੋਡ਼ (2,3) \n5. \n>>> ਜੋਡ਼ (5,7) \n12.", "natural_language": "Punjabi"}
{"task_id": "python/20", "entry_point": "same_chars", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n", "language": "python", "canonical_solution": "    return set(s0) == set(s1)\n", "description": "ਜਾਂਚ ਕਰੋ ਕਿ ਕੀ ਦੋ ਸ਼ਬਦਾਂ ਵਿੱਚ ਇੱਕੋ ਜਿਹੇ ਅੱਖਰ ਹਨ। \n>> ਸਮਾਨ _ ਅੱਖਰ ('eabcdzzzz','dddzzzzzuddeddabc') \nਸੱਚ ਹੈ। \n>> ਸਮਾਨ _ ਅੱਖਰ ('ਏ. ਬੀ. ਸੀ. ਡੀ.','ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਏ. ਬੀ. ਸੀ.') \nਸੱਚ ਹੈ। \n>> ਸਮਾਨ _ ਅੱਖਰ ('ddddddabc','abcd') \nਸੱਚ ਹੈ। \n>> ਸਮਾਨ _ ਅੱਖਰ ('ਈ. ਏ. ਬੀ. ਸੀ. ਡੀ.','ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. \nਝੂਠ ਬੋਲਦਾ ਹੈ। \n>> ਸਮਾਨ _ ਅੱਖਰ ('ਏ. ਬੀ. ਸੀ. ਡੀ.','ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਡੀ. \nਝੂਠ ਬੋਲਦਾ ਹੈ। \n>> ਸਮਾਨ _ ਅੱਖਰ ('ਈ. ਏ. ਬੀ. ਸੀ. ਡੀ. ਐੱਜ਼. ਐੱਸ.','ਡੀ. ਡੀ. ਡੀ. ਡੀ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱਸ. ਐੱ \nਝੂਠ ਬੋਲਦਾ ਹੈ।", "natural_language": "Punjabi"}
{"task_id": "python/21", "entry_point": "fib", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "description": "n-th ਫਿਬੋਨਾਚੀ ਨੰਬਰ ਵਾਪਸ ਕਰੋ। \n>>> ਫਾਈਬ (10) \n55. \n>>> ਫਾਈਬ (1) \n1. \n>>> ਫਾਈਬ (8) \n21.", "natural_language": "Punjabi"}
{"task_id": "python/22", "entry_point": "common", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n", "language": "python", "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "description": "ਦੋ ਸੂਚੀਆਂ ਲਈ ਵਿਲੱਖਣ ਆਮ ਤੱਤਾਂ ਨੂੰ ਵਾਪਸ ਕ੍ਰਮਬੱਧ ਕਰੋ। \n>> ਆਮ ([1,4,3,34,653,2,5], [5,7,1,5,9,653,121]) \n[1,5,653] \n>>> ਆਮ ([5,3,2,8], [3,2]) \n[2,3]", "natural_language": "Punjabi"}
{"task_id": "python/23", "entry_point": "largest_prime_factor", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n", "language": "python", "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n", "description": "n ਦਾ ਸਭ ਤੋਂ ਵੱਡਾ ਪ੍ਰਾਈਮ ਫੈਕਟਰ ਵਾਪਸ ਕਰੋ। ਮੰਨ ਲਓ ਕਿ n> 1 ਪ੍ਰਾਈਮ ਨਹੀਂ ਹੈ। \n>>> ਸਭ ਤੋਂ ਵੱਡਾ _ ਪ੍ਰਾਈਮ _ ਫੈਕਟਰ (13195) \n29. \n>>> ਸਭ ਤੋਂ ਵੱਡਾ _ ਪ੍ਰਾਈਮ _ ਫੈਕਟਰ (2048) \n2.", "natural_language": "Punjabi"}
{"task_id": "python/24", "entry_point": "sum_to_n", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n", "language": "python", "canonical_solution": "    return sum(range(n + 1))\n", "description": "sum _ to _ n ਇੱਕ ਫੰਕਸ਼ਨ ਹੈ ਜੋ 1 ਤੋਂ n ਤੱਕ ਸੰਖਿਆਵਾਂ ਦਾ ਜੋਡ਼ ਕਰਦਾ ਹੈ। \n>>> ਜੋਡ਼ _ ਤੋਂ _ n (30) \n465 \n>>> ਜੋਡ਼ _ ਤੋਂ _ n (100) \n5050 \n>>> ਜੋਡ਼ _ ਤੋਂ _ n (5) \n15. \n>>> ਜੋਡ਼ _ ਤੋਂ _ n (10) \n55. \n>>> ਜੋਡ਼ _ ਤੋਂ _ n (1) \n1.", "natural_language": "Punjabi"}
{"task_id": "python/25", "entry_point": "derivative", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n", "language": "python", "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n", "description": "xs ਕਿਸੇ ਬਹੁਪੱਖੀ ਦੇ ਗੁਣਾਂਕਾਂ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ। \nxs [0] + xs [1] * x + xs [2] * x2 +.... \nਇਸ ਬਹੁਪੱਖੀ ਦਾ ਉਸੇ ਰੂਪ ਵਿੱਚ ਰਿਟਰਨ ਡੈਰੀਵੇਟਿਵ। \n>>> ਡੈਰੀਵੇਟਿਵ ([3,1,2,4,5]) \n[1,4,12,20] \n>>> ਡੈਰੀਵੇਟਿਵ ([1,2,3]) \n[2,6]", "natural_language": "Punjabi"}
{"task_id": "python/26", "entry_point": "fibfib", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n", "description": "ਫਾਈਬ ਫਾਈਬ ਨੰਬਰ ਕ੍ਰਮ ਫਾਈਬੋਨੈਕੀ ਸੇਕੁਨੇਸ ਦੇ ਸਮਾਨ ਇੱਕ ਕ੍ਰਮ ਹੈ ਜਿਸ ਨੂੰ ਹੇਠ ਲਿਖੇ ਅਨੁਸਾਰ ਪਰਿਭਾਸ਼ਿਤ ਕੀਤਾ ਗਿਆ ਹੈਃ \nਫਾਈਬਫਿਬ (0) = = 0 \nਫਾਈਬਫਿਬ (1) = = 0 \nਫਾਈਬਫਿਬ (2) = = 1 \nਫਾਈਬ ਫਾਈਬ (ਐੱਨ) = = ਫਾਈਬ ਫਾਈਬ (ਐੱਨ-1) + ਫਾਈਬ ਫਾਈਬ (ਐੱਨ-2) + ਫਾਈਬ ਫਾਈਬ (ਐੱਨ-3)। \nਕ੍ਰਿਪਾ ਕਰਕੇ fibfib ਨੰਬਰ ਤਰਤੀਬ ਦੇ n-th ਤੱਤ ਦੀ ਕੁਸ਼ਲਤਾ ਨਾਲ ਗਣਨਾ ਕਰਨ ਲਈ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ। \n>>> ਫਾਈਬਫਿਬ (1) \n0 \n>>> ਫਾਈਬਫਿਬ (5) \n4. \n>>> ਫਾਈਬਫਿਬ (8) \n24.", "natural_language": "Punjabi"}
{"task_id": "python/27", "entry_point": "vowels_count", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n", "description": "ਇੱਕ ਫੰਕਸ਼ਨ vowels _ ਕੌਂਟ ਲਿਖੋ ਜੋ ਇੱਕ ਸਤਰ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ \nਇੱਕ ਸ਼ਬਦ ਇੰਪੁੱਟ ਦੇ ਰੂਪ ਵਿੱਚ ਅਤੇ ਸਤਰ ਵਿੱਚ ਸਵਰਾਂ ਦੀ ਗਿਣਤੀ ਵਾਪਸ ਕਰਦਾ ਹੈ। \nਇਸ ਮਾਮਲੇ ਵਿੱਚ ਸਵਰ'a','e','i','o','u'ਹਨ। ਇੱਥੇ,'y'ਵੀ ਇੱਕ ਹੈ। \nਸਵਰ, ਪਰ ਸਿਰਫ ਉਦੋਂ ਜਦੋਂ ਇਹ ਦਿੱਤੇ ਗਏ ਸ਼ਬਦ ਦੇ ਅੰਤ ਵਿੱਚ ਹੋਵੇ। \n\nਉਦਾਹਰਨਃ \n>>> ਸਵਰਾਂ ਦੀ ਗਿਣਤੀ (\"ਏ. ਬੀ. ਸੀ. ਡੀ\".) \n2. \n>>> ਸਵਰਾਂ ਦੀ ਗਿਣਤੀ (\"ACEDY\") \n3.", "natural_language": "Punjabi"}
{"task_id": "python/28", "entry_point": "search", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n", "language": "python", "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n", "description": "ਤੁਹਾਨੂੰ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕਾਂ ਦੀ ਇੱਕ ਖਾਲੀ ਸੂਚੀ ਦਿੱਤੀ ਜਾਂਦੀ ਹੈ। ਸਭ ਤੋਂ ਵੱਡਾ ਪੂਰਨ ਅੰਕ ਵਾਪਸ ਕਰੋ ਜੋ ਇਸ ਤੋਂ ਵੱਡਾ ਹੈ। \nਜ਼ੀਰੋ, ਅਤੇ ਇਸਦੀ ਬਾਰੰਬਾਰਤਾ ਆਪਣੇ ਆਪ ਵਿੱਚ ਪੂਰਨ ਅੰਕ ਦੇ ਮੁੱਲ ਤੋਂ ਵੱਧ ਜਾਂ ਬਰਾਬਰ ਹੁੰਦੀ ਹੈ। \nਇੱਕ ਪੂਰਨ ਅੰਕ ਦੀ ਬਾਰੰਬਾਰਤਾ ਸੂਚੀ ਵਿੱਚ ਕਿੰਨੀ ਵਾਰ ਦਿਖਾਈ ਦਿੰਦੀ ਹੈ। \nਜੇਕਰ ਅਜਿਹਾ ਕੋਈ ਮੁੱਲ ਮੌਜੂਦ ਨਹੀਂ ਹੈ, ਤਾਂ-1 ਵਾਪਸ ਕਰੋ। \nਉਦਾਹਰਨਾਂਃ \nਖੋਜ ([4,1,2,2,3,1]) = = 2 \nਖੋਜ ([1,2,3,3,4,4]) = = 3 \nਖੋਜ ([5,5,4,4]) = =-1", "natural_language": "Punjabi"}
{"task_id": "python/29", "entry_point": "triangle_area", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n", "language": "python", "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n", "description": "ਇੱਕ ਤਿਕੋਣ ਦੇ ਤਿੰਨ ਪਾਸਿਆਂ ਦੀ ਲੰਬਾਈ ਦਿੱਤੀ ਗਈ ਹੈ। \nਜੇਕਰ ਤਿੰਨੋਂ ਪਾਸੇ ਇੱਕ ਜਾਇਜ਼ ਤਿਕੋਣ ਬਣਾਉਂਦੇ ਹਨ ਤਾਂ ਤਿਕੋਣ ਨੂੰ 2 ਦਸ਼ਿਮਲ ਬਿੰਦੂਆਂ ਤੱਕ ਗੋਲ ਕੀਤਾ ਜਾਂਦਾ ਹੈ। \nਨਹੀਂ ਤਾਂ ਵਾਪਸੀ-1 \nਤਿੰਨ ਪਾਸੇ ਇੱਕ ਜਾਇਜ਼ ਤਿਕੋਣ ਬਣਾਉਂਦੇ ਹਨ ਜਦੋਂ ਕਿਸੇ ਵੀ ਦੋ ਪਾਸਿਆਂ ਦਾ ਜੋਡ਼ ਵੱਡਾ ਹੁੰਦਾ ਹੈ। \nਤੀਜੇ ਪੱਖ ਤੋਂ ਵੱਧ. \nਉਦਾਹਰਨਃ \nਤਿਕੋਣ ਖੇਤਰਫਲ (3,4,5) = = 6.00 \nਤਿਕੋਣ _ ਖੇਤਰਫਲ (1,2,10) = =-1", "natural_language": "Punjabi"}
{"task_id": "python/30", "entry_point": "will_it_fly", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n", "language": "python", "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n", "description": "ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਸਹੀ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੇਕਰ ਆਬਜੈਕਟ q ਉੱਡੇਗਾ, ਅਤੇ ਗਲਤ ਨਹੀਂ। \nਵਸਤੂ q ਉੱਡੇਗੀ ਜੇ ਇਹ ਸੰਤੁਲਿਤ ਹੈ (ਇਹ ਇੱਕ ਪੈਲਿੰਡ੍ਰੋਮਿਕ ਸੂਚੀ ਹੈ) ਅਤੇ ਇਸਦੇ ਤੱਤਾਂ ਦਾ ਜੋਡ਼ ਵੱਧ ਤੋਂ ਵੱਧ ਸੰਭਵ ਭਾਰ ਡਬਲਯੂ ਤੋਂ ਘੱਟ ਜਾਂ ਬਰਾਬਰ ਹੈ। \n\nਉਦਾਹਰਨਃ \nਕੀ ਇਹ ਉੱਡਦਾ ਹੈ ([1,2], 5) ਗਲਤ \n#1 + 2 ਵੱਧ ਤੋਂ ਵੱਧ ਸੰਭਵ ਭਾਰ ਤੋਂ ਘੱਟ ਹੈ, ਪਰ ਇਹ ਅਸੰਤੁਲਿਤ ਹੈ। \n\nਕੀ ਇਹ ਉੱਡਦਾ ਹੈ ([3,2,3], 1) ਗਲਤ \n#ਇਹ ਸੰਤੁਲਿਤ ਹੈ, ਪਰ 3 + 2 + 3 ਵੱਧ ਤੋਂ ਵੱਧ ਸੰਭਵ ਭਾਰ ਤੋਂ ਵੱਧ ਹੈ। \n\nਵਿਲ ਇਟ ਫਲਾਈ ([3,2,3], 9) ਸੱਚ ਹੈ \n#3 + 2 + 3 ਵੱਧ ਤੋਂ ਵੱਧ ਸੰਭਵ ਭਾਰ ਤੋਂ ਘੱਟ ਹੈ, ਅਤੇ ਇਹ ਸੰਤੁਲਿਤ ਹੈ। \n\nਵਿਲ _ ਇਟ _ ਫਲਾਈ ([3], 5) ਸੱਚ \n#3 ਵੱਧ ਤੋਂ ਵੱਧ ਸੰਭਵ ਭਾਰ ਤੋਂ ਘੱਟ ਹੈ, ਅਤੇ ਇਹ ਸੰਤੁਲਿਤ ਹੈ।", "natural_language": "Punjabi"}
{"task_id": "python/31", "entry_point": "is_multiply_prime", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n", "language": "python", "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n", "description": "ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਸੱਚ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੇਕਰ ਦਿੱਤਾ ਗਿਆ ਨੰਬਰ 3 ਪ੍ਰਾਈਮ ਨੰਬਰਾਂ ਦਾ ਗੁਣਾ ਹੈ। \nਅਤੇ ਹੋਰ ਗਲਤ. \nਇਹ ਜਾਣਨਾ ਕਿ (ਏ) 100 ਤੋਂ ਘੱਟ ਹੈ। \nਉਦਾਹਰਨਃ \nਕੀ _ ਗੁਣਾ _ ਪ੍ਰਾਈਮ (30) = = ਸੱਚ ਹੈ \n30 = 2 * 3 * 5", "natural_language": "Punjabi"}
{"task_id": "python/32", "entry_point": "decimal_to_binary", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n", "description": "ਤੁਹਾਨੂੰ ਦਸ਼ਮਲਵ ਰੂਪ ਵਿੱਚ ਇੱਕ ਨੰਬਰ ਦਿੱਤਾ ਜਾਵੇਗਾ ਅਤੇ ਤੁਹਾਡਾ ਕੰਮ ਇਸ ਨੂੰ ਇਸ ਵਿੱਚ ਬਦਲਣਾ ਹੈ \nਬਾਈਨਰੀ ਫਾਰਮੈਟ। ਫੰਕਸ਼ਨ ਨੂੰ ਇੱਕ ਸਤਰ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ, ਜਿਸ ਵਿੱਚ ਹਰੇਕ ਅੱਖਰ ਇੱਕ ਬਾਈਨਰੀ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ। \nਨੰਬਰ। ਸਤਰ ਵਿੱਚ ਹਰੇਕ ਅੱਖਰ'0'ਜਾਂ'1'ਹੋਵੇਗਾ। \n\nਸਤਰ ਦੇ ਸ਼ੁਰੂ ਵਿੱਚ ਅਤੇ ਅੰਤ ਵਿੱਚ ਦੋ ਵਾਧੂ ਅੱਖਰ'db'ਹੋਣਗੇ। \nਫਾਰਮੈਟ ਵਿੱਚ ਮਦਦ ਕਰਨ ਲਈ ਵਾਧੂ ਅੱਖਰ ਹਨ। \n\nਉਦਾਹਰਨਾਂਃ \nਡੈਸੀਮਲ _ ਤੋਂ _ ਬਾਈਨਰੀ (15) #\"db1111db\" ਦਿੰਦਾ ਹੈ \nਡੈਸੀਮਲ _ ਤੋਂ _ ਬਾਈਨਰੀ (32) #\"db100000db\" ਦਿੰਦਾ ਹੈ", "natural_language": "Punjabi"}
{"task_id": "python/33", "entry_point": "is_happy", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n", "language": "python", "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n", "description": "ਤੁਹਾਨੂੰ ਇੱਕ ਸਤਰ s ਦਿੱਤੀ ਜਾਂਦੀ ਹੈ। \nਤੁਹਾਡਾ ਕੰਮ ਇਹ ਜਾਂਚ ਕਰਨਾ ਹੈ ਕਿ ਸਤਰ ਖੁਸ਼ ਹੈ ਜਾਂ ਨਹੀਂ। \nਇੱਕ ਸਤਰ ਖੁਸ਼ ਹੁੰਦੀ ਹੈ ਜੇਕਰ ਇਸ ਦੀ ਲੰਬਾਈ ਘੱਟੋ ਘੱਟ 3 ਹੋਵੇ ਅਤੇ ਹਰ 3 ਲਗਾਤਾਰ ਅੱਖਰ ਵੱਖਰੇ ਹੋਣ। \nਉਦਾਹਰਨ ਲਈਃ \nਖੁਸ਼ ਹੈ (a) => ਗਲਤ ਹੈ \nਖੁਸ਼ ਹੈ (ਏਏ) => ਗਲਤ ਹੈ \nਖੁਸ਼ ਹੈ (ਏ. ਬੀ. ਸੀ. ਡੀ.) => ਸੱਚ ਹੈ \nਖੁਸ਼ ਹੈ (aabb) => ਗਲਤ ਹੈ \nਖੁਸ਼ ਹੈ (adb) => ਸੱਚ ਹੈ \nਖੁਸ਼ ਹੈ (xyy) => ਗਲਤ ਹੈ", "natural_language": "Punjabi"}
{"task_id": "python/34", "entry_point": "numerical_letter_grade", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "description": "ਇਹ ਸਮੈਸਟਰ ਦਾ ਆਖਰੀ ਹਫ਼ਤਾ ਹੁੰਦਾ ਹੈ ਅਤੇ ਅਧਿਆਪਕ ਨੂੰ ਗ੍ਰੇਡ ਦੇਣੇ ਹੁੰਦੇ ਹਨ। \nਵਿਦਿਆਰਥੀਆਂ ਨੂੰ। ਅਧਿਆਪਕ ਗ੍ਰੇਡਿੰਗ ਲਈ ਆਪਣਾ ਐਲਗੋਰਿਦਮ ਬਣਾ ਰਿਹਾ ਹੈ। \nਇਕੋ ਸਮੱਸਿਆ ਇਹ ਹੈ ਕਿ ਉਸ ਨੇ ਗ੍ਰੇਡਿੰਗ ਲਈ ਵਰਤਿਆ ਕੋਡ ਗੁਆ ਦਿੱਤਾ ਹੈ। \nਉਸ ਨੇ ਤੁਹਾਨੂੰ ਕੁੱਝ ਵਿਦਿਆਰਥੀਆਂ ਲਈ ਜੀ. ਪੀ. ਏ. ਦੀ ਸੂਚੀ ਦਿੱਤੀ ਹੈ ਅਤੇ ਤੁਹਾਨੂੰ ਲਿਖਣਾ ਪਵੇਗਾ। \nਇੱਕ ਫੰਕਸ਼ਨ ਜੋ ਹੇਠ ਦਿੱਤੀ ਸਾਰਣੀ ਦੀ ਵਰਤੋਂ ਕਰਕੇ ਅੱਖਰ ਗ੍ਰੇਡ ਦੀ ਸੂਚੀ ਨੂੰ ਆਉਟਪੁੱਟ ਕਰ ਸਕਦਾ ਹੈਃ \nਜੀ. ਪੀ. ਏ। ਲੈਟਰ ਗ੍ਰੇਡ \n4. 0 ਏ + \n> 3.7 ਏ \n> 3.3 ਏ-\n> 3 ਬੀ + \n> 2.7 ਬੀ \n> 2.3 ਬੀ-\n> 2C + \n> 1.7 ਡਿਗਰੀ ਸੈਲਸੀਅਸ \n> 1.3 ਸੀ-\n> 1. 0 ਡੀ + \n> 0.7 ਡੀ \n> 0.0 ਡੀ-\n0. 0 ਈ \n\nਉਦਾਹਰਨਃ \ngrade _ ਸਮੀਕਰਨ ([4,0,3,7,2,3,5]) = => ['A +','B','C-','C','A -']", "natural_language": "Punjabi"}
{"task_id": "python/35", "entry_point": "prime_length", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n", "language": "python", "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "description": "ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੱਕ ਸਤਰ ਲੈਂਦਾ ਹੈ ਅਤੇ ਸਹੀ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੇਕਰ ਸਤਰ \nਲੰਬਾਈ ਇੱਕ ਪ੍ਰਮੁੱਖ ਸੰਖਿਆ ਹੈ ਜਾਂ ਗਲਤ \nਉਦਾਹਰਣਾਂ \nਪ੍ਰਾਈਮ _ ਲੰਬਾਈ ('ਹੈਲੋ') = = ਸੱਚ \nਪ੍ਰਾਈਮ _ ਲੰਬਾਈ ('abcdcba') = = ਸੱਚ \nਪ੍ਰਾਈਮ _ ਲੰਬਾਈ ('ਬਿੱਲੀਆਂ ਦੇ ਬੱਚੇ') = = ਸੱਚ \nਪ੍ਰਾਈਮ _ ਲੰਬਾਈ ('ਸੰਤਰੀ') = = ਗਲਤ", "natural_language": "Punjabi"}
{"task_id": "python/36", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n", "language": "python", "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n", "description": "ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ N ਦਿੱਤਾ ਗਿਆ ਹੈ, ਇਸ ਦੇ ਅੰਕਾਂ ਦਾ ਕੁੱਲ ਜੋਡ਼ ਬਾਈਨਰੀ ਵਿੱਚ ਵਾਪਸ ਕਰੋ। \n\nਉਦਾਹਰਨ \nN = 1000 ਲਈ, ਅੰਕਾਂ ਦਾ ਜੋਡ਼ 1 ਹੋਵੇਗਾ ਅਤੇ ਆਉਟਪੁੱਟ \"1\" ਹੋਣੀ ਚਾਹੀਦੀ ਹੈ। \nN = 150 ਲਈ, ਅੰਕਾਂ ਦਾ ਜੋਡ਼ 6 ਹੋਵੇਗਾ ਅਤੇ ਆਉਟਪੁੱਟ \"110\" ਹੋਣੀ ਚਾਹੀਦੀ ਹੈ। \nN = 147 ਲਈ, ਅੰਕਾਂ ਦਾ ਜੋਡ਼ 12 ਹੋਵੇਗਾ ਅਤੇ ਆਉਟਪੁੱਟ \"1100\" ਹੋਣੀ ਚਾਹੀਦੀ ਹੈ। \n\nਪਰਿਵਰਤਨਸ਼ੀਲਃ \n@N ਪੂਰਨ ਅੰਕ \nਪਾਬੰਦੀਆਂਃ 0 ≤ N ≤ 10000. \nਆਉਟਪੁੱਟਃ \nਬਾਈਨਰੀ ਨੰਬਰ ਦੀ ਇੱਕ ਸਤਰ", "natural_language": "Punjabi"}
{"task_id": "python/37", "entry_point": "get_row", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "description": "ਤੁਹਾਨੂੰ ਇੱਕ 2-ਅਯਾਮੀ ਡੇਟਾ ਦਿੱਤਾ ਜਾਂਦਾ ਹੈ, ਇੱਕ ਨੈਸਟਡ ਸੂਚੀ ਦੇ ਰੂਪ ਵਿੱਚ, \nਜੋ ਮੈਟ੍ਰਿਕਸ ਦੇ ਸਮਾਨ ਹੈ, ਹਾਲਾਂਕਿ, ਮੈਟ੍ਰਿਕਸ ਦੇ ਉਲਟ, \nਹਰੇਕ ਕਤਾਰ ਵਿੱਚ ਵੱਖ-ਵੱਖ ਕਾਲਮ ਹੋ ਸਕਦੇ ਹਨ। \nਦਿੱਤੇ ਗਏ lst, ਅਤੇ ਪੂਰਨ ਅੰਕ x, ਸੂਚੀ ਵਿੱਚ ਪੂਰਨ ਅੰਕ x ਲੱਭੋ, \nਅਤੇ ਟੁਪਲਾਂ ਦੀ ਸੂਚੀ ਵਾਪਸ ਕਰੋ, [(x1, y1), (x2, y2)...] ਜਿਵੇਂ ਕਿ \nਹਰੇਕ ਟੁਪਲ ਇੱਕ ਨਿਰਦੇਸ਼ਾਂਕ-(ਕਤਾਰ, ਕਾਲਮ) ਹੁੰਦਾ ਹੈ, ਜੋ 0 ਨਾਲ ਸ਼ੁਰੂ ਹੁੰਦਾ ਹੈ। \nਕੋਆਰਡੀਨੇਟਸ ਨੂੰ ਸ਼ੁਰੂ ਵਿੱਚ ਕਤਾਰਾਂ ਦੁਆਰਾ ਚਡ਼੍ਹਦੇ ਕ੍ਰਮ ਵਿੱਚ ਕ੍ਰਮਬੱਧ ਕਰੋ। \nਨਾਲ ਹੀ, ਕਤਾਰ ਦੇ ਨਿਰਦੇਸ਼ਾਂਕ ਨੂੰ ਕਾਲਮਾਂ ਦੁਆਰਾ ਉਤਰਦੇ ਕ੍ਰਮ ਵਿੱਚ ਕ੍ਰਮਬੱਧ ਕਰੋ। \n\nਉਦਾਹਰਨਾਂਃ \nਕਤਾਰ ਪ੍ਰਾਪਤ ਕਰੋ ([]) \n[1,2,3, 4,5,6], \n[1,2,3, 4,1,6], \n[1,2,3, 4,5,1] \n], 1) = = [(0,0), (1,4), (1,0), (2,5), (2,0)] \nਪ੍ਰਾਪਤ ਕਰੋ ([], 1) = = [] \nਪ੍ਰਾਪਤ ਕਰੋ ([[], [1], [1,2,3]], 3) = = [(2,2)]", "natural_language": "Punjabi"}
{"task_id": "python/38", "entry_point": "next_smallest", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "description": "ਤੁਹਾਨੂੰ ਪੂਰਨ ਅੰਕਾਂ ਦੀ ਸੂਚੀ ਦਿੱਤੀ ਜਾਂਦੀ ਹੈ। \nਇੱਕ ਫੰਕਸ਼ਨ ਅਗਲਾ _ ਛੋਟਾ () ਲਿਖੋ ਜੋ ਸੂਚੀ ਦਾ ਦੂਜਾ ਸਭ ਤੋਂ ਛੋਟਾ ਤੱਤ ਵਾਪਸ ਕਰਦਾ ਹੈ। \nਜੇਕਰ ਅਜਿਹਾ ਕੋਈ ਤੱਤ ਨਹੀਂ ਹੈ ਤਾਂ ਨੱਲ ਵਾਪਸ ਕਰੋ। \n\nਅਗਲਾ _ ਸਭ ਤੋਂ ਛੋਟਾ ([1,2,3,4,5]) = = 2 \nਅਗਲਾ _ ਸਭ ਤੋਂ ਛੋਟਾ ([5,1,4,3,2]) = = 2 \nਅਗਲਾ _ ਸਭ ਤੋਂ ਛੋਟਾ ([]) = = ਕੋਈ ਨਹੀਂ \nਅਗਲਾ _ ਸਭ ਤੋਂ ਛੋਟਾ ([1,1]) = = ਕੋਈ ਨਹੀਂ", "natural_language": "Punjabi"}
{"task_id": "python/39", "entry_point": "is_bored", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "description": "ਤੁਹਾਨੂੰ ਸ਼ਬਦਾਂ ਦੀ ਇੱਕ ਸਤਰ ਦਿੱਤੀ ਜਾਵੇਗੀ, ਅਤੇ ਤੁਹਾਡਾ ਕੰਮ ਸੰਖਿਆ ਦੀ ਗਿਣਤੀ ਕਰਨਾ ਹੈ। \nਬੋਰਿੰਗ. ਬੋਰਿੰਗ ਇੱਕ ਵਾਕ ਹੈ ਜੋ \"ਮੈਂ\" ਸ਼ਬਦ ਨਾਲ ਸ਼ੁਰੂ ਹੁੰਦਾ ਹੈ। \nਵਾਕਾਂ ਦੀ ਹੱਦਬੰਦੀ '.', '?'ਜਾਂ '!'ਦੁਆਰਾ ਕੀਤੀ ਜਾਂਦੀ ਹੈ। \n\nਉਦਾਹਰਨ ਲਈਃ \n>>> ਬੋਰ ਹੈ (\"ਹੈਲੋ ਵਰਲਡ\") \n0 \n>>> ਹੈ _ ਬੋਰ (\"ਅਸਮਾਨ ਨੀਲਾ ਹੈ. ਸੂਰਜ ਚਮਕ ਰਿਹਾ ਹੈ. ਮੈਨੂੰ ਇਹ ਮੌਸਮ ਪਸੰਦ ਹੈ\") \n1.", "natural_language": "Punjabi"}
{"task_id": "python/40", "entry_point": "skjkasdkd", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n", "language": "python", "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "description": "ਤੁਹਾਨੂੰ ਪੂਰਨ ਅੰਕਾਂ ਦੀ ਸੂਚੀ ਦਿੱਤੀ ਜਾਂਦੀ ਹੈ। \nਤੁਹਾਨੂੰ ਸਭ ਤੋਂ ਵੱਡਾ ਪ੍ਰਾਈਮ ਮੁੱਲ ਲੱਭਣ ਅਤੇ ਇਸ ਦੇ ਅੰਕਾਂ ਦਾ ਜੋਡ਼ ਵਾਪਸ ਕਰਨ ਦੀ ਜ਼ਰੂਰਤ ਹੈ। \n\nਉਦਾਹਰਨਾਂਃ \nlst = [0,3,2, 1,3,5, 7,4,5, 5,5,2, 181,32,4, 32,3,2, 32,324,4, 3] ਲਈ ਆਉਟਪੁੱਟ 10 ਹੋਣੀ ਚਾਹੀਦੀ ਹੈ। \nlst = [1,0,1, 8,2,4597, 2,1,3, 40,1,2, 1,2,4, 2,5,1] ਲਈ ਆਉਟਪੁੱਟ 25 ਹੋਣੀ ਚਾਹੀਦੀ ਹੈ। \nlst = [1,3,1, 32,5107,34, 83278,109,163, 23,2323,32, 30,1,9, 3] ਲਈ ਆਉਟਪੁੱਟ 13 ਹੋਣੀ ਚਾਹੀਦੀ ਹੈ। \nlst = [0,724,32, 71,99,32, 6,0,5, 91,83,0, 5,6] ਲਈ ਆਉਟਪੁੱਟ 11 ਹੋਣੀ ਚਾਹੀਦੀ ਹੈ। \nlst = [0,81,12, 3,1,21] ਲਈ ਆਉਟਪੁੱਟ 3 ਹੋਣੀ ਚਾਹੀਦੀ ਹੈ। \nlst = [0,8,1, 2,1,7] ਲਈ ਆਉਟਪੁੱਟ 7 ਹੋਣੀ ਚਾਹੀਦੀ ਹੈ।", "natural_language": "Punjabi"}
{"task_id": "python/41", "entry_point": "check_dict_case", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n", "language": "python", "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n", "description": "ਇੱਕ ਸ਼ਬਦਕੋਸ਼ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਤਾਂ ਸਹੀ ਵਾਪਸ ਕਰੋ ਜੇਕਰ ਸਾਰੀਆਂ ਕੁੰਜੀਆਂ ਹੇਠਲੇ ਸਤਰ ਵਿੱਚ ਹਨ \nਕੇਸ ਜਾਂ ਸਾਰੀਆਂ ਕੁੰਜੀਆਂ ਵੱਡੇ ਕੇਸ ਵਿੱਚ ਸਤਰ ਹਨ, ਨਹੀਂ ਤਾਂ ਗਲਤ ਵਾਪਸ ਕਰੋ। \nਫੰਕਸ਼ਨ ਨੂੰ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਗਲਤ ਸ਼ਬਦਕੋਸ਼ ਖਾਲੀ ਹੈ। \nਉਦਾਹਰਨਾਂਃ \nਚੈੱਕ _ ਡਿਕ _ ਕੇਸ ({\"a\": \"ਸੇਬ\", \"b\": \"ਕੇਲੇ\"}) ਨੂੰ ਸਹੀ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ। \nਚੈੱਕ _ ਡਿਕਟੀ _ ਕੇਸ ({\"a\": \"ਸੇਬ\", \"A\": \"ਕੇਲਾ\", \"B\": \"ਕੇਲਾ\"}) ਨੂੰ ਗਲਤ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ। \nਚੈੱਕ _ ਡਿਕ _ ਕੇਸ ({\"a\": \"ਸੇਬ\", 8: \"ਕੇਲਾ\", \"a\": \"ਸੇਬ\"}) ਨੂੰ ਗਲਤ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ। \nਚੈੱਕ _ ਡਿਕ _ ਕੇਸ ({\"ਨਾਮ\": \"ਜੌਨ\", \"ਉਮਰ\": \"36\", \"ਸਿਟੀ\": \"ਹਿਊਸਟਨ\"}) ਨੂੰ ਗਲਤ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ। \nਚੈੱਕ _ ਡਿੱਕਟ _ ਕੇਸ ({\"STATE\": \"NC\", \"ZIP\": \"12345\"}) ਨੂੰ ਸਹੀ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ।", "natural_language": "Punjabi"}
{"task_id": "python/42", "entry_point": "closest_integer", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n", "language": "python", "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "description": "ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਇੱਕ ਨੰਬਰ ਨੂੰ ਦਰਸਾਉਂਦਾ ਇੱਕ ਮੁੱਲ (ਸਤਰ) ਲੈਂਦਾ ਹੈ \nਅਤੇ ਇਸ ਨੂੰ ਸਭ ਤੋਂ ਨਜ਼ਦੀਕੀ ਪੂਰਨ ਅੰਕ ਦਿੰਦਾ ਹੈ। ਜੇਕਰ ਸੰਖਿਆ ਬਰਾਬਰ ਹੈ \nਦੋ ਪੂਰਨ ਅੰਕਾਂ ਤੋਂ, ਇਸ ਨੂੰ ਜ਼ੀਰੋ ਤੋਂ ਦੂਰ ਗੋਲ ਕਰੋ। \n\nਉਦਾਹਰਣਾਂ \n>>> ਨਜ਼ਦੀਕੀ ਪੂਰਨ ਅੰਕ (\"10\") \n10. \n>>> ਨਜ਼ਦੀਕੀ ਪੂਰਨ ਅੰਕ (\"15.3\") \n15. \n\nਨੋਟਃ \nਜ਼ੀਰੋ ਤੋਂ ਦੂਰ ਗੋਲ ਕਰਨ ਦਾ ਅਰਥ ਹੈ ਕਿ ਜੇਕਰ ਦਿੱਤੀ ਗਈ ਸੰਖਿਆ ਬਰਾਬਰ ਹੈ \nਦੋ ਪੂਰਨ ਅੰਕਾਂ ਵਿੱਚੋਂ, ਜੋ ਤੁਹਾਨੂੰ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਉਹ ਹੈ \nਜ਼ੀਰੋ ਤੋਂ ਸਭ ਤੋਂ ਦੂਰ। ਉਦਾਹਰਨ ਲਈ ਨਜ਼ਦੀਕੀ ਅੰਕ (\"14.5\") ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ। \n15 ਵਾਪਸ ਕਰੋ ਅਤੇ ਨਜ਼ਦੀਕੀ ਪੂਰਨ ਅੰਕ (\"-14.5\") ਨੂੰ-15 ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ।", "natural_language": "Punjabi"}
{"task_id": "python/43", "entry_point": "make_a_pile", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return [n + 2*i for i in range(n)]\n", "description": "ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ, ਤੁਹਾਨੂੰ ਪੱਥਰਾਂ ਦੇ n ਪੱਧਰਾਂ ਦਾ ਢੇਰ ਬਣਾਉਣਾ ਪਵੇਗਾ। \nਪਹਿਲੇ ਪੱਧਰ ਵਿੱਚ n ਪੱਥਰ ਹਨ। \nਅਗਲੇ ਪੱਧਰ ਵਿੱਚ ਪੱਥਰਾਂ ਦੀ ਗਿਣਤੀ ਇਹ ਹੈਃ \n- ਅਗਲਾ ਅਜੀਬ ਸੰਖਿਆ ਜੇਕਰ n ਅਜੀਬ ਹੈ। \n- ਅਗਲਾ ਇਵਨ ਨੰਬਰ ਜੇਕਰ n ਇਵਨ ਹੈ। \nਇੱਕ ਸੂਚੀ ਵਿੱਚ ਹਰੇਕ ਪੱਧਰ ਵਿੱਚ ਪੱਥਰਾਂ ਦੀ ਗਿਣਤੀ ਵਾਪਸ ਕਰੋ, ਜਿੱਥੇ ਸੂਚਕਾਂਕ ਉੱਤੇ ਤੱਤ \ni ਪੱਧਰ (i + 1) ਵਿੱਚ ਪੱਥਰਾਂ ਦੀ ਗਿਣਤੀ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ। \n\nਉਦਾਹਰਨਾਂਃ \n>>> ਮੇਕ _ ਏ _ ਪਾਈਲ (3) \n[3,5,7]", "natural_language": "Punjabi"}
{"task_id": "python/44", "entry_point": "words_string", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n", "language": "python", "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n", "description": "ਤੁਹਾਨੂੰ ਕੋਮਾ ਜਾਂ ਖਾਲੀ ਥਾਂਵਾਂ ਦੁਆਰਾ ਵੱਖ ਕੀਤੇ ਸ਼ਬਦਾਂ ਦੀ ਇੱਕ ਸਤਰ ਦਿੱਤੀ ਜਾਵੇਗੀ। ਤੁਹਾਡਾ ਕੰਮ ਹੈ \nਸਤਰ ਨੂੰ ਸ਼ਬਦਾਂ ਵਿੱਚ ਵੰਡਣ ਅਤੇ ਸ਼ਬਦਾਂ ਦੀ ਇੱਕ ਲਡ਼ੀ ਵਾਪਸ ਕਰਨ ਲਈ। \n\nਉਦਾਹਰਨ ਲਈਃ \nਸ਼ਬਦ _ ਸਤਰ (\"ਹੈਲੋ, ਮੇਰਾ ਨਾਮ ਜੌਨ ਹੈ\") = = [\"ਹੈਲੋ\", \"ਮੇਰਾ\", \"ਨਾਮ\", \"ਹੈ\", \"ਜੌਨ\"] \nਸ਼ਬਦ _ ਸਤਰ (\"ਇੱਕ, ਦੋ, ਤਿੰਨ, ਚਾਰ, ਪੰਜ, ਛੇ\") = = [\"ਇੱਕ\", \"ਦੋ\", \"ਤਿੰਨ\", \"ਚਾਰ\", \"ਪੰਜ\", \"ਛੇ\"]", "natural_language": "Punjabi"}
{"task_id": "python/45", "entry_point": "choose_num", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n", "language": "python", "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n", "description": "ਇਹ ਫੰਕਸ਼ਨ ਦੋ ਸਕਾਰਾਤਮਕ ਸੰਖਿਆਵਾਂ x ਅਤੇ y ਲੈਂਦਾ ਹੈ ਅਤੇ ਵਾਪਸ ਕਰਦਾ ਹੈ \nਸਭ ਤੋਂ ਵੱਡਾ ਇਵਨ ਇੰਟੀਜਰ ਨੰਬਰ ਜੋ ਕਿ [x, y] ਸਮੇਤ ਸੀਮਾ ਵਿੱਚ ਹੈ। \nਅਜਿਹਾ ਕੋਈ ਨੰਬਰ ਨਹੀਂ ਹੈ, ਫਿਰ ਫੰਕਸ਼ਨ-1 ਵਾਪਸ ਆਉਣਾ ਚਾਹੀਦਾ ਹੈ। \n\nਉਦਾਹਰਨ ਲਈਃ \nਚੁਣੋ (12,15) = 14 \nਚੁਣੋ (13,12) =-1", "natural_language": "Punjabi"}
{"task_id": "python/46", "entry_point": "rounded_avg", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n", "language": "python", "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "description": "ਤੁਹਾਨੂੰ ਦੋ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਅਤੇ m ਦਿੱਤੇ ਗਏ ਹਨ, ਅਤੇ ਤੁਹਾਡਾ ਕੰਮ ਗਣਨਾ ਕਰਨਾ ਹੈ \nn ਤੋਂ m ਤੱਕ ਦੇ ਪੂਰਨ ਅੰਕਾਂ ਦੀ ਔਸਤ (n ਅਤੇ m ਸਮੇਤ)। \nਨਜ਼ਦੀਕੀ ਪੂਰਨ ਅੰਕ ਦੇ ਉੱਤਰ ਨੂੰ ਗੋਲ ਕਰੋ ਅਤੇ ਉਸ ਨੂੰ ਬਾਈਨਰੀ ਵਿੱਚ ਬਦਲੋ। \nਜੇਕਰ n, m ਤੋਂ ਵੱਡਾ ਹੈ, ਤਾਂ-1 ਵਾਪਸ ਕਰੋ। \nਉਦਾਹਰਨਃ \nਗੋਲ _ ਏਵੀਜੀ (1,5) => \"0ਬੀ11\" \nਗੋਲ _ ਏਵੀਜੀ (7,5) =>-1 \nਗੋਲ _ ਏਵੀਜੀ (10,20) => \"0ਬੀ1111\" \nਗੋਲ _ ਏਵੀਜੀ (20,33) => \"0ਬੀ11010\"", "natural_language": "Punjabi"}
{"task_id": "python/47", "entry_point": "f", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n", "language": "python", "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n", "description": "ਫੰਕਸ਼ਨ f ਨੂੰ ਲਾਗੂ ਕਰੋ ਜੋ n ਨੂੰ ਇੱਕ ਪੈਰਾਮੀਟਰ ਵਜੋਂ ਲੈਂਦਾ ਹੈ, \nਅਤੇ ਅਕਾਰ n ਦੀ ਇੱਕ ਸੂਚੀ ਵਾਪਸ ਕਰਦਾ ਹੈ, ਜਿਵੇਂ ਕਿ ਸੂਚਕਾਂਕ i ਉੱਤੇ ਤੱਤ ਦਾ ਮੁੱਲ i ਦਾ ਫੈਕਟੋਰੀਅਲ ਹੈ ਜੇਕਰ i ਇਵਨ ਹੈ \nਜਾਂ 1 ਤੋਂ i ਤੱਕ ਸੰਖਿਆਵਾਂ ਦਾ ਜੋਡ਼। \nਮੈਂ 1 ਤੋਂ ਸ਼ੁਰੂ ਕਰਦਾ ਹਾਂ। \ni ਦਾ ਫੈਕਟੋਰੀਅਲ 1 ਤੋਂ i (1 * 2 *... * i) ਤੱਕ ਸੰਖਿਆਵਾਂ ਦਾ ਗੁਣਾ ਹੈ। \nਉਦਾਹਰਨਃ \nf (5) = = [1,2,6,24,15]", "natural_language": "Punjabi"}
{"task_id": "python/48", "entry_point": "even_odd_palindrome", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n", "description": "ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ, ਇੱਕ ਟੁਪਲ ਵਾਪਸ ਕਰੋ ਜਿਸ ਦੀ ਸੰਖਿਆ ਇਵਨ ਅਤੇ ਔਡ ਹੈ \nਪੂਰਨ ਅੰਕ ਪਾਲੀਨਡਰੋਮ ਜੋ ਸੀਮਾ (1, n) ਦੇ ਅੰਦਰ ਆਉਂਦੇ ਹਨ, ਸਮੇਤ। \n\nਉਦਾਹਰਨ 1: \n\nਇੰਪੁੱਟਃ 3 \nਆਉਟਪੁੱਟਃ (1,2) \nਵਿਆਖਿਆਃ \nਪੂਰਨ ਅੰਕ ਪੈਲਿੰਡਰੋਮ 1,2,3 ਹਨ. ਉਹਨਾਂ ਵਿੱਚੋਂ ਇੱਕ ਇਵਨ ਹੈ, ਅਤੇ ਉਹਨਾਂ ਵਿੱਚੋਂ ਦੋ ਔਡ ਹਨ। \n\nਉਦਾਹਰਨ 2: \n\nਇੰਪੁੱਟਃ 12 \nਆਉਟਪੁੱਟਃ (4,6) \nਵਿਆਖਿਆਃ \nਪੂਰਨ ਅੰਕ ਪੈਲਿੰਡਰੋਮ 1,2,3,4,5,6,7,8,9,11 ਹਨ. ਉਹਨਾਂ ਵਿੱਚੋਂ ਚਾਰ ਇਵਨ ਹਨ, ਅਤੇ ਉਹਨਾਂ ਵਿੱਚੋਂ 6 ਔਡ ਹਨ। \n\nਨੋਟਃ \n1. 1 <= n <= 10 ^ 3 \n2. ਵਾਪਸ ਆਏ ਟੁਪਲ ਵਿੱਚ ਕ੍ਰਮਵਾਰ ਇਵਨ ਅਤੇ ਔਡ ਇੰਟੀਜਰ ਪੈਲਿੰਡਰੋਮ ਦੀ ਗਿਣਤੀ ਹੁੰਦੀ ਹੈ।", "natural_language": "Punjabi"}
{"task_id": "python/49", "entry_point": "move_one_ball", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n", "language": "python", "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n", "description": "ਸਾਡੇ ਕੋਲ N ਪੂਰਨ ਅੰਕ arr [1], arr [2],..., arr [N] ਦੀ ਇੱਕ ਐਰੇ'arr'ਹੈ। \nਐਰੇ ਵਿੱਚ ਨੰਬਰ ਬੇਤਰਤੀਬੇ ਕ੍ਰਮਬੱਧ ਕੀਤੇ ਜਾਣਗੇ। ਤੁਹਾਡਾ ਕੰਮ ਇਹ ਨਿਰਧਾਰਤ ਕਰਨਾ ਹੈ ਕਿ ਕੀ \nਪ੍ਰਦਰਸ਼ਨ ਕਰਕੇ ਗੈਰ-ਘਟਦੇ ਕ੍ਰਮ ਵਿੱਚ ਇੱਕ ਐਰੇ ਨੂੰ ਕ੍ਰਮਬੱਧ ਕਰਨਾ ਸੰਭਵ ਹੈ \nਦਿੱਤੇ ਐਰੇ ਉੱਤੇ ਹੇਠ ਦਿੱਤੀ ਕਾਰਵਾਈਃ \nਤੁਹਾਨੂੰ ਕਿਸੇ ਵੀ ਗਿਣਤੀ ਵਿੱਚ ਸਹੀ ਸ਼ਿਫਟ ਓਪਰੇਸ਼ਨ ਕਰਨ ਦੀ ਆਗਿਆ ਹੈ। \n\nਇੱਕ ਸੱਜੇ ਸ਼ਿਫਟ ਓਪਰੇਸ਼ਨ ਦਾ ਅਰਥ ਹੈ ਐਰੇ ਦੇ ਸਾਰੇ ਤੱਤਾਂ ਨੂੰ ਇੱਕ ਨਾਲ ਤਬਦੀਲ ਕਰਨਾ। \nਸਹੀ ਦਿਸ਼ਾ ਵਿੱਚ ਸਥਿਤੀ। ਐਰੇ ਦੇ ਆਖਰੀ ਤੱਤ ਨੂੰ ਇੱਥੇ ਲਿਜਾਇਆ ਜਾਵੇਗਾ \nਐਰੇ ਵਿੱਚ ਸ਼ੁਰੂਆਤੀ ਸਥਿਤੀ ਭਾਵ 0 ਵਾਂ ਸੂਚਕਾਂਕ। \n\nਜੇ ਉੱਪਰ ਦਿੱਤੀ ਕਾਰਵਾਈ ਕਰਕੇ ਕ੍ਰਮਬੱਧ ਐਰੇ ਪ੍ਰਾਪਤ ਕਰਨਾ ਸੰਭਵ ਹੈ \nਫਿਰ ਸਹੀ ਵਾਪਸ ਕਰੋ ਨਹੀਂ ਤਾਂ ਗਲਤ ਵਾਪਸ ਕਰੋ। \nਜੇਕਰ ਦਿੱਤਾ ਗਿਆ ਐਰੇ ਖਾਲੀ ਹੈ ਤਾਂ ਸਹੀ ਵਾਪਸ ਕਰੋ। \n\nਨੋਟਃ ਦਿੱਤੀ ਗਈ ਸੂਚੀ ਵਿੱਚ ਵਿਲੱਖਣ ਤੱਤ ਹੋਣ ਦੀ ਗਾਰੰਟੀ ਹੈ। \n\nਉਦਾਹਰਨ ਲਈਃ \n\nਮੂਵ _ ਵਨ _ ਬਾਲ ([3,4,5,1,2]) = => ਸੱਚ \nਵਿਆਖਿਆਃ 2 ਸੱਜੇ ਸ਼ਿਫਟ ਓਪਰੇਸ਼ਨਾਂ ਵਿੱਚ ਪ੍ਰਦਰਸ਼ਨ ਕਰਕੇ, ਗੈਰ-ਘਟਦਾ ਕ੍ਰਮ ਕਰ ਸਕਦਾ ਹੈ \nਦਿੱਤੇ ਐਰੇ ਲਈ ਪ੍ਰਾਪਤ ਕੀਤਾ ਜਾ ਸਕਦਾ ਹੈ। \nਮੂਵ _ ਵਨ _ ਬਾਲ ([3,5,4,1,2]) = => ਗਲਤ \nਵਿਆਖਿਆਃ ਦਿੱਤੇ ਗਏ ਲਈ ਗੈਰ-ਘਟਦੇ ਕ੍ਰਮ ਨੂੰ ਪ੍ਰਾਪਤ ਕਰਨਾ ਸੰਭਵ ਨਹੀਂ ਹੈ \nਕਿਸੇ ਵੀ ਗਿਣਤੀ ਵਿੱਚ ਸਹੀ ਸ਼ਿਫਟ ਓਪਰੇਸ਼ਨ ਕਰਕੇ ਐਰੇ.", "natural_language": "Punjabi"}
{"task_id": "python/50", "entry_point": "exchange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n", "language": "python", "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n", "description": "ਇਸ ਸਮੱਸਿਆ ਵਿੱਚ, ਤੁਸੀਂ ਇੱਕ ਫੰਕਸ਼ਨ ਲਾਗੂ ਕਰੋਗੇ ਜੋ ਸੰਖਿਆਵਾਂ ਦੀਆਂ ਦੋ ਸੂਚੀਆਂ ਲੈਂਦਾ ਹੈ, \nਅਤੇ ਇਹ ਨਿਰਧਾਰਤ ਕਰਦਾ ਹੈ ਕਿ ਕੀ ਤੱਤਾਂ ਦਾ ਆਦਾਨ-ਪ੍ਰਦਾਨ ਕਰਨਾ ਸੰਭਵ ਹੈ \nਉਹਨਾਂ ਦੇ ਵਿਚਕਾਰ lst1 ਨੂੰ ਸਿਰਫ ਇਵਨ ਨੰਬਰਾਂ ਦੀ ਸੂਚੀ ਬਣਾਉਣ ਲਈ। \nlst1 ਅਤੇ lst2 ਦੇ ਵਿਚਕਾਰ ਅਦਾਨ-ਪ੍ਰਦਾਨ ਕੀਤੇ ਤੱਤਾਂ ਦੀ ਗਿਣਤੀ ਦੀ ਕੋਈ ਸੀਮਾ ਨਹੀਂ ਹੈ। \nਜੇ lst1 ਅਤੇ lst2 ਦੇ ਵਿਚਕਾਰ ਤੱਤਾਂ ਦਾ ਆਦਾਨ-ਪ੍ਰਦਾਨ ਕਰਨਾ ਸੰਭਵ ਹੈ \nlst1 ਦੇ ਸਾਰੇ ਤੱਤ ਬਰਾਬਰ ਹੋਣ ਲਈ, \"ਹਾਂ\" ਵਾਪਸ ਕਰੋ। \nਨਹੀਂ ਤਾਂ, \"ਨਹੀਂ\" ਵਾਪਸ ਕਰੋ। \nਉਦਾਹਰਨ ਲਈਃ \nਐਕਸਚੇਂਜ ([1,2,3,4], [1,2,3,4]) => \"ਹਾਂ\" \nਐਕਸਚੇਂਜ ([1,2,3,4], [1,5,3,4]) => \"ਨਹੀਂ\" \nਇਹ ਮੰਨਿਆ ਜਾਂਦਾ ਹੈ ਕਿ ਇਨਪੁਟ ਸੂਚੀਆਂ ਖਾਲੀ ਨਹੀਂ ਹੋਣਗੀਆਂ।", "natural_language": "Punjabi"}
{"task_id": "python/51", "entry_point": "reverse_delete", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n", "language": "python", "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n", "description": "ਕੰਮ \nਸਾਨੂੰ ਦੋ ਸਤਰ s ਅਤੇ c ਦਿੱਤੇ ਗਏ ਹਨ, ਤੁਹਾਨੂੰ s ਵਿੱਚ ਸਾਰੇ ਅੱਖਰ ਮਿਟਾਉਣੇ ਪੈਣਗੇ ਜੋ c ਵਿੱਚ ਕਿਸੇ ਵੀ ਅੱਖਰ ਦੇ ਬਰਾਬਰ ਹਨ। \nਫਿਰ ਜਾਂਚ ਕਰੋ ਕਿ ਕੀ ਨਤੀਜਾ ਸਤਰ ਪਾਲੀਂਡਰੋਮ ਹੈ। \nਇੱਕ ਸਤਰ ਨੂੰ ਪਾਲੀਂਡਰੋਮ ਕਿਹਾ ਜਾਂਦਾ ਹੈ ਜੇਕਰ ਇਹ ਅੱਗੇ ਵਾਂਗ ਹੀ ਪਿੱਛੇ ਵੱਲ ਪਡ਼੍ਹਦੀ ਹੈ। \nਤੁਹਾਨੂੰ ਚੈੱਕ ਲਈ ਨਤੀਜਾ ਸਤਰ ਅਤੇ ਸਹੀ/ਗਲਤ ਵਾਲਾ ਇੱਕ ਟਿਪਲ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ। \nਉਦਾਹਰਨ \ns = \"abcd\", c = \"ae\" ਲਈ, ਨਤੀਜਾ ('bcd', ਗਲਤ) ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ। \ns = \"abcdef\" ਲਈ, c = \"b\" ਨਤੀਜਾ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ ('acdef', ਗਲਤ) \ns = \"abcdedcba\", c = \"ab\" ਲਈ, ਨਤੀਜਾ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ ('cdedc', ਸੱਚ)।", "natural_language": "Punjabi"}
{"task_id": "python/52", "entry_point": "max_fill", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n", "language": "python", "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n", "description": "ਤੁਹਾਨੂੰ ਖੂਹਾਂ ਦਾ ਇੱਕ ਆਇਤਾਕਾਰ ਗਰਿੱਡ ਦਿੱਤਾ ਜਾਂਦਾ ਹੈ। ਹਰੇਕ ਕਤਾਰ ਇੱਕ ਖੂਹ ਨੂੰ ਦਰਸਾਉਂਦੀ ਹੈ, \nਅਤੇ ਇੱਕ ਕਤਾਰ ਵਿੱਚ ਹਰੇਕ 1 ਪਾਣੀ ਦੀ ਇੱਕ ਇਕਾਈ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ। \nਹਰੇਕ ਖੂਹ ਵਿੱਚ ਇੱਕ ਅਨੁਸਾਰੀ ਬਾਲਟੀ ਹੁੰਦੀ ਹੈ ਜਿਸ ਦੀ ਵਰਤੋਂ ਇਸ ਵਿੱਚੋਂ ਪਾਣੀ ਕੱਢਣ ਲਈ ਕੀਤੀ ਜਾ ਸਕਦੀ ਹੈ। \nਅਤੇ ਸਾਰੀਆਂ ਬਾਲਟੀਆਂ ਦੀ ਸਮਰੱਥਾ ਇੱਕੋ ਜਿਹੀ ਹੈ। \nਤੁਹਾਡਾ ਕੰਮ ਖੂਹਾਂ ਨੂੰ ਖਾਲੀ ਕਰਨ ਲਈ ਬਾਲਟੀਆਂ ਦੀ ਵਰਤੋਂ ਕਰਨਾ ਹੈ। \nਕਿੰਨੀ ਵਾਰ ਤੁਹਾਨੂੰ ਬਾਲਟੀਆਂ ਨੂੰ ਘੱਟ ਕਰਨ ਦੀ ਜ਼ਰੂਰਤ ਹੈ। \n\nਉਦਾਹਰਨ 1: \nਇੰਪੁੱਟਃ \nਗਰਿੱਡਃ [[0,0,1, 0], [0,1,0, 0], [1,1,1, 1] \nਬਾਲਟੀ ਸਮਰੱਥਾਃ 1 \nਆਉਟਪੁੱਟਃ 6 \n\nਉਦਾਹਰਨ 2: \nਇੰਪੁੱਟਃ \nਗਰਿੱਡਃ [[0, 0,1,1], [0,0,0, 0], [1,1,1, 1], [0, 1,1,1] \nਬਾਲਟੀ ਸਮਰੱਥਾਃ 2 \nਆਉਟਪੁੱਟਃ 5 \n\nਉਦਾਹਰਨ 3: \nਇੰਪੁੱਟਃ \nਗਰਿੱਡਃ [0,0,0], [0,0,0] \nਬਾਲਟੀ ਸਮਰੱਥਾਃ 5 \nਆਉਟਪੁੱਟਃ 0 \n\nਪਾਬੰਦੀਆਂਃ \nਸਾਰੇ ਖੂਹਾਂ ਦੀ ਲੰਬਾਈ ਇੱਕੋ ਜਿਹੀ ਹੁੰਦੀ ਹੈ। \n* 1 <= grid.length <= 10 ^ 2 \n* 1 <= ਗਰਿੱਡ [:, 1]. ਲੰਬਾਈ <= 10 ^ 2 \nਗਰਿੱਡ [i] [j]-> 0। 1 \n* 1 <= ਸਮਰੱਥਾ <= 10", "natural_language": "Punjabi"}
{"task_id": "python/53", "entry_point": "select_words", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n", "language": "python", "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n", "description": "ਇੱਕ ਸਤਰ s ਅਤੇ ਇੱਕ ਕੁਦਰਤੀ ਨੰਬਰ n ਦੇ ਮੱਦੇਨਜ਼ਰ, ਤੁਹਾਨੂੰ ਲਾਗੂ ਕਰਨ ਦਾ ਕੰਮ ਸੌਂਪਿਆ ਗਿਆ ਹੈ। \nਇੱਕ ਫੰਕਸ਼ਨ ਜੋ ਸਤਰ s ਤੋਂ ਸਾਰੇ ਸ਼ਬਦਾਂ ਦੀ ਇੱਕ ਸੂਚੀ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜਿਸ ਵਿੱਚ ਬਿਲਕੁਲ \nn ਵਿਅੰਜਨ, ਕ੍ਰਮ ਵਿੱਚ ਇਹ ਸ਼ਬਦ ਸਤਰ s ਵਿੱਚ ਦਿਖਾਈ ਦਿੰਦੇ ਹਨ। \nਜੇਕਰ ਸਤਰ s ਖਾਲੀ ਹੈ ਤਾਂ ਫੰਕਸ਼ਨ ਨੂੰ ਇੱਕ ਖਾਲੀ ਸੂਚੀ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ। \nਨੋਟਃ ਤੁਸੀਂ ਮੰਨ ਸਕਦੇ ਹੋ ਕਿ ਇੰਪੁੱਟ ਸਤਰ ਵਿੱਚ ਸਿਰਫ ਅੱਖਰ ਅਤੇ ਖਾਲੀ ਥਾਂਵਾਂ ਹਨ। \nਉਦਾਹਰਨਾਂਃ \nਚੁਣੋ _ ਸ਼ਬਦ (\"ਮੈਰੀ ਕੋਲ ਇੱਕ ਛੋਟਾ ਜਿਹਾ ਭੇਡੂ ਸੀ\", 4) = => [\"ਛੋਟਾ\"] \nਚੁਣੋ _ ਸ਼ਬਦ (\"ਮੈਰੀ ਦਾ ਇੱਕ ਛੋਟਾ ਜਿਹਾ ਭੇਡੂ ਸੀ\", 3) = => [\"ਮੈਰੀ\", \"ਭੇਡੂ\"] \nਸ਼ਬਦ ਚੁਣੋ (\"ਸਧਾਰਨ ਚਿੱਟੀ ਥਾਂ\", 2) = => [] \nਸ਼ਬਦ ਚੁਣੋ (\"ਹੈਲੋ ਵਰਲਡ\", 4) = => [\"ਵਰਲਡ\"] \nਸ਼ਬਦ ਚੁਣੋ (\"ਅੰਕਲ ਸੈਮ\", 3) = => [\"ਅੰਕਲ\"]", "natural_language": "Punjabi"}
{"task_id": "python/54", "entry_point": "maximum", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n", "language": "python", "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n", "description": "ਪੂਰਨ ਅੰਕ ਦੀ ਇੱਕ ਐਰੇ arr ਅਤੇ ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ k ਦਿੱਤਾ ਗਿਆ ਹੈ, ਇੱਕ ਕ੍ਰਮਬੱਧ ਸੂਚੀ ਵਾਪਸ ਕਰੋ \nਅਰਰ ਵਿੱਚ ਵੱਧ ਤੋਂ ਵੱਧ k ਸੰਖਿਆਵਾਂ ਦੇ ਨਾਲ k ਦੀ ਲੰਬਾਈ। \n\nਉਦਾਹਰਨ 1: \n\nਇਨਪੁਟਃ arr = [-3,-4,5], k = 3 \nਆਉਟਪੁੱਟਃ [-4,-3,5] \n\nਉਦਾਹਰਨ 2: \n\nਇਨਪੁਟਃ arr = [4,-4,4], k = 2 \nਆਉਟਪੁੱਟਃ [4,4] \n\nਉਦਾਹਰਨ 3: \n\nਇੰਪੁੱਟਃ arr = [-3,2,1,2,-1,-2,1], k = 1 \nਆਉਟਪੁੱਟਃ [2] \n\nਨੋਟਃ \n1. ਐਰੇ ਦੀ ਲੰਬਾਈ [1000] ਦੀ ਸੀਮਾ ਵਿੱਚ ਹੋਵੇਗੀ। \n2. ਐਰੇ ਵਿੱਚ ਤੱਤ [-1000] ਦੀ ਸੀਮਾ ਵਿੱਚ ਹੋਣਗੇ। \n3. 0 <= k <= ਲੇਨ (arr)", "natural_language": "Punjabi"}
{"task_id": "python/55", "entry_point": "add_elements", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n", "description": "ਪੂਰਨ ਅੰਕ arr ਅਤੇ ਇੱਕ ਪੂਰਨ ਅੰਕ k ਦੀ ਇੱਕ ਗੈਰ-ਖਾਲੀ ਐਰੇ ਦਿੱਤੀ ਗਈ ਹੈ, ਵਾਪਸ ਕਰੋ \narr ਦੇ ਪਹਿਲੇ k ਤੱਤਾਂ ਤੋਂ ਵੱਧ ਤੋਂ ਵੱਧ ਦੋ ਅੰਕਾਂ ਵਾਲੇ ਤੱਤਾਂ ਦਾ ਜੋਡ਼। \n\nਉਦਾਹਰਨਃ \n\nਇਨਪੁਟਃ arr = [111,21,3, 4000,5,6, 7,8,9], k = 4 \nਆਉਟਪੁੱਟਃ 24 #21 + 3 ਦਾ ਜੋਡ਼ \n\nਪਾਬੰਦੀਆਂਃ \n1. 1 <= ਲੇਨ (arr) <= 100 \n2. 1 <= k <= ਲੇਨ (arr)", "natural_language": "Punjabi"}
{"task_id": "python/56", "entry_point": "intersection", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n", "language": "python", "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n", "description": "ਤੁਹਾਨੂੰ ਦੋ ਅੰਤਰਾਲ ਦਿੱਤੇ ਗਏ ਹਨ, \nਜਿੱਥੇ ਹਰੇਕ ਅੰਤਰਾਲ ਪੂਰਨ ਅੰਕਾਂ ਦਾ ਇੱਕ ਜੋਡ਼ਾ ਹੁੰਦਾ ਹੈ। ਉਦਾਹਰਨ ਲਈ, ਅੰਤਰਾਲ = (ਸ਼ੁਰੂ, ਅੰਤ) = (1,2)। \nਦਿੱਤੇ ਗਏ ਅੰਤਰਾਲ ਬੰਦ ਹੁੰਦੇ ਹਨ ਜਿਸਦਾ ਅਰਥ ਹੈ ਕਿ ਅੰਤਰਾਲ (ਅਰੰਭ, ਅੰਤ) \nਇਸ ਵਿੱਚ ਸ਼ੁਰੂਆਤ ਅਤੇ ਅੰਤ ਦੋਵੇਂ ਸ਼ਾਮਲ ਹਨ। \nਹਰੇਕ ਦਿੱਤੇ ਗਏ ਅੰਤਰਾਲ ਲਈ, ਇਹ ਮੰਨਿਆ ਜਾਂਦਾ ਹੈ ਕਿ ਇਸ ਦੀ ਸ਼ੁਰੂਆਤ ਇਸ ਦੇ ਅੰਤ ਤੋਂ ਘੱਟ ਜਾਂ ਬਰਾਬਰ ਹੈ। \nਤੁਹਾਡਾ ਕੰਮ ਇਹ ਨਿਰਧਾਰਤ ਕਰਨਾ ਹੈ ਕਿ ਕੀ ਇਨ੍ਹਾਂ ਦੋਵਾਂ ਦੇ ਇੰਟਰਸੈਕਸ਼ਨ ਦੀ ਲੰਬਾਈ \nਅੰਤਰਾਲ ਇੱਕ ਪ੍ਰਮੁੱਖ ਸੰਖਿਆ ਹੈ। \nਉਦਾਹਰਨ ਲਈ, ਅੰਤਰਾਲਾਂ (1,3), (2,4) ਦਾ ਇੰਟਰਸੈਕਸ਼ਨ (2,3) ਹੈ। \nਜਿਸ ਦੀ ਲੰਬਾਈ 1 ਹੈ, ਜੋ ਕਿ ਇੱਕ ਪ੍ਰਮੁੱਖ ਸੰਖਿਆ ਨਹੀਂ ਹੈ। \nਜੇਕਰ ਇੰਟਰਸੈਕਸ਼ਨ ਦੀ ਲੰਬਾਈ ਇੱਕ ਪ੍ਰਾਈਮ ਨੰਬਰ ਹੈ, ਤਾਂ \"ਹਾਂ\" ਵਾਪਸ ਕਰੋ, \nਨਹੀਂ ਤਾਂ, \"ਨਹੀਂ\" ਵਾਪਸ ਕਰੋ। \nਜੇ ਦੋਵੇਂ ਅੰਤਰਾਲ ਇੱਕ ਦੂਜੇ ਨੂੰ ਨਹੀਂ ਕੱਟਦੇ, ਤਾਂ \"ਨਹੀਂ\" ਵਾਪਸ ਕਰੋ। \n\n[ਇਨਪੁਟ/ਆਉਟਪੁੱਟ] ਨਮੂਨੇਃ \nਇੰਟਰਸੈਕਸ਼ਨ ((1,2,3)) = => \"NO\" \nਇੰਟਰਸੈਕਸ਼ਨ ((-1,1), (0,4)) = => \"NO\" \nਇੰਟਰਸੈਕਸ਼ਨ ((-3,-1), (-5,5)) = => \"ਹਾਂ\"", "natural_language": "Punjabi"}
{"task_id": "python/57", "entry_point": "tri", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n", "language": "python", "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n", "description": "ਹਰ ਕੋਈ ਫਿਬੋਨਾਚੀ ਤਰਤੀਬ ਨੂੰ ਜਾਣਦਾ ਹੈ, ਇਸ ਦਾ ਗਣਿਤ ਸ਼ਾਸਤਰੀਆਂ ਦੁਆਰਾ ਡੂੰਘਾਈ ਨਾਲ ਅਧਿਐਨ ਕੀਤਾ ਗਿਆ ਸੀ \nਪਿਛਲੀਆਂ ਦੋ ਸਦੀਆਂ ਤੋਂ ਲੋਕ ਜੋ ਨਹੀਂ ਜਾਣਦੇ ਉਹ ਹੈ ਟ੍ਰਿਬੋਨਾਚੀ ਕ੍ਰਮ। \nਟ੍ਰਿਬੋਨਾਚੀ ਤਰਤੀਬ ਨੂੰ ਪੁਨਰਵਰਤਨ ਦੁਆਰਾ ਪਰਿਭਾਸ਼ਿਤ ਕੀਤਾ ਜਾਂਦਾ ਹੈਃ \nਟ੍ਰਾਈ (1) = 3 \nਟ੍ਰਾਈ (n) = 1 + n/2, ਜੇਕਰ n ਇਵਨ ਹੋਵੇ। \nਟ੍ਰਾਈ (ਐੱਨ) = ਟ੍ਰਾਈ (ਐੱਨ-1) + ਟ੍ਰਾਈ (ਐੱਨ-2) + ਟ੍ਰਾਈ (ਐੱਨ + 1), ਜੇਕਰ ਐੱਨ ਔਡ ਹੈ। \nਉਦਾਹਰਨ ਲਈਃ \nਟ੍ਰਾਈ (2) = 1 + (2/2) = 2 \nਟ੍ਰਾਈ (4) = 3 \nਟ੍ਰਾਈ (3) = ਟ੍ਰਾਈ (2) + ਟ੍ਰਾਈ (1) + ਟ੍ਰਾਈ (4) \n= 2 + 3 + 3 = 8 \nਤੁਹਾਨੂੰ ਇੱਕ ਗੈਰ-ਨਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਨੰਬਰ n ਦਿੱਤਾ ਜਾਂਦਾ ਹੈ, ਤੁਹਾਨੂੰ ਇੱਕ ਸੂਚੀ ਵਾਪਸ ਕਰਨੀ ਪਵੇਗੀ \nਟ੍ਰਿਬੋਨਾਚੀ ਤਰਤੀਬ ਦੇ ਪਹਿਲੇ n + 1 ਨੰਬਰ। \nਉਦਾਹਰਨਾਂਃ \nਟ੍ਰਾਈ (3) = [1,3,2,8]", "natural_language": "Punjabi"}
{"task_id": "python/58", "entry_point": "digits", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n", "language": "python", "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n", "description": "ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ, ਤਾਂ ਔਡ ਅੰਕਾਂ ਦਾ ਗੁਣਨਫਲ ਵਾਪਸ ਕਰੋ। \n0 ਵਾਪਸ ਕਰੋ ਜੇਕਰ ਸਾਰੇ ਅੰਕ ਬਰਾਬਰ ਹਨ। \nਉਦਾਹਰਨ ਲਈਃ \nਅੰਕ (1) = = 1 \nਅੰਕ (4) = = 0 \nਅੰਕ (235) = = 15", "natural_language": "Punjabi"}
{"task_id": "python/59", "entry_point": "is_nested", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n", "language": "python", "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n", "description": "ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਇੱਕ ਸਤਰ ਨੂੰ ਇੰਪੁੱਟ ਵਜੋਂ ਲੈਂਦਾ ਹੈ ਜਿਸ ਵਿੱਚ ਸਿਰਫ ਵਰਗ ਬਰੈਕਟ ਹੁੰਦੇ ਹਨ। \nਫੰਕਸ਼ਨ ਨੂੰ ਸਹੀ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਜੇ ਅਤੇ ਸਿਰਫ ਤਾਂ ਹੀ ਜੇ ਬਰੈਕਟ ਦੀ ਇੱਕ ਜਾਇਜ਼ ਲਡ਼ੀ ਹੋਵੇ \nਜਿੱਥੇ ਬਾਅਦ ਵਿੱਚ ਘੱਟੋ ਘੱਟ ਇੱਕ ਬਰੈਕਟ ਨੂੰ ਨੈਸਟ ਕੀਤਾ ਜਾਂਦਾ ਹੈ। \n\nis _ nested ('[[]]') ਸੱਚ ਹੈ \nis _ nested ('[]]]]] [[[[]') ਗਲਤ ਹੈ \nis _ nested ('[] []') ਗਲਤ ਹੈ \nis _ nested ('[]') ਗਲਤ ਹੈ \nis _ nested ('[[] []]') ਸੱਚ ਹੈ \nis _ nested ('[[]] [[') ਸੱਚ ਹੈ", "natural_language": "Punjabi"}
{"task_id": "python/60", "entry_point": "sum_squares", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n", "description": "ਤੁਹਾਨੂੰ ਸੰਖਿਆਵਾਂ ਦੀ ਸੂਚੀ ਦਿੱਤੀ ਜਾਂਦੀ ਹੈ। \nਤੁਹਾਨੂੰ ਦਿੱਤੀ ਗਈ ਸੂਚੀ ਵਿੱਚ ਵਰਗ ਸੰਖਿਆਵਾਂ ਦਾ ਜੋਡ਼ ਵਾਪਸ ਕਰਨ ਦੀ ਜ਼ਰੂਰਤ ਹੈ, \nਸੂਚੀ ਵਿੱਚ ਹਰੇਕ ਤੱਤ ਨੂੰ ਪਹਿਲਾਂ ਉੱਪਰਲੇ ਇੰਟ (ਛੱਤ) ਵਿੱਚ ਗੋਲ ਕਰੋ। \nਉਦਾਹਰਨਾਂਃ \nlst = [1,2,3] ਲਈ ਆਉਟਪੁੱਟ 14 ਹੋਣੀ ਚਾਹੀਦੀ ਹੈ। \nlst = [1,4,9] ਲਈ ਆਉਟਪੁੱਟ 98 ਹੋਣੀ ਚਾਹੀਦੀ ਹੈ। \nlst = [1,3,5, 7] ਲਈ ਆਉਟਪੁੱਟ 84 ਹੋਣੀ ਚਾਹੀਦੀ ਹੈ। \nlst = [1.4,4.2, 0] ਲਈ ਆਉਟਪੁੱਟ 29 ਹੋਣੀ ਚਾਹੀਦੀ ਹੈ। \nlst = [-2.4,1, 1] ਲਈ ਆਉਟਪੁੱਟ 6 ਹੋਣੀ ਚਾਹੀਦੀ ਹੈ।", "natural_language": "Punjabi"}
{"task_id": "python/61", "entry_point": "check_if_last_char_is_a_letter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n", "description": "ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਸਹੀ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੇਕਰ ਆਖਰੀ ਅੱਖਰ ਹੋਵੇ \nਇੱਕ ਦਿੱਤੀ ਸਤਰ ਦਾ ਇੱਕ ਵਰਣਮਾਲਾ ਅੱਖਰ ਹੈ ਅਤੇ ਨਹੀਂ ਹੈ \nਇੱਕ ਸ਼ਬਦ ਦਾ ਇੱਕ ਹਿੱਸਾ, ਅਤੇ ਗਲਤ ਹੋਰ. \nਨੋਟਃ \"ਸ਼ਬਦ\" ਅੱਖਰਾਂ ਦਾ ਇੱਕ ਸਮੂਹ ਹੈ ਜੋ ਸਪੇਸ ਦੁਆਰਾ ਵੱਖ ਕੀਤਾ ਜਾਂਦਾ ਹੈ। \n\nਉਦਾਹਰਨਾਂਃ \nਚੈੱਕ ਕਰੋ _ ਜੇਕਰ _ ਆਖਰੀ _ ਚਾਰ _ ਇੱਕ _ ਅੱਖਰ ਹੈ (\"ਐਪਲ ਪਾਈ\") ਗਲਤ ਹੈ \nਚੈੱਕ ਕਰੋ _ ਜੇਕਰ _ ਆਖਰੀ _ ਚਾਰ _ ਹੈ _ a _ ਅੱਖਰ (\"ਐਪਲ ਪਾਈ ਈ\") ਸੱਚ ਹੈ \nਚੈੱਕ ਕਰੋ _ ਜੇਕਰ _ ਆਖਰੀ _ ਚਾਰ _ ਇੱਕ _ ਅੱਖਰ ਹੈ (\"ਐਪਲ ਪਾਈ ਈ\") ਗਲਤ ਹੈ \nਚੈੱਕ ਕਰੋ _ ਜੇਕਰ _ ਆਖਰੀ _ ਚਾਰ _ ਹੈ _ a _ ਅੱਖਰ (\"\") ਗਲਤ ਹੈ", "natural_language": "Punjabi"}
{"task_id": "python/62", "entry_point": "can_arrange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n", "language": "python", "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n", "description": "ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਇੱਕ ਤੱਤ ਦਾ ਸਭ ਤੋਂ ਵੱਡਾ ਸੂਚਕਾਂਕ ਦਿੰਦਾ ਹੈ ਜੋ \nਇਸ ਤੋਂ ਤੁਰੰਤ ਪਹਿਲਾਂ ਵਾਲੇ ਤੱਤ ਤੋਂ ਵੱਡਾ ਜਾਂ ਬਰਾਬਰ ਨਹੀਂ ਹੈ। \nਅਜਿਹਾ ਕੋਈ ਤੱਤ ਮੌਜੂਦ ਨਹੀਂ ਹੈ ਤਾਂ-1 ਵਾਪਸ ਕਰੋ। ਦਿੱਤੀ ਗਈ ਐਰੇ ਵਿੱਚ ਸ਼ਾਮਲ ਨਹੀਂ ਹੋਵੇਗਾ \nਡੁਪਲੀਕੇਟ ਮੁੱਲ. \n\nਉਦਾਹਰਨਾਂਃ \nਕਰ ਸਕਦੇ ਹਨ ([1,2,4, 3,5]) = 3 \nਕਰ ਸਕਦੇ ਹੋ ([1,2,3]) =-1", "natural_language": "Punjabi"}
{"task_id": "python/63", "entry_point": "largest_smallest_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "language": "python", "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "description": "ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਇੱਕ ਟੁਪਲ (a, b) ਦਿੰਦਾ ਹੈ, ਜਿੱਥੇ'a'ਹੈ। \nਨਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕਾਂ ਵਿੱਚੋਂ ਸਭ ਤੋਂ ਵੱਡਾ, ਅਤੇ'b'ਸਭ ਤੋਂ ਛੋਟਾ ਹੈ \nਇੱਕ ਸੂਚੀ ਵਿੱਚ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ। \nਜੇਕਰ ਕੋਈ ਨਕਾਰਾਤਮਕ ਜਾਂ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਨਹੀਂ ਹਨ, ਤਾਂ ਉਹਨਾਂ ਨੂੰ None ਦੇ ਰੂਪ ਵਿੱਚ ਵਾਪਸ ਕਰੋ। \n\nਉਦਾਹਰਨਾਂਃ \nਸਭ ਤੋਂ ਵੱਡੇ _ ਸਭ ਤੋਂ ਛੋਟੇ _ ਪੂਰਨ ਅੰਕ ([2,4,1,3,5,7]) = = (ਕੋਈ ਨਹੀਂ, 1) \nਸਭ ਤੋਂ ਵੱਡੇ _ ਸਭ ਤੋਂ ਛੋਟੇ _ ਪੂਰਨ ਅੰਕ ([]) = = (ਕੋਈ ਨਹੀਂ, ਕੋਈ ਨਹੀਂ) \nਸਭ ਤੋਂ ਵੱਡੇ _ ਸਭ ਤੋਂ ਛੋਟੇ _ ਪੂਰਨ ਅੰਕ ([0]) = = (ਕੋਈ ਨਹੀਂ, ਕੋਈ ਨਹੀਂ)", "natural_language": "Punjabi"}
{"task_id": "python/64", "entry_point": "special_factorial", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n", "language": "python", "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "description": "ਬ੍ਰਾਜ਼ੀਲ ਦੇ ਫੈਕਟੋਰੀਅਲ ਨੂੰ ਇਸ ਤਰ੍ਹਾਂ ਪਰਿਭਾਸ਼ਿਤ ਕੀਤਾ ਗਿਆ ਹੈਃ \nਬ੍ਰਾਜ਼ਿਲੀਅਨ _ ਫੈਕਟੋਰੀਅਲ (n) = n! * (n-1)! * (n-2)! *... * 1! \nਜਿੱਥੇ n> 0 \n\nਉਦਾਹਰਨ ਲਈਃ \n>>> ਸਪੈਸ਼ਲ _ ਫੈਕਟੋਰੀਅਲ (4) \n288 \n\nਫੰਕਸ਼ਨ ਇੱਕ ਪੂਰਨ ਅੰਕ ਨੂੰ ਇੰਪੁੱਟ ਦੇ ਰੂਪ ਵਿੱਚ ਪ੍ਰਾਪਤ ਕਰੇਗਾ ਅਤੇ ਵਿਸ਼ੇਸ਼ ਨੂੰ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ \nਇਸ ਪੂਰਨ ਅੰਕ ਦਾ ਫੈਕਟੋਰੀਅਲ।", "natural_language": "Punjabi"}
{"task_id": "python/65", "entry_point": "words_in_sentence", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n", "language": "python", "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n", "description": "ਤੁਹਾਨੂੰ ਇੱਕ ਸਤਰ ਦਿੱਤੀ ਜਾਂਦੀ ਹੈ ਜੋ ਇੱਕ ਵਾਕ ਨੂੰ ਦਰਸਾਉਂਦੀ ਹੈ, \nਵਾਕ ਵਿੱਚ ਕੁਝ ਸ਼ਬਦ ਹੁੰਦੇ ਹਨ ਜੋ ਇੱਕ ਸਪੇਸ ਦੁਆਰਾ ਵੱਖ ਕੀਤੇ ਜਾਂਦੇ ਹਨ, \nਅਤੇ ਤੁਹਾਨੂੰ ਇੱਕ ਸਤਰ ਵਾਪਸ ਕਰਨੀ ਪਵੇਗੀ ਜਿਸ ਵਿੱਚ ਮੂਲ ਵਾਕ ਦੇ ਸ਼ਬਦ ਸ਼ਾਮਲ ਹਨ, \nਜਿਸ ਦੀ ਲੰਬਾਈ ਮੁੱਖ ਸੰਖਿਆਵਾਂ ਹਨ, \nਨਵੀਂ ਸਤਰ ਵਿੱਚ ਸ਼ਬਦਾਂ ਦਾ ਕ੍ਰਮ ਮੂਲ ਦੇ ਸਮਾਨ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ। \n\nਉਦਾਹਰਨ 1: \nਇਨਪੁਟਃ ਵਾਕ = \"ਇਹ ਇੱਕ ਟੈਸਟ ਹੈ\" \nਆਉਟਪੁੱਟਃ \"is\" \n\nਉਦਾਹਰਨ 2: \nਇਨਪੁਟਃ ਵਾਕ = \"ਚਲੋ ਤੈਰਾਕੀ ਲਈ ਚੱਲੀਏ\" \nਆਉਟਪੁੱਟਃ \"ਲਈ ਜਾਓ\" \n\nਪਾਬੰਦੀਆਂਃ \n* 1 <= ਲੇਨ (ਵਾਕ) <= 100 \n* ਵਾਕ ਵਿੱਚ ਸਿਰਫ਼ ਅੱਖਰ ਹੁੰਦੇ ਹਨ", "natural_language": "Punjabi"}
{"task_id": "python/66", "entry_point": "simplify", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n", "language": "python", "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n", "description": "ਤੁਹਾਡਾ ਕੰਮ ਇੱਕ ਫੰਕਸ਼ਨ ਨੂੰ ਲਾਗੂ ਕਰਨਾ ਹੈ ਜੋ ਸਮੀਕਰਨ ਨੂੰ ਸਰਲ ਬਣਾਵੇਗਾ। \nx * n. ਫੰਕਸ਼ਨ ਸਹੀ ਦਿੰਦਾ ਹੈ ਜੇਕਰ x * n ਇੱਕ ਸੰਪੂਰਨ ਸੰਖਿਆ ਦਾ ਮੁੱਲਾਂਕਣ ਕਰਦਾ ਹੈ ਅਤੇ ਗਲਤ \nਨਹੀਂ ਤਾਂ. x ਅਤੇ n ਦੋਵੇਂ, ਇੱਕ ਅੰਸ਼ ਦੀ ਸਤਰ ਨੁਮਾਇੰਦਗੀ ਹਨ, ਅਤੇ ਹੇਠ ਦਿੱਤਾ ਫਾਰਮੈਟ ਹੈ, \nਜਿੱਥੇ ਅੰਕ ਅਤੇ ਅੰਕ ਦੋਵੇਂ ਸਕਾਰਾਤਮਕ ਸੰਪੂਰਨ ਸੰਖਿਆਵਾਂ ਹੁੰਦੀਆਂ ਹਨ। \n\nਤੁਸੀਂ ਇਹ ਮੰਨ ਸਕਦੇ ਹੋ ਕਿ x, ਅਤੇ n ਜਾਇਜ਼ ਅੰਸ਼ ਹਨ, ਅਤੇ ਅੰਕ ਦੇ ਰੂਪ ਵਿੱਚ ਜ਼ੀਰੋ ਨਹੀਂ ਹਨ। \n\nਸਰਲ ਬਣਾਓ (\"1/5\", \"5/1\") = ਸੱਚ \nਸਰਲ ਬਣਾਓ (\"1/6\", \"2/1\") = ਗਲਤ \nਸਰਲ ਬਣਾਓ (\"7/10\", \"10/2\") = ਗਲਤ", "natural_language": "Punjabi"}
{"task_id": "python/67", "entry_point": "order_by_points", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n", "description": "ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਪੂਰਨ ਅੰਕਾਂ ਦੀ ਦਿੱਤੀ ਸੂਚੀ ਨੂੰ ਕ੍ਰਮਬੱਧ ਕਰਦਾ ਹੈ \nਉਹਨਾਂ ਦੇ ਅੰਕਾਂ ਦੇ ਜੋਡ਼ ਅਨੁਸਾਰ ਚਡ਼੍ਹਦੇ ਕ੍ਰਮ ਵਿੱਚ। \nਨੋਟਃ ਜੇ ਇੱਥੇ ਕਈ ਆਈਟਮਾਂ ਹਨ ਜੋ ਉਹਨਾਂ ਦੇ ਅੰਕਾਂ ਦੇ ਇੱਕੋ ਜਿਹੇ ਜੋਡ਼ ਨਾਲ ਹਨ, \nਉਹਨਾਂ ਨੂੰ ਮੂਲ ਸੂਚੀ ਵਿੱਚ ਉਹਨਾਂ ਦੇ ਸੂਚਕਾਂਕ ਦੇ ਅਧਾਰ ਤੇ ਆਰਡਰ ਕਰੋ। \n\nਉਦਾਹਰਨ ਲਈਃ \n>>> ਆਰਡਰ _ ਬਾਈ _ ਪੁਆਇੰਟ ([1,11,-1,11,-12]) = = [-1,11,1,-12,11] \n>>> ਆਰਡਰ _ ਬਾਈ _ ਪੁਆਇੰਟਸ ([]) = = []", "natural_language": "Punjabi"}
{"task_id": "python/68", "entry_point": "specialFilter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n", "language": "python", "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n", "description": "ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਸੰਖਿਆਵਾਂ ਦੀ ਇੱਕ ਲਡ਼ੀ ਨੂੰ ਇੰਪੁੱਟ ਅਤੇ ਰਿਟਰਨ ਵਜੋਂ ਲੈਂਦਾ ਹੈ \nਐਰੇ ਵਿੱਚ ਤੱਤਾਂ ਦੀ ਗਿਣਤੀ ਜੋ 10 ਤੋਂ ਵੱਧ ਹੈ ਅਤੇ ਦੋਵੇਂ \nਕਿਸੇ ਸੰਖਿਆ ਦੇ ਪਹਿਲੇ ਅਤੇ ਆਖਰੀ ਅੰਕ ਅਜੀਬ (1,3,5,7,9) ਹੁੰਦੇ ਹਨ। \nਉਦਾਹਰਨ ਲਈਃ \nਸਪੈਸ਼ਲਫਿਲਟਰ ([15,-73,14,-15]) => 1 \nਵਿਸ਼ੇਸ਼ ਫਿਲਟਰ ([33,-2,-3,45,21,109]) => 2", "natural_language": "Punjabi"}
{"task_id": "python/69", "entry_point": "get_max_triples", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n", "language": "python", "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n", "description": "ਤੁਹਾਨੂੰ ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਜਾਂਦਾ ਹੈ। ਤੁਹਾਨੂੰ n ਦੀ ਲੰਬਾਈ ਦਾ ਇੱਕ ਪੂਰਨ ਅੰਕ ਐਰੇ ਬਣਾਉਣਾ ਪਵੇਗਾ। \nਹਰੇਕ i (1 ≤ i ≤ n) ਲਈ, a [i] = i * i-i + 1 ਦਾ ਮੁੱਲ ਹੈ। \na ਦੇ ਤਿੰਨਾਂ ਦੀ ਗਿਣਤੀ (a [i], a [j], a [k]) ਵਾਪਸ ਕਰੋ ਜਿੱਥੇ i <j <k, \nਅਤੇ a [i] + a [j] + a [k] 3 ਦਾ ਮਲਟੀਪਲ ਹੁੰਦਾ ਹੈ। \n\nਉਦਾਹਰਨਃ \nਇੰਪੁੱਟਃ n = 5 \nਆਉਟਪੁੱਟਃ 1 \nਵਿਆਖਿਆਃ \na = [1,3,7,13,21] \nਇੱਕੋ ਇੱਕ ਵੈਧ ਟ੍ਰਿਪਲ (1,7,13) ਹੈ।", "natural_language": "Punjabi"}
{"task_id": "python/70", "entry_point": "bf", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n", "language": "python", "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n", "description": "ਸਾਡੇ ਸੂਰਜੀ ਮੰਡਲ ਵਿੱਚ ਅੱਠ ਗ੍ਰਹਿ ਹਨਃ ਸੂਰਜ ਦੇ ਸਭ ਤੋਂ ਨੇਡ਼ੇ \nਬੁਧ ਹੈ, ਅਗਲਾ ਸ਼ੁੱਕਰ ਹੈ, ਫਿਰ ਧਰਤੀ, ਮੰਗਲ, ਜੁਪੀਟਰ, ਸ਼ਨੀਵਾਰ, \nਯੂਰੇਨਸ, ਨੇਪਚਿਊਨ। \nਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਦੋ ਗ੍ਰਹਿਆਂ ਦੇ ਨਾਮ ਗ੍ਰਹਿ 1 ਅਤੇ ਗ੍ਰਹਿ 2 ਦੇ ਰੂਪ ਵਿੱਚ ਲੈਂਦਾ ਹੈ। \nਫੰਕਸ਼ਨ ਨੂੰ ਇੱਕ ਟੁਪਲ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਜਿਸ ਵਿੱਚ ਸਾਰੇ ਗ੍ਰਹਿ ਹੁੰਦੇ ਹਨ ਜਿਨ੍ਹਾਂ ਦੇ ਚੱਕਰ ਹਨ \nਗ੍ਰਹਿ 1 ਦੇ ਚੱਕਰ ਅਤੇ ਗ੍ਰਹਿ 2 ਦੇ ਚੱਕਰ ਦੇ ਵਿਚਕਾਰ ਸਥਿਤ, ਦੁਆਰਾ ਕ੍ਰਮਬੱਧ \nਸੂਰਜ ਦੀ ਨੇਡ਼ਤਾ. \nਫੰਕਸ਼ਨ ਨੂੰ ਇੱਕ ਖਾਲੀ ਟੁਪਲ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਜੇਕਰ ਗ੍ਰਹਿ 1 ਜਾਂ ਗ੍ਰਹਿ 2 \nਇਹ ਗ੍ਰਹਿਆਂ ਦੇ ਸਹੀ ਨਾਮ ਨਹੀਂ ਹਨ। \nਉਦਾਹਰਣਾਂ \nbf (\"ਜੁਪੀਟਰ\", \"ਨੇਪਚੂਨ\") = => (\"ਸੈਟਰਨ\", \"ਯੂਰੇਨਸ\") \nbf (\"ਧਰਤੀ\", \"ਮਰਕਰੀ\") = => (\"ਵੀਨਸ\") \nbf (\"ਮਰਕਰੀ\", \"ਯੂਰੇਨਸ\") = => (\"ਵੀਨਸ\", \"ਧਰਤੀ\", \"ਮੰਗਲ\", \"ਜੁਪੀਟਰ\", \"ਸੈਟਰਨ\")", "natural_language": "Punjabi"}
{"task_id": "python/71", "entry_point": "x_or_y", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n", "language": "python", "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n", "description": "ਇੱਕ ਸਧਾਰਨ ਪ੍ਰੋਗਰਾਮ ਜਿਸ ਨੂੰ x ਦਾ ਮੁੱਲ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਜੇਕਰ n ਹੈ \nਇੱਕ ਪ੍ਰਾਈਮ ਨੰਬਰ ਅਤੇ y ਦਾ ਮੁੱਲ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ। \n\nਉਦਾਹਰਨਾਂਃ \nx _ ਜਾਂ _ y ਲਈ (7,34,12) = = 34 \nx _ ਜਾਂ _ y ਲਈ (15,8,5) = = 5", "natural_language": "Punjabi"}
{"task_id": "python/72", "entry_point": "double_the_difference", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n", "description": "ਸੰਖਿਆਵਾਂ ਦੀ ਸੂਚੀ ਦਿੱਤੀ ਗਈ ਹੈ, ਤਾਂ ਸੰਖਿਆਵਾਂ ਦੇ ਵਰਗਾਂ ਦਾ ਜੋਡ਼ ਵਾਪਸ ਕਰੋ। \nਸੂਚੀ ਵਿੱਚ ਜੋ ਅਜੀਬ ਹਨ। ਉਹਨਾਂ ਸੰਖਿਆਵਾਂ ਨੂੰ ਨਜ਼ਰਅੰਦਾਜ਼ ਕਰੋ ਜੋ ਨਕਾਰਾਤਮਕ ਹਨ ਜਾਂ ਪੂਰਨ ਅੰਕ ਨਹੀਂ ਹਨ। \n\nਡਬਲ _ ਦ _ ਫਰਕ ([1,3,2,0]) = = 1 + 9 + 0 + 0 = 10 \nਡਬਲ _ ਦ _ ਫਰਕ ([-1,2,0]) = = 0 \nਡਬਲ _ ਦ _ ਫਰਕ ([9,-2]) = = 81 \nਡਬਲ _ ਦ _ ਫਰਕ ([0]) = = 0 \n\nਜੇਕਰ ਇੰਪੁੱਟ ਸੂਚੀ ਖਾਲੀ ਹੈ, ਤਾਂ 0 ਵਾਪਸ ਕਰੋ।", "natural_language": "Punjabi"}
{"task_id": "python/73", "entry_point": "Strongest_Extension", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n\n", "language": "python", "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n", "description": "ਤੁਹਾਨੂੰ ਇੱਕ ਕਲਾਸ (ਇੱਕ ਸਤਰ) ਦਾ ਨਾਮ ਅਤੇ ਐਕਸਟੈਂਸ਼ਨਾਂ ਦੀ ਸੂਚੀ ਦਿੱਤੀ ਜਾਵੇਗੀ। \nਐਕਸਟੈਂਸ਼ਨਾਂ ਦੀ ਵਰਤੋਂ ਕਲਾਸ ਵਿੱਚ ਵਾਧੂ ਕਲਾਸਾਂ ਨੂੰ ਲੋਡ ਕਰਨ ਲਈ ਕੀਤੀ ਜਾਣੀ ਹੈ। \nਐਕਸਟੈਂਸ਼ਨ ਦੀ ਤਾਕਤ ਹੇਠ ਲਿਖੇ ਅਨੁਸਾਰ ਹੈਃ ਮੰਨ ਲਓ ਕਿ CAP ਵੱਡੇ ਅੱਖਰ ਦੀ ਸੰਖਿਆ ਹੈ। \nਐਕਸਟੈਂਸ਼ਨ ਦੇ ਨਾਮ ਵਿੱਚ ਅੱਖਰ, ਅਤੇ ਮੰਨ ਲਓ ਕਿ ਐੱਸ. ਐੱਮ. ਛੋਟੇ ਅੱਖਰਾਂ ਦੀ ਗਿਣਤੀ ਹੈ। \nਐਕਸਟੈਂਸ਼ਨ ਦੇ ਨਾਮ ਵਿੱਚ, ਤਾਕਤ CAP-SM ਦੇ ਅੰਸ਼ ਦੁਆਰਾ ਦਿੱਤੀ ਜਾਂਦੀ ਹੈ। \nਤੁਹਾਨੂੰ ਸਭ ਤੋਂ ਮਜ਼ਬੂਤ ਐਕਸਟੈਂਸ਼ਨ ਲੱਭਣੀ ਚਾਹੀਦੀ ਹੈ ਅਤੇ ਇਸ ਵਿੱਚ ਇੱਕ ਸਤਰ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ। \nਫਾਰਮੈਟਃ ClassName.StrongestExtensionName। \nਜੇ ਇੱਕੋ ਤਾਕਤ ਦੇ ਨਾਲ ਦੋ ਜਾਂ ਦੋ ਤੋਂ ਵੱਧ ਐਕਸਟੈਂਸ਼ਨ ਹਨ, ਤਾਂ ਤੁਹਾਨੂੰ ਚਾਹੀਦਾ ਹੈ \nਸੂਚੀ ਵਿੱਚ ਸਭ ਤੋਂ ਪਹਿਲਾਂ ਆਉਣ ਵਾਲੇ ਨੂੰ ਚੁਣੋ। \nਉਦਾਹਰਨ ਲਈ, ਜੇ ਤੁਹਾਨੂੰ ਕਲਾਸ ਅਤੇ ਸੂਚੀ ਦੇ ਰੂਪ ਵਿੱਚ \"ਸਲਾਈਸ\" ਦਿੱਤਾ ਗਿਆ ਹੈ \nਐਕਸਟੈਂਸ਼ਨਃ ['SERVINGSliCes','ਚੀਜ਼','ਸਟੂਫੈਡ'] ਤਾਂ ਤੁਹਾਨੂੰ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ \n'Slices.SErviNGSliCes'ਵਾਪਸ ਕਰੋ ਕਿਉਂਕਿ'SERVINGSliCes'ਸਭ ਤੋਂ ਮਜ਼ਬੂਤ ਐਕਸਟੈਂਸ਼ਨ ਹੈ \n(ਇਸ ਦੀ ਤਾਕਤ-1 ਹੈ)। \nਉਦਾਹਰਨਃ \nਸਭ ਤੋਂ ਮਜ਼ਬੂਤ _ ਐਕਸਟੈਂਸ਼ਨ ਲਈ ('ਮੇਰੀ _ ਕਲਾਸ', ['AA','Be','CC']) = ='my_class.AA'", "natural_language": "Punjabi"}
{"task_id": "python/74", "entry_point": "cycpattern_check", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n", "language": "python", "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n", "description": "ਤੁਹਾਨੂੰ 2 ਸ਼ਬਦ ਦਿੱਤੇ ਗਏ ਹਨ। ਤੁਹਾਨੂੰ ਸਹੀ ਵਾਪਸ ਕਰਨ ਦੀ ਜ਼ਰੂਰਤ ਹੈ ਜੇਕਰ ਦੂਜਾ ਸ਼ਬਦ ਜਾਂ ਇਸ ਦੀਆਂ ਰੋਟੇਸ਼ਨਾਂ ਵਿੱਚੋਂ ਕੋਈ ਵੀ ਪਹਿਲੇ ਸ਼ਬਦ ਵਿੱਚ ਇੱਕ ਸਬਸਟਰਿੰਗ ਹੈ। \nਸਾਈਕਪੈਟਰਨ _ ਚੈੱਕ (\"ਏ. ਬੀ. ਸੀ. ਡੀ\"., \"ਏ. ਬੀ. ਡੀ\".) => ਗਲਤ \nਸਾਈਕਪੈਟਰਨ _ ਚੈੱਕ (\"ਹੈਲੋ\", \"ਈਲ\") => ਸੱਚ \nਸਾਈਕਪੈਟਰਨ _ ਚੈੱਕ (\"ਵ੍ਹਾਸਅਪ\", \"ਪੀਸਸ\") => ਗਲਤ \nਸਾਈਕਪੈਟਰਨ _ ਚੈੱਕ (\"ਅਬਾਬ\", \"ਬਾ\") => ਸੱਚ \nਸਾਈਕਪੈਟਰਨ _ ਚੈੱਕ (\"ਈ. ਐੱਫ. ਈ. ਐੱਫ\"., \"ਈ. ਈ. ਐੱਫ. ਐੱਫ\".) => ਗਲਤ \nਸਾਈਕਪੈਟਰਨ _ ਚੈੱਕ (\"ਹਿਮੇਨਸ\", \"ਸਿਮੇਨ\") => ਸੱਚ", "natural_language": "Punjabi"}
{"task_id": "python/75", "entry_point": "int_to_mini_roman", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n", "description": "ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਦਿੱਤੇ ਜਾਣ ਉੱਤੇ, ਇੱਕ ਸਤਰ ਦੇ ਰੂਪ ਵਿੱਚ ਇਸਦੇ ਰੋਮਨ ਅੰਕ ਦੇ ਬਰਾਬਰ ਪ੍ਰਾਪਤ ਕਰੋ, \nਅਤੇ ਇਸ ਨੂੰ ਛੋਟੇ ਅੱਖਰਾਂ ਵਿੱਚ ਵਾਪਸ ਕਰ ਦਿਓ। \nਪਾਬੰਦੀਆਂਃ 1 <= num <= 1000 \n\nਉਦਾਹਰਨਾਂਃ \n>> ਇੰਟ _ ਤੋਂ _ ਮਿਨੀ _ ਰੋਮਨ (19) = ='xix'\n>> ਇੰਟ _ ਟੂ _ ਮਿਨੀ _ ਰੋਮਨ (152) = ='ਕਲਿ'\n>> ਇੰਟ _ ਤੋਂ _ ਮਿਨੀ _ ਰੋਮਨ (426) = ='cdxxvi'", "natural_language": "Punjabi"}
{"task_id": "python/76", "entry_point": "right_angle_triangle", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n", "language": "python", "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n", "description": "ਇੱਕ ਤਿਕੋਣ ਦੇ ਤਿੰਨ ਪਾਸਿਆਂ ਦੀ ਲੰਬਾਈ ਦਿੱਤੀ ਗਈ ਹੈ। ਸਹੀ ਵਾਪਸ ਕਰੋ ਜੇਕਰ ਤਿੰਨੋਂ \nਪਾਸੇ ਇੱਕ ਸੱਜੇ-ਕੋਣ ਵਾਲਾ ਤਿਕੋਣ ਬਣਾਉਂਦੇ ਹਨ, ਨਹੀਂ ਤਾਂ ਗਲਤ। \nਇੱਕ ਸੱਜੇ ਕੋਣ ਵਾਲਾ ਤਿਕੋਣ ਇੱਕ ਤਿਕੋਣ ਹੁੰਦਾ ਹੈ ਜਿਸ ਵਿੱਚ ਇੱਕ ਕੋਣ ਸੱਜੇ ਕੋਣ ਜਾਂ \n90 ਡਿਗਰੀ. \nਉਦਾਹਰਨਃ \nਸੱਜੇ ਕੋਣ ਦਾ ਤਿਕੋਣ (3,4,5) = = ਸੱਚਾ \nਸੱਜੇ ਕੋਣ ਦਾ ਤਿਕੋਣ (1,2,3) = = ਗਲਤ", "natural_language": "Punjabi"}
{"task_id": "python/77", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n", "language": "python", "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n", "description": "ਤੁਹਾਨੂੰ ਇੱਕ ਸਤਰ s ਦਿੱਤੀ ਜਾਂਦੀ ਹੈ। \nਜੇਕਰ s [i] ਇੱਕ ਅੱਖਰ ਹੈ, ਤਾਂ ਇਸ ਦੇ ਮਾਮਲੇ ਨੂੰ ਹੇਠਲੇ ਤੋਂ ਉੱਪਰ ਵੱਲ ਜਾਂ ਉਲਟ ਕਰੋ, \nਨਹੀਂ ਤਾਂ ਇਸ ਨੂੰ ਜਿਵੇਂ ਹੈ ਉਸੇ ਤਰ੍ਹਾਂ ਰੱਖੋ। \nਜੇ ਸਤਰ ਵਿੱਚ ਕੋਈ ਅੱਖਰ ਨਹੀਂ ਹਨ, ਤਾਂ ਸਤਰ ਨੂੰ ਉਲਟਾ ਦਿਓ। \nਫੰਕਸ਼ਨ ਨੂੰ ਨਤੀਜੇ ਵਾਲੀ ਸਤਰ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ। \nਉਦਾਹਰਣਾਂ \nਹੱਲ ਕਰੋ (\"1234\") = \"4321\" \nਹੱਲ ਕਰੋ (\"ab\") = \"AB\" \nਹੱਲ ਕਰੋ (\"#a @C\") = \"#A @c\"", "natural_language": "Punjabi"}
{"task_id": "python/78", "entry_point": "string_to_md5", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n", "description": "ਇੱਕ ਸਤਰ'ਟੈਕਸਟ'ਦਿੱਤੇ ਜਾਣ ਉੱਤੇ, ਇਸ ਦੀ md5 ਹੈਸ਼ ਦੇ ਬਰਾਬਰ ਸਤਰ ਵਾਪਸ ਕਰੋ। \nਜੇਕਰ'ਟੈਕਸਟ'ਇੱਕ ਖਾਲੀ ਸਤਰ ਹੈ, ਤਾਂ ਨੱਲ ਵਾਪਸ ਕਰੋ। \n\n>> ਸਤਰ _ ਤੋਂ _ md5 ('ਹੈਲੋ ਵਰਲਡ') = ='3e25960a79dbc69b674cd4ec67a72c62'", "natural_language": "Punjabi"}
{"task_id": "python/79", "entry_point": "generate_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n", "description": "ਦੋ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ a ਅਤੇ b ਦਿੱਤੇ ਗਏ ਹਨ, ਤਾਂ a ਦੇ ਵਿਚਕਾਰ ਦੇ ਜੋਡ਼ ਅੰਕ ਵਾਪਸ ਕਰੋ। \nਅਤੇ ਬੀ, ਚਡ਼੍ਹਦੇ ਕ੍ਰਮ ਵਿੱਚ। \n\nਉਦਾਹਰਨ ਲਈਃ \nਜਨਰੇਟ _ ਇੰਟੀਜਰਸ (2,8) => [2,4,6,8] \nਜਨਰੇਟ _ ਇੰਟੀਜਰਸ (8,2) => [2,4,6,8] \nਪੂਰਨ ਅੰਕ ਤਿਆਰ ਕਰੋ (10,14) => []", "natural_language": "Punjabi"}
