{"task_id": "python/0", "entry_point": "below_zero", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n", "language": "python", "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n", "description": "आपको बैंक खाते में जमा और निकासी कार्यों की एक सूची दी जाती है जो किस से शुरू होती है \nशून्य शेष राशि। आपका काम यह पता लगाना है कि क्या किसी भी समय खाते की शेष राशि शून्य से नीचे गिरती है, और \nउस बिंदु पर फ़ंक्शन को सही लौटाना चाहिए। अन्यथा इसे गलत लौटाना चाहिए। \n>>> शून्य से नीचे ([1,2,3]) \nझूठ बोलती है। \n>>> शून्य से नीचे ([1,2,-4,5]) \nसच है।", "natural_language": "Hindi"}
{"task_id": "python/1", "entry_point": "sum_product", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n", "language": "python", "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n", "description": "पूर्णांकों की दी गई सूची के लिए, एक टुपल वापस करें जिसमें एक सूची में सभी पूर्णांकों का योग और एक गुणनफल हो। \nखाली राशि 0 के बराबर होनी चाहिए और खाली उत्पाद 1 के बराबर होना चाहिए। \n>>> sum _ product ([]) \n(0,1) \n>>> sum _ product ([1,2,3,4]) \n(10,24)", "natural_language": "Hindi"}
{"task_id": "python/2", "entry_point": "string_xor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n", "language": "python", "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n", "description": "इनपुट दो स्ट्रिंग a और b हैं जिनमें केवल 1s और 0s होते हैं। \nइन निवेशों पर द्विआधारी XOR करें और एक स्ट्रिंग के रूप में परिणाम भी वापस करें। \n>>> स्ट्रिंग _ xor ('010','110') \n'100'", "natural_language": "Hindi"}
{"task_id": "python/3", "entry_point": "longest", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n", "language": "python", "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "description": "स्ट्रिंग्स की सूची में से सबसे लंबा स्ट्रिंग्स वापस करें। कई स्ट्रिंग्स होने पर पहला स्ट्रिंग्स वापस करें। \nसमान लंबाई के स्ट्रिंग। यदि इनपुट सूची खाली है तो शून्य लौटें। \n>>> सबसे लंबा ([]) \n\n>>> सबसे लंबा (['ए','बी','सी']) \n'ए'\n>>> सबसे लंबा (['ए','बीबी','सीसीसी']) \n'सी. सी. सी.'", "natural_language": "Hindi"}
{"task_id": "python/4", "entry_point": "greatest_common_divisor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n", "language": "python", "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n", "description": "दो पूर्णांकों a और b का सबसे बड़ा सामान्य भाजक वापस करें \n>>> ग्रेटेस्ट _ कॉमन _ डिवाइजर (3,5) \n1. \n>>> ग्रेटेस्ट _ कॉमन _ डिवाइजर (25,15) \n5.", "natural_language": "Hindi"}
{"task_id": "python/5", "entry_point": "sort_numbers", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n", "language": "python", "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n", "description": "इनपुट'शून्य'से'नौ'तक की संख्याओं की एक स्थान-सीमित स्ट्रिंग है। \nवैध विकल्प'शून्य','एक','दो','तीन','चार','पाँच','छह','सात','आठ'और'नौ'हैं। \nस्ट्रिंग को सबसे छोटी से सबसे बड़ी तक क्रमबद्ध संख्याओं के साथ वापस करें \n>>> छँटाई संख्याएँ ('तीन एक पाँच') \n'एक तीन पाँच'", "natural_language": "Hindi"}
{"task_id": "python/6", "entry_point": "rescale_to_unit", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n", "language": "python", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "description": "संख्याओं की सूची (कम से कम दो तत्वों की) को देखते हुए, उस सूची में एक रैखिक परिवर्तन लागू करें, \nकि सबसे छोटी संख्या 0 हो जाएगी और सबसे बड़ी संख्या 1 हो जाएगी। \n>>> इकाई को पुनः प्राप्त करें ([1, 2, 3, 4, 5]) \n[0,0,25,0,0.75,1.0]", "natural_language": "Hindi"}
{"task_id": "python/7", "entry_point": "flip_case", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n", "language": "python", "canonical_solution": "    return string.swapcase()\n", "description": "किसी दिए गए स्ट्रिंग के लिए, छोटे अक्षरों को बड़े अक्षरों में और बड़े अक्षरों को छोटे अक्षरों में बदलें। \n>>> फ़्लिप केस ('हैलो') \n'हैलो'", "natural_language": "Hindi"}
{"task_id": "python/8", "entry_point": "get_positive", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n", "language": "python", "canonical_solution": "    return [e for e in l if e > 0]\n", "description": "सूची में केवल सकारात्मक संख्याएँ वापस करें। \n>>> सकारात्मक प्राप्त करें ([-1,2,-4,5,6]) \n[2,5,6] \n>>> सकारात्मक प्राप्त करें ([5,3,-5,2,-3,3,9,0,123,1,-10]) \n[5,3,2,3,9,123,1]", "natural_language": "Hindi"}
{"task_id": "python/9", "entry_point": "is_prime", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n", "language": "python", "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n", "description": "यदि कोई दी गई संख्या अभाज्य है तो सही वापस करें, और अन्यथा गलत। \n>>> प्राइम है (6) \nझूठ बोलती है। \n>>> इस _ प्राइम (101) है \nसच है। \n>>> प्राइम है (11) \nसच है। \n= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \nसच है। \n>>> इस _ प्राइम (61) \nसच है। \n>>> प्राइम है (4) \nझूठ बोलती है। \n>>> प्राइम है (1) \nझूठ बोलती है।", "natural_language": "Hindi"}
{"task_id": "python/10", "entry_point": "unique", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n", "language": "python", "canonical_solution": "    return sorted(list(set(l)))\n", "description": "एक सूची में क्रमबद्ध अद्वितीय तत्वों को वापस करें \n>>> अद्वितीय ([5,3,5,2,3,3,9,0,123]) \n[0,2,3,5,9,123]", "natural_language": "Hindi"}
{"task_id": "python/11", "entry_point": "prime_fib", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n", "language": "python", "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n", "description": "प्राइम _ फाइब n-th संख्या बताता है जो एक फिबोनाची संख्या है और यह भी अभाज्य है। \n>>> प्राइम _ फाइब (1) \n2. \n>>> प्राइम _ फाइब (2) \n3. \n>>> प्राइम _ फाइब (3) \n5. \n>>> प्राइम _ फाइब (4) \n13. \n>>> प्राइम _ फाइब (5) \n89", "natural_language": "Hindi"}
{"task_id": "python/12", "entry_point": "triples_sum_to_zero", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n", "description": "ट्रिपल्स _ सम _ से _ जीरो एक इनपुट के रूप में पूर्णांकों की एक सूची लेता है। \nयह सही बताता है यदि सूची में तीन अलग-अलग तत्व हैं जो \nशून्य का योग, और अन्यथा गलत। \n\n>>> ट्रिपल _ सम _ से _ शून्य ([1,35,5,0]) \nझूठ बोलती है। \n>>> ट्रिपल _ सम _ से _ शून्य ([1,3,-2,1]) \nसच है। \n>>> ट्रिपल _ सम _ से _ शून्य ([1,2,3,7]) \nझूठ बोलती है। \n>>> ट्रिपल _ सम _ से _ शून्य ([2,4,-5,3,9,7]) \nसच है। \n>>> ट्रिपल _ सम _ से _ शून्य ([1]) \nझूठ बोलती है।", "natural_language": "Hindi"}
{"task_id": "python/13", "entry_point": "pairs_sum_to_zero", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n", "language": "python", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "description": "pair _ sum _ to _ zero पूर्णांकों की एक सूची को एक इनपुट के रूप में लेता है। \nयह सही बताता है यदि सूची में दो अलग-अलग तत्व हैं जो \nशून्य का योग, और अन्यथा गलत। \n>>> जोड़े _ योग _ से _ शून्य ([1,3,5,0]) \nझूठ बोलती है। \n>>> जोड़े _ योग _ से _ शून्य ([1,3,-2,1]) \nझूठ बोलती है। \n>>> जोड़े _ योग _ से _ शून्य ([1,2,3,7]) \nझूठ बोलती है। \n>>> जोड़े _ योग _ से _ शून्य ([2,4,-5,3,5,7]) \nसच है। \n>>> जोड़े _ योग _ से _ शून्य ([1]) \nझूठ बोलती है।", "natural_language": "Hindi"}
{"task_id": "python/14", "entry_point": "fib4", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n", "language": "python", "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n", "description": "फाइब4 संख्या अनुक्रम फाइबोनैचि सेकुनेस के समान एक अनुक्रम है जिसे निम्नानुसार परिभाषित किया गया हैः \nfib4 (0)-> 0 \nफाइब 4 (1)-> 0 \nफाइब 4 (2)-> 2 \nफाइब 4 (3)-> 0 \nफाइब 4 (एन)-> फाइब 4 (एन-1) + फाइब 4 (एन-2) + फाइब 4 (एन-3) + फाइब 4 (एन-4)। \nकृपया तन्तु 4 संख्या अनुक्रम के n-th तत्व की कुशलता से गणना करने के लिए एक कार्य लिखें। पुनरावृत्ति का उपयोग न करें। \n>>> फाइब4 (5) \n4. \n>>> fib4 (6) \n8. \n>>> fib4 (7) \n14.", "natural_language": "Hindi"}
{"task_id": "python/15", "entry_point": "median", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n", "language": "python", "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n", "description": "सूची एल में तत्वों का माध्यिका वापस करें। \n>>> माध्यिका ([3,1,2,4,5]) \n3. \n>>> माध्यिका ([-10,4,6,1000,10,20]) \n15. 0", "natural_language": "Hindi"}
{"task_id": "python/16", "entry_point": "is_palindrome", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n", "description": "जाँच करता है कि क्या दी गई स्ट्रिंग एक पालिंड्रोम है \n>>> इस _ पालिंड्रोम (\") है \nसच है। \n>>> इस _ पालिंड्रोम ('अबा') है \nसच है। \n>>> इस _ पालिंड्रोम ('एएएएए') है \nसच है। \n>>> is _ palindrom ('zbcd') है \nझूठ बोलती है।", "natural_language": "Hindi"}
{"task_id": "python/17", "entry_point": "remove_vowels", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n", "language": "python", "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n", "description": "रिमूव _ वॉवेल्स एक ऐसा फंक्शन है जो स्ट्रिंग लेता है और बिना स्वर के स्ट्रिंग लौटाता है। \n>>> स्वर हटाएँ (\") \n\"\n>>> स्वरों को हटाएँ (\"abcdef\\nghijklm\") \n'बी. सी. डी. एफ. \\एनजी. जे. के. एल. एम.'\n>>> स्वरों को हटाएँ ('abcdef') \n'बी. सी. डी. एफ.'\n>>> स्वरों को हटाएँ ('एएएए') \n\"\n>>> स्वरों को हटाएँ ('एएबीएए') \n'बी'\n>>> स्वर हटाएँ ('zbcd') \n'जेड. बी. सी. डी.'", "natural_language": "Hindi"}
{"task_id": "python/18", "entry_point": "below_threshold", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n", "language": "python", "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n", "description": "सही लौटें यदि सूची में सभी संख्याएँ t की सीमा से नीचे हैं। \n>>> थ्रेसहोल्ड के नीचे ([1,2,4,10], 100) \nसच है। \n>>> थ्रेसहोल्ड के नीचे ([1,20,4,10], 5) \nझूठ बोलती है।", "natural_language": "Hindi"}
{"task_id": "python/19", "entry_point": "add", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n", "language": "python", "canonical_solution": "    return x + y\n", "description": "दो संख्याएँ x और y जोड़ें \n>>> जोड़ें (2,3) \n5. \n>>> जोड़ें (5,7) \n12.", "natural_language": "Hindi"}
{"task_id": "python/20", "entry_point": "same_chars", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n", "language": "python", "canonical_solution": "    return set(s0) == set(s1)\n", "description": "जाँच करें कि क्या दो शब्दों में समान अक्षर हैं। \n>>> समान अक्षर ('eabcdzzzz','dddzzzzzuddeddabc') \nसच है। \n>>> समान अक्षर ('एबीसीडी','डीडीडीडीडीएबीसी') \nसच है। \n>>> समान अक्षर ('ddddddabc','abcd') \nसच है। \n>>> समान अक्षर ('ई. ए. बी. सी. डी.','डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. \nझूठ बोलती है। \n>>> समान अक्षर ('ए. बी. सी. डी.','डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. डी. \nझूठ बोलती है। \n>>> समान अक्षर ('eabcdzzzz','dddzzzzzddddddabc') \nझूठ बोलती है।", "natural_language": "Hindi"}
{"task_id": "python/21", "entry_point": "fib", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "description": "n-th फिबोनाची संख्या वापस करें। \n>>> फाइबर (10) \n55. \n>>> फाइबर (1) \n1. \n>>> फाइबर (8) \n21.", "natural_language": "Hindi"}
{"task_id": "python/22", "entry_point": "common", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n", "language": "python", "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "description": "दो सूचियों के लिए विशिष्ट सामान्य तत्वों को वापस क्रमबद्ध करें। \n>>> सामान्य ([1,4,3,34,653,2,5], [5,7,1,5,9,653,121]) \n[1,5,653] \n>>> सामान्य ([5,3,2,8], [3,2]) \n[2,3]", "natural_language": "Hindi"}
{"task_id": "python/23", "entry_point": "largest_prime_factor", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n", "language": "python", "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n", "description": "n का सबसे बड़ा अभाज्य गुणनखंड वापस करें। मान लीजिए कि n> 1 अभाज्य नहीं है। \n>>> सबसे बड़ा _ प्राइम _ फैक्टर (13195) \n29. \n>>> सबसे बड़ा _ प्राइम _ फैक्टर (2048) \n2.", "natural_language": "Hindi"}
{"task_id": "python/24", "entry_point": "sum_to_n", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n", "language": "python", "canonical_solution": "    return sum(range(n + 1))\n", "description": "sum _ to _ n एक फलन है जो 1 से n तक की संख्याओं का योग करता है। \n>>> योग _ से _ एन (30) \n465 \n>>> योग _ से _ एन (100) \n5050 \n>>> योग _ से _ एन (5) \n15. \n>>> योग _ से _ एन (10) \n55. \n>>> योग _ से _ एन (1) \n1.", "natural_language": "Hindi"}
{"task_id": "python/25", "entry_point": "derivative", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n", "language": "python", "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n", "description": "xs एक बहुपद के गुणांक का प्रतिनिधित्व करता है। \nxs [0] + xs [1] * x + xs [2] * x2 +.... \nइस बहुपद का उसी रूप में व्युत्पन्न वापस करें। \n>>> व्युत्पन्न ([3,1,2,4,5]) \n[1,4,12,20] \n>>> व्युत्पन्न ([1,2,3]) \n[2,6]", "natural_language": "Hindi"}
{"task_id": "python/26", "entry_point": "fibfib", "test": "\n\nMETADATA = {}\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n", "description": "फाइबफाइब संख्या अनुक्रम फाइबोनैचि सेकुनेस के समान एक अनुक्रम है जिसे निम्नानुसार परिभाषित किया गया हैः \nफाइबफिब (0) = = 0 \nफाइबफिब (1) = = 0 \nफाइबफिब (2) = = 1 \nफाइबफिब (एन) = = फाइबफिब (एन-1) + फाइबफिब (एन-2) + फाइबफिब (एन-3)। \nकृपया फाइबफिब संख्या अनुक्रम के n-th तत्व की कुशलता से गणना करने के लिए एक कार्य लिखें। \n>>> फाइबफिब (1) \n0 \n>>> फाइबफिब (5) \n4. \n>>> फाइबफिब (8) \n24.", "natural_language": "Hindi"}
{"task_id": "python/27", "entry_point": "vowels_count", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n", "description": "एक फलन स्वर गणना लिखें जो एक स्ट्रिंग का प्रतिनिधित्व करता है \nइनपुट के रूप में एक शब्द और स्ट्रिंग में स्वरों की संख्या लौटाता है। \nइस मामले में स्वर'ए','ई','आई','ओ','यू'हैं। यहाँ,'वाई'भी एक है। \nस्वर, लेकिन केवल तभी जब यह दिए गए शब्द के अंत में हो। \n\nउदाहरणः \n>>> स्वरों की गिनती (\"एबीसीडीई\") \n2. \n>>> स्वर गणना (\"ACEDY\") \n3.", "natural_language": "Hindi"}
{"task_id": "python/28", "entry_point": "search", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n", "language": "python", "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n", "description": "आपको सकारात्मक पूर्णांकों की एक गैर-खाली सूची दी जाती है। सबसे बड़ा पूर्णांक वापस करें जो उससे बड़ा है \nशून्य, और इसकी आवृत्ति पूर्णांक के मूल्य से अधिक या उसके बराबर होती है। \nएक पूर्णांक की आवृत्ति वह संख्या है जो वह सूची में कितनी बार दिखाई देती है। \nयदि ऐसा कोई मान मौजूद नहीं है, तो-1 वापस करें। \nउदाहरण के लिएः \nखोज ([4,1,2,2,3,1]) = = 2 \nखोज ([1,2,3,3,4,4]) = = 3 \nखोज ([5,5,4,4]) = =-1", "natural_language": "Hindi"}
{"task_id": "python/29", "entry_point": "triangle_area", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n", "language": "python", "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n", "description": "त्रिभुज की तीनों भुजाओं की लंबाई को देखते हुए। \nत्रिभुज को 2 दशमलव बिंदुओं पर गोल किया जाता है यदि तीनों भुजाएं एक वैध त्रिभुज बनाती हैं। \nअन्यथा वापसी-1 \nतीन भुजाएँ एक वैध त्रिभुज बनाती हैं जब किसी भी दो भुजाओं का योग अधिक होता है। \nतीसरे पक्ष की तुलना में। \nउदाहरणः \nत्रिभुज क्षेत्रफल (3,4,5) = = 6.00 \nत्रिभुज क्षेत्र (1,2,10) = =-1", "natural_language": "Hindi"}
{"task_id": "python/30", "entry_point": "will_it_fly", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n", "language": "python", "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n", "description": "एक फलन लिखें जो सही बताता है यदि वस्तु q उड़ान भरेगी, और अन्यथा गलत। \nवस्तु q उड़ जाएगी यदि यह संतुलित है (यह एक पैलिन्ड्रोमिक सूची है) और इसके तत्वों का योग अधिकतम संभव वजन डब्ल्यू से कम या उसके बराबर है। \n\nउदाहरणः \nविल इट फ्लाई ([1,2], 5) ′ फाल्स \n#1 + 2 अधिकतम संभव वजन से कम है, लेकिन यह असंतुलित है। \n\nविल इट फ्लाई ([3,2,3], 1) ′ फाल्स \n#यह संतुलित है, लेकिन 3 + 2 + 3 अधिकतम संभव वजन से अधिक है। \n\nविल इट फ्लाई ([3,2,3], 9) सही है \n#3 + 2 + 3 अधिकतम संभव वजन से कम है, और यह संतुलित है। \n\nविल इट फ्लाई ([3], 5) ट्रू \n#3 अधिकतम संभव वजन से कम है, और यह संतुलित है।", "natural_language": "Hindi"}
{"task_id": "python/31", "entry_point": "is_multiply_prime", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n", "language": "python", "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n", "description": "एक फलन लिखें जो सही लौटता है यदि दी गई संख्या 3 अभाज्य संख्याओं का गुणन है। \nऔर अन्यथा गलत। \nयह जानते हुए कि (ए) 100 से कम है। \nउदाहरणः \nक्या _ गुणा _ अभाज्य (30) = = सही है \n30 = 2 * 3 * 5", "natural_language": "Hindi"}
{"task_id": "python/32", "entry_point": "decimal_to_binary", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n", "description": "आपको दशमलव के रूप में एक संख्या दी जाएगी और आपका काम इसे में बदलना है \nद्विआधारी प्रारूप। फलन को एक स्ट्रिंग वापस करनी चाहिए, जिसमें प्रत्येक वर्ण द्विआधारी का प्रतिनिधित्व करता है। \nसंख्या. स्ट्रिंग में प्रत्येक वर्ण'0'या'1'होगा। \n\nस्ट्रिंग के शुरू में और अंत में कुछ अतिरिक्त वर्ण'db'होंगे। \nप्रारूप में मदद करने के लिए अतिरिक्त वर्ण हैं। \n\nउदाहरण के लिएः \nदशमलव से द्विआधारी (15) #\"db1111db\" बताता है \nदशमलव _ से _ द्विआधारी (32) #बताता है \"db100000db\"", "natural_language": "Hindi"}
{"task_id": "python/33", "entry_point": "is_happy", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n", "language": "python", "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n", "description": "आपको एक स्ट्रिंग s दी जाती है। \nआपका काम यह जांचना है कि स्ट्रिंग खुश है या नहीं। \nएक स्ट्रिंग तब खुश होती है जब इसकी लंबाई कम से कम 3 हो और हर 3 लगातार अक्षर अलग-अलग हों। \nउदाहरण के लिएः \nखुश है (a) => गलत है \nखुश है (एए) => गलत है \nखुश है (ए. बी. सी. डी.) => सही है \nखुश है (आब्ब) => गलत है \nखुश है (ए. डी. बी.) => सच है \nखुश है (xyy) => गलत है", "natural_language": "Hindi"}
{"task_id": "python/34", "entry_point": "numerical_letter_grade", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "description": "यह सेमेस्टर का अंतिम सप्ताह होता है और शिक्षक को अंक देने होते हैं। \nछात्रों के लिए। शिक्षक ग्रेडिंग के लिए अपना खुद का एल्गोरिदम बना रहे हैं। \nएकमात्र समस्या यह है कि उसने ग्रेडिंग के लिए उपयोग किया गया कोड खो दिया है। \nउन्होंने आपको कुछ छात्रों के लिए जी. पी. ए. की सूची दी है और आपको लिखना होगा। \nएक प्रकार्य जो निम्नलिखित तालिका का उपयोग करके अक्षर श्रेणी की सूची तैयार कर सकता हैः \nजी. पी. ए। लेटर ग्रेड \n4. 0 ए + \n> 3.7 ए \n> 3.3 ए-\n> 3 बी + \n> 2.7 बी \n> 2.3 बी-\n> 2 सी + \n> 1.7 डिग्री सेल्सियस \n> 1.3 सी-\n> 1 डी + \n> 0.7 डी \n> 0.0 डी-\n0. 0 ई \n\nउदाहरणः \nश्रेणी समीकरण ([4.0,3,17,2,3.5]) = => ['ए +','बी','सी-','सी','ए -']", "natural_language": "Hindi"}
{"task_id": "python/35", "entry_point": "prime_length", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n", "language": "python", "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "description": "एक फ़ंक्शन लिखें जो एक स्ट्रिंग लेता है और सही लौटाता है यदि स्ट्रिंग \nलंबाई एक अभाज्य संख्या है या अन्यथा गलत है \nउदाहरण \nप्राइम लेंथ ('हैलो') = = सही \nप्राइम _ लेंथ ('एबीसीडीसीबीए') = = सही \nअभाज्य लंबाई ('बिल्ली के बच्चे') = = सही \nअभाज्य लंबाई ('नारंगी') = = गलत", "natural_language": "Hindi"}
{"task_id": "python/36", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n", "language": "python", "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n", "description": "एक सकारात्मक पूर्णांक N दिए जाने पर, इसके अंकों का कुल योग द्विआधारी में वापस करें। \n\nउदाहरण \nएन = 1000 के लिए, अंकों का योग 1 होगा और आउटपुट \"1\" होना चाहिए। \nएन = 150 के लिए, अंकों का योग 6 होगा और आउटपुट \"110\" होना चाहिए। \nएन = 147 के लिए, अंकों का योग 12 होगा और आउटपुट \"1100\" होना चाहिए। \n\nचरः \n@N पूर्णांक \nबाधाएँः 0 ≤ एन ≤ 10000। \nआउटपुटः \nद्विआधारी संख्या की एक स्ट्रिंग", "natural_language": "Hindi"}
{"task_id": "python/37", "entry_point": "get_row", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "description": "आपको एक 2 आयामी डेटा दिया जाता है, एक नेस्टेड सूची के रूप में, \nजो मैट्रिक्स के समान है, हालांकि, मैट्रिक्स के विपरीत, \nप्रत्येक पंक्ति में अलग-अलग संख्या में स्तंभ हो सकते हैं। \nपहले और पूर्णांक x को देखते हुए, सूची में पूर्णांक x खोजें, \nऔर टुपल्स की वापसी सूची, [(x1, y1), (x2, y2)...] जैसे कि \nप्रत्येक टुपल एक निर्देशांक है-(पंक्ति, कॉलम), जो 0 से शुरू होता है। \nनिर्देशांकों को प्रारंभ में पंक्तियों द्वारा आरोही क्रम में क्रमबद्ध करें। \nइसके अलावा, पंक्ति के निर्देशांक को स्तंभों द्वारा अवरोही क्रम में क्रमबद्ध करें। \n\nउदाहरण के लिएः \nपंक्ति प्राप्त करें (_ r) \n[1,2,3, 4,5,6], \n[1,2,3, 4,1,6], \n[1,2,3, 4,5,1] \n], 1) = = [(0,0), (1,4), (1,0), (2,5), (2,0)] \nपंक्ति प्राप्त करें ([], 1) = = [] \nगेट _ रो ([[], [1], [1,2,3]], 3) = = [(2,2)]", "natural_language": "Hindi"}
{"task_id": "python/38", "entry_point": "next_smallest", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "description": "आपको पूर्णांकों की एक सूची दी जाती है। \nएक फलन अगला _ सबसे छोटा () लिखें जो सूची का दूसरा सबसे छोटा तत्व देता है। \nशून्य लौटें यदि ऐसा कोई तत्व नहीं है। \n\nअगला _ सबसे छोटा ([1,2,3,4,5]) = = 2 \nअगला _ सबसे छोटा ([5,1,4,3,2]) = = 2 \nअगला _ सबसे छोटा ([]) = = कोई नहीं \nअगला _ सबसे छोटा ([1,1]) = = कोई नहीं", "natural_language": "Hindi"}
{"task_id": "python/39", "entry_point": "is_bored", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "description": "आपको शब्दों की एक श्रृंखला दी जाएगी, और आपका काम संख्या को गिनना है। \nऊब का। ऊब एक वाक्य है जो \"मैं\" शब्द से शुरू होता है। \nवाक्यों को '.', '?'या '!'द्वारा सीमांकित किया जाता है। \n\nउदाहरण के लिएः \n>>> बोर हो गया है (\"हैलो वर्ल्ड\") \n0 \n>>> ऊब गया है (\"आकाश नीला है। सूरज चमक रहा है। मुझे यह मौसम पसंद है\") \n1.", "natural_language": "Hindi"}
{"task_id": "python/40", "entry_point": "skjkasdkd", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n", "language": "python", "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "description": "आपको पूर्णांकों की एक सूची दी जाती है। \nआपको सबसे बड़ा अभाज्य मूल्य खोजने और उसके अंकों का योग वापस करने की आवश्यकता है। \n\nउदाहरण के लिएः \nlst = [0,3,2, 1,3,5, 7,4,5, 5,5,2, 181,32,4, 32,3,2, 32,324,4, 3] के लिए आउटपुट 10 होना चाहिए। \nlst = [1,0,1, 8,2,4597, 2,1,3, 40,1,2, 1,2,4, 2,5,1] के लिए आउटपुट 25 होना चाहिए। \nlst = [1,3,1, 32,5107,34, 83278,109,163, 23,2323,32, 30,1,9, 3] के लिए आउटपुट 13 होना चाहिए। \nlst = [0,724,32, 71,99,32, 6,0,5, 91,83,0, 5,6] के लिए आउटपुट 11 होना चाहिए। \nlst = [0,81,12, 3,1,21] के लिए आउटपुट 3 होना चाहिए। \nlst = [0,8,1, 2,1,7] के लिए आउटपुट 7 होना चाहिए।", "natural_language": "Hindi"}
{"task_id": "python/41", "entry_point": "check_dict_case", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n", "language": "python", "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n", "description": "शब्दकोश दिए जाने पर, सही वापस करें यदि सभी कुंजी निचले हिस्से में स्ट्रिंग हैं \nकेस या सभी कुंजी ऊपरी मामले में स्ट्रिंग हैं, अन्यथा गलत लौटें। \nफ़ंक्शन को वापस करना चाहिए गलत है दिया गया शब्दकोश खाली है। \nउदाहरण के लिएः \nचेक _ डिक्ट _ केस ({\"a\": \"सेब\", \"b\": \"केला\"}) को सही लौटना चाहिए। \nचेक _ डिक्ट _ केस ({\"a\": \"सेब\", \"A\": \"केला\", \"B\": \"केला\"}) को गलत लौटाना चाहिए। \nचेक _ डिक्ट _ केस ({\"a\": \"सेब\", 8: \"केला\", \"a\": \"सेब\"}) को गलत लौटाना चाहिए। \nचेक _ डिक्ट _ केस ({\"नाम\": \"जॉन\", \"आयु\": \"36\", \"सिटी\": \"ह्यूस्टन\"}) को गलत लौटाना चाहिए। \nचेक _ डिक्ट _ केस ({\"STATE\": \"NC\", \"ZIP\": \"12345\"}) को सही लौटना चाहिए।", "natural_language": "Hindi"}
{"task_id": "python/42", "entry_point": "closest_integer", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n", "language": "python", "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "description": "एक फ़ंक्शन बनाएँ जो एक संख्या का प्रतिनिधित्व करने वाला मान (स्ट्रिंग) लेता है \nऔर निकटतम पूर्णांक देता है। यदि संख्या समान दूरी पर है। \nदो पूर्णांकों से, इसे शून्य से दूर गोल करें। \n\nउदाहरण \n>>> निकटतम पूर्णांक (\"10\") \n10. \n>>> निकटतम पूर्णांक (\"15.3\") \n15. \n\nध्यान देंः \nशून्य से दूर गोल करने का अर्थ है कि यदि दी गई संख्या समान दूरी पर है \nदो पूर्णांकों से, जिसे आपको वापस करना चाहिए वह वह है जो \nशून्य से सबसे दूर। उदाहरण के लिए निकटतम पूर्णांक (\"14.5\") चाहिए \n15 वापस करें और निकटतम पूर्णांक (\"-14.5\") को-15 वापस करना चाहिए।", "natural_language": "Hindi"}
{"task_id": "python/43", "entry_point": "make_a_pile", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return [n + 2*i for i in range(n)]\n", "description": "एक सकारात्मक पूर्णांक n को देखते हुए, आपको पत्थरों के n स्तरों का ढेर बनाना होगा। \nपहले स्तर में एन पत्थर हैं। \nअगले स्तर पर पत्थरों की संख्या हैः \n- अगली विषम संख्या यदि n विषम है। \n- अगली सम संख्या यदि n सम है। \nसूची में प्रत्येक स्तर पर पत्थरों की संख्या वापस करें, जहां सूचकांक पर तत्व है \ni स्तर (i + 1) में पत्थरों की संख्या का प्रतिनिधित्व करता है। \n\nउदाहरण के लिएः \n>>> _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[3,5,7]", "natural_language": "Hindi"}
{"task_id": "python/44", "entry_point": "words_string", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n", "language": "python", "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n", "description": "आपको अल्पविराम या रिक्त स्थान द्वारा अलग किए गए शब्दों की एक श्रृंखला दी जाएगी। आपका कार्य है \nस्ट्रिंग को शब्दों में विभाजित करने और शब्दों की एक सरणी वापस करने के लिए। \n\nउदाहरण के लिएः \nशब्द _ स्ट्रिंग (\"हाय, मेरा नाम जॉन है\") = = [\"हाय\", \"मेरा\", \"नाम\", \"है\", \"जॉन\"] \nशब्द _ स्ट्रिंग (\"एक, दो, तीन, चार, पांच, छह\") = = [\"एक\", \"दो\", \"तीन\", \"चार\", \"पांच\", \"छह\"]", "natural_language": "Hindi"}
{"task_id": "python/45", "entry_point": "choose_num", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n", "language": "python", "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n", "description": "यह फलन दो धनात्मक संख्याएँ x और y लेता है और वापस करता है \nसबसे बड़ी सम पूर्णांक संख्या जो [x, y] समावेशी सीमा में है। यदि \nऐसी कोई संख्या नहीं है, तो फ़ंक्शन-1 लौटना चाहिए। \n\nउदाहरण के लिएः \nचुनें (12,15) = 14 \nचुनें (13,12) =-1", "natural_language": "Hindi"}
{"task_id": "python/46", "entry_point": "rounded_avg", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n", "language": "python", "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "description": "आपको दो सकारात्मक पूर्णांक n और m दिए गए हैं, और आपका कार्य गणना करना है \nn से m तक के पूर्णांकों का औसत (n और m सहित)। \nनिकटतम पूर्णांक के उत्तर को गोल करें और उसे द्विआधारी में परिवर्तित करें। \nयदि n, m से बड़ा है, तो-1 वापस करें। \nउदाहरणः \nगोलाकार _ ए. वी. जी. (1,5) => \"0बी11\" \nगोलाकार _ ए. वी. जी. (7,5) =>-1 \nगोलाकार _ ए. वी. जी. (10,20) => \"0बी1111\" \nगोलाकार _ ए. वी. जी. (20,33) => \"0बी11010\"", "natural_language": "Hindi"}
{"task_id": "python/47", "entry_point": "f", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n", "language": "python", "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n", "description": "फलन f को लागू करें जो n को एक पैरामीटर के रूप में लेता है, \nऔर आकार n की एक सूची लौटाता है, जैसे कि सूचकांक i पर तत्व का मान i का भाज्य है यदि i सम है \nया अन्यथा 1 से i तक की संख्याओं का योग। \nमैं 1 से शुरू करता हूँ। \ni का भाज्य 1 से i (1 * 2 *... * i) तक की संख्याओं का गुणन है। \nउदाहरणः \nf (5) = = [1,2,6,24,15]", "natural_language": "Hindi"}
{"task_id": "python/48", "entry_point": "even_odd_palindrome", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n", "description": "एक सकारात्मक पूर्णांक n दिए जाने पर, एक टुपल वापस करें जिसमें सम और विषम की संख्या हो। \nपूर्णांक पालिंड्रोम जो सीमा (1, एन) के भीतर आते हैं, समावेशी। \n\nउदाहरण 1: \n\nइनपुटः 3 \nआउटपुटः (1,2) \nव्याख्याः \nपूर्णांक पालिंड्रोम 1,2,3 हैं. उनमें से एक सम है, और उनमें से दो विषम हैं। \n\nउदाहरण 2: \n\nइनपुटः 12 \nआउटपुटः (4,6) \nव्याख्याः \nपूर्णांक पालिंड्रोम हैं 1,2,3,4,5,6,7,8,9,11. उनमें से चार सम हैं, और उनमें से 6 विषम हैं। \n\nध्यान देंः \n1. 1 <= n <= 10 ^ 3 \n2. लौटाए गए टुपल में क्रमशः सम और विषम पूर्णांक पालिंड्रोम्स की संख्या होती है।", "natural_language": "Hindi"}
{"task_id": "python/49", "entry_point": "move_one_ball", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n", "language": "python", "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n", "description": "हमारे पास एन पूर्णांक arr [1], arr [2],..., arr [N] की एक सरणी'arr'है। \nसरणी में संख्याओं को यादृच्छिक रूप से क्रमबद्ध किया जाएगा। आपका कार्य यह निर्धारित करना है कि क्या \nप्रदर्शन करके गैर-घटते क्रम में एक सरणी को क्रमबद्ध करना संभव है। \nदिए गए सरणी पर निम्नलिखित ऑपरेशनः \nआपको किसी भी समय सही शिफ्ट ऑपरेशन करने की अनुमति है। \n\nएक राइट शिफ्ट ऑपरेशन का अर्थ है सरणी के सभी तत्वों को एक से स्थानांतरित करना। \nसही दिशा में स्थिति। सरणी के अंतिम तत्व को स्थानांतरित किया जाएगा \nसरणी में प्रारंभिक स्थिति अर्थात 0 वां सूचकांक। \n\nयदि उपरोक्त ऑपरेशन करके क्रमबद्ध सरणी प्राप्त करना संभव है \nफिर सही लौटें अन्यथा गलत लौटें। \nयदि दी गई सरणी खाली है तो सही वापस करें। \n\nनोटः दी गई सूची में अद्वितीय तत्व होने की गारंटी है। \n\nउदाहरण के लिएः \n\nमूव _ वन _ बॉल ([3,4,5,1,2]) = => सही \nव्याख्याः 2 सही शिफ्ट संचालन में प्रदर्शन करके, गैर-घटता क्रम कर सकता है \nदिए गए सरणी के लिए प्राप्त किया जा सकता है। \nमूव _ वन _ बॉल ([3,5,4,1,2]) = => गलत \nव्याख्याः दिए गए के लिए गैर-घटता आदेश प्राप्त करना संभव नहीं है। \nकिसी भी संख्या में सही शिफ्ट संचालन करके सरणी।", "natural_language": "Hindi"}
{"task_id": "python/50", "entry_point": "exchange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n", "language": "python", "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n", "description": "इस समस्या में, आप एक फ़ंक्शन लागू करेंगे जो संख्याओं की दो सूचियाँ लेता है, \nऔर यह निर्धारित करता है कि क्या तत्वों का आदान-प्रदान करना संभव है \nउनके बीच lst1 को केवल सम संख्याओं की सूची बनाने के लिए। \nlst1 और lst2 के बीच आदान-प्रदान किए गए तत्वों की संख्या की कोई सीमा नहीं है। \nयदि बनाने के लिए lst1 और lst2 के बीच तत्वों का आदान-प्रदान करना संभव है \nlst1 के सभी तत्वों को सम होने के लिए, \"हाँ\" वापस करें। \nअन्यथा, \"नहीं\" वापस करें। \nउदाहरण के लिएः \nविनिमय ([1,2,3,4], [1,2,3,4]) => \"हाँ\" \nविनिमय ([1,2,3,4], [1,5,3,4]) => \"नहीं\" \nयह माना जाता है कि इनपुट सूचियाँ खाली नहीं होंगी।", "natural_language": "Hindi"}
{"task_id": "python/51", "entry_point": "reverse_delete", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n", "language": "python", "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n", "description": "कार्य \nहमें दो स्ट्रिंग s और c दिए गए हैं, आपको s में सभी वर्णों को हटाना होगा जो c में किसी भी वर्ण के बराबर हैं। \nफिर जाँच करें कि परिणाम स्ट्रिंग पालिंड्रोम है या नहीं। \nएक तार को पालिंड्रोम कहा जाता है यदि यह आगे के समान पीछे की ओर पढ़ता है। \nआपको चेक के लिए परिणाम स्ट्रिंग और सही/गलत वाला एक टुपल वापस करना चाहिए। \nउदाहरण \nएस = \"एबीसीडी\", सी = \"एई\" के लिए, परिणाम होना चाहिए ('बीसीडी', गलत) \nएस = \"एबीसीडीएफ\" के लिए, सी = \"बी\" परिणाम होना चाहिए ('एसीडीएफ', गलत) \ns = \"abcdedcba\", c = \"ab\" के लिए, परिणाम होना चाहिए ('cdedc', सही)", "natural_language": "Hindi"}
{"task_id": "python/52", "entry_point": "max_fill", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n", "language": "python", "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n", "description": "आपको कुओं का एक आयताकार ग्रिड दिया जाता है। प्रत्येक पंक्ति एक कुएं का प्रतिनिधित्व करती है, \nऔर एक पंक्ति में प्रत्येक 1 पानी की एक इकाई का प्रतिनिधित्व करता है। \nप्रत्येक कुएँ में एक संबंधित बाल्टी होती है जिसका उपयोग उससे पानी निकालने के लिए किया जा सकता है। \nऔर सभी बाल्टियों में समान क्षमता होती है। \nआपका काम कुओं को खाली करने के लिए बाल्टियों का उपयोग करना है। \nजितनी बार आपको बाल्टियों को कम करने की आवश्यकता होगी, उसे आउटपुट करें। \n\nउदाहरण 1: \nइनपुटः \nग्रिडः [[0, 0,1,0], [0,1,0, 0], [1,1,1, 1]] \nबाल्टी क्षमताः 1 \nआउटपुटः 6 \n\nउदाहरण 2: \nइनपुटः \nग्रिडः [[0, 0,1,1], [0,0,0, 0], [1,1,1, 1], [0,1,1, 1]] \nबाल्टी क्षमताः 2 \nआउटपुटः 5 \n\nउदाहरण 3: \nइनपुटः \nग्रिडः [0,0,0], [0,0,0] \nबाल्टी क्षमताः 5 \nआउटपुटः 0 \n\nअड़चनेंः \n* सभी कुओं की लंबाई समान होती है। \n* 1 <= grid.length <= 10 ^ 2 \n* 1 <= ग्रिड [:, 1]. लंबाई <= 10 ^ 2 \nग्रिड [i] [j]-> 0। 1 \n* 1 <= क्षमता <= 10", "natural_language": "Hindi"}
{"task_id": "python/53", "entry_point": "select_words", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n", "language": "python", "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n", "description": "एक स्ट्रिंग s और एक प्राकृतिक संख्या n को देखते हुए, आपको इसे लागू करने का काम सौंपा गया है। \nएक प्रकार्य जो स्ट्रिंग एस से सभी शब्दों की एक सूची देता है जिसमें ठीक-ठीक शब्द होते हैं \nएन व्यंजन, क्रम में ये शब्द स्ट्रिंग एस में दिखाई देते हैं। \nयदि स्ट्रिंग s खाली है तो फ़ंक्शन को एक खाली सूची वापस करनी चाहिए। \nनोटः आप मान सकते हैं कि इनपुट स्ट्रिंग में केवल अक्षर और रिक्त स्थान हैं। \nउदाहरण के लिएः \nशब्द चुनें (\"मैरी के पास एक छोटा भेड़ का बच्चा था\", 4) = => [\"छोटा\"] \nशब्द चुनें (\"मैरी का एक छोटा भेड़ का बच्चा था\", 3) = => [\"मैरी\", \"भेड़ का बच्चा\"] \nशब्द चुनें (\"साधारण सफेद स्थान\", 2) = => [] \nशब्द चुनें (\"हैलो वर्ल्ड\", 4) = => [\"वर्ल्ड\"] \nशब्द चुनें (\"अंकल सैम\", 3) = => [\"अंकल\"]", "natural_language": "Hindi"}
{"task_id": "python/54", "entry_point": "maximum", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n", "language": "python", "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n", "description": "पूर्णांकों की एक सरणी arr और एक सकारात्मक पूर्णांक k दिए जाने पर, एक क्रमबद्ध सूची वापस करें \nए. आर. आर. में अधिकतम के संख्याओं के साथ लंबाई के. \n\nउदाहरण 1: \n\nइनपुटः arr = [-3,-4,5], k = 3 \nआउटपुटः [-4,-3,5] \n\nउदाहरण 2: \n\nइनपुटः arr = [4,-4,4], k = 2 \nआउटपुटः [4,4] \n\nउदाहरण 3: \n\nइनपुटः arr = [-3,2,1,2,-1,2,1], k = 1 \nआउटपुटः [2] \n\nध्यान देंः \n1. सरणी की लंबाई [1000] की सीमा में होगी। \n2. सरणी में तत्व [-1000] की सीमा में होंगे। \n3. 0 <= k <= लेन (arr)", "natural_language": "Hindi"}
{"task_id": "python/55", "entry_point": "add_elements", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n", "description": "पूर्णांक एआरआर और एक पूर्णांक के की एक गैर-खाली सरणी को देखते हुए, वापस करें \narr के पहले k तत्वों से अधिकतम दो अंकों वाले तत्वों का योग। \n\nउदाहरणः \n\nइनपुटः arr = [111,21,3, 4000,5,6, 7,8,9], k = 4 \nआउटपुटः 24 #21 + 3 का योग \n\nअड़चनेंः \n1. 1 <= लेन (arr) <= 100 \n2. 1 <= k <= लेन (arr)", "natural_language": "Hindi"}
{"task_id": "python/56", "entry_point": "intersection", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n", "language": "python", "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n", "description": "आपको दो अंतराल दिए जाते हैं, \nजहाँ प्रत्येक अंतराल पूर्णांकों का एक जोड़ा है। उदाहरण के लिए, अंतराल = (प्रारंभ, अंत) = (1,2)। \nदिए गए अंतराल बंद होते हैं जिसका अर्थ है कि अंतराल (प्रारंभ, अंत) \nइसमें शुरुआत और अंत दोनों शामिल हैं। \nप्रत्येक दिए गए अंतराल के लिए, यह माना जाता है कि इसकी शुरुआत कम या इसके अंत के बराबर है। \nआपका काम यह निर्धारित करना है कि इन दोनों के प्रतिच्छेदन की लंबाई कितनी है। \nअंतराल एक अभाज्य संख्या है। \nउदाहरण के लिए, अंतराल (1,3), (2,4) का प्रतिच्छेदन (2,3) है। \nजिसकी लंबाई 1 है, जो एक अभाज्य संख्या नहीं है। \nयदि प्रतिच्छेदन की लंबाई एक अभाज्य संख्या है, तो \"हाँ\" वापस करें, \nअन्यथा, \"नहीं\" वापस करें। \nयदि दोनों अंतराल एक दूसरे को नहीं काटते हैं, तो \"नहीं\" वापस करें। \n\n[इनपुट/आउटपुट] नमूनेः \nप्रतिच्छेदन ((1,2,3)) = => \"नहीं\" \nप्रतिच्छेदन ((-1,1), (0,4)) = => \"नहीं\" \nप्रतिच्छेदन ((-3,-1), (-5,5)) = => \"हाँ\"", "natural_language": "Hindi"}
{"task_id": "python/57", "entry_point": "tri", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n", "language": "python", "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n", "description": "हर कोई फिबोनाची अनुक्रम को जानता है, इसका गणितविदों द्वारा गहराई से अध्ययन किया गया था \nपिछली कुछ शताब्दियाँ। हालाँकि, लोग जो नहीं जानते हैं वह है ट्रिबोनाची अनुक्रम। \nट्राइबोनाची अनुक्रम को पुनरावृत्ति द्वारा परिभाषित किया जाता हैः \nत्रि (1) = 3 \nत्रि (एन) = 1 + एन/2, यदि एन सम है। \nयदि n विषम है तो त्रि (n) = त्रि (n-1) + त्रि (n-2) + त्रि (n + 1)। \nउदाहरण के लिएः \nत्रि (2) = 1 + (2/2) = 2 \nत्रि (4) = 3 \nत्रि (3) = त्रि (2) + त्रि (1) + त्रि (4) \n= 2 + 3 + 3 = 8 \nआपको एक गैर-नकारात्मक पूर्णांक संख्या n दी गई है, आपको एक सूची वापस करनी होगी \nट्रिबोनाची अनुक्रम की पहली n + 1 संख्याएँ। \nउदाहरण के लिएः \nत्रि (3) = [1,3,2,8]", "natural_language": "Hindi"}
{"task_id": "python/58", "entry_point": "digits", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n", "language": "python", "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n", "description": "एक सकारात्मक पूर्णांक n दिए जाने पर, विषम अंकों के गुणनफल को वापस करें। \nयदि सभी अंक सम हैं तो 0 वापस करें। \nउदाहरण के लिएः \nअंक (1) = = 1 \nअंक (4) = = 0 \nअंक (235) = = 15", "natural_language": "Hindi"}
{"task_id": "python/59", "entry_point": "is_nested", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n", "language": "python", "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n", "description": "एक ऐसा फ़ंक्शन बनाएँ जो एक स्ट्रिंग को इनपुट के रूप में लेता है जिसमें केवल वर्ग कोष्ठक होते हैं। \nफ़ंक्शन को सही लौटना चाहिए यदि और केवल तभी जब कोष्ठक का एक वैध अनुक्रम हो \nजेराव उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन उन। \n\nनेस्टेड ('[[]]') सही है \nis _ nested ('[]]]]] [[[[]') गलत है \nनेस्टेड ('[] []') गलत है \nनेस्टेड ('[]') गलत है \nनेस्टेड ('[[] []]') सही है \nनेस्टेड है ('[[]] [[') सही है", "natural_language": "Hindi"}
{"task_id": "python/60", "entry_point": "sum_squares", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n", "description": "आपको संख्याओं की एक सूची दी जाती है। \nआपको दी गई सूची में वर्ग संख्या का योग वापस करना होगा, \nसूची में प्रत्येक तत्व को पहले ऊपरी इंट (सीलिंग) में गोल करें। \nउदाहरण के लिएः \nlst = [1,2,3] के लिए आउटपुट 14 होना चाहिए। \nlst = [1,4,9] के लिए आउटपुट 98 होना चाहिए। \nlst = [1,3,5, 7] के लिए आउटपुट 84 होना चाहिए। \nlst = [1.4,4.2, 0] के लिए आउटपुट 29 होना चाहिए। \nlst = [-2.4,1, 1] के लिए आउटपुट 6 होना चाहिए।", "natural_language": "Hindi"}
{"task_id": "python/61", "entry_point": "check_if_last_char_is_a_letter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n", "description": "एक प्रकार्य बनाएँ जो सही लौटाता है यदि अंतिम वर्ण \nकिसी दिए गए स्ट्रिंग का वर्णमाला वर्ण है और यह नहीं है \nएक शब्द का एक हिस्सा, और अन्यथा गलत। \nनोटः \"शब्द\" अक्षरों का एक समूह है जो स्थान द्वारा अलग किया जाता है। \n\nउदाहरण के लिएः \nजाँचें _ अगर _ अंतिम _ चर _ है _ ए _ अक्षर (\"सेब पाई\") ′ गलत \nजाँच करें कि अगर _ अंतिम _ चर _ है _ a _ अक्षर (\"एप्पल पाई ई\") सही है \nजाँचें _ अगर _ अंतिम _ चर _ है _ ए _ अक्षर (\"सेब पाई ई\") गलत है \nजाँचें _ अगर _ अंतिम _ चर _ है _ ए _ अक्षर (\"\") ′ गलत", "natural_language": "Hindi"}
{"task_id": "python/62", "entry_point": "can_arrange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n", "language": "python", "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n", "description": "एक ऐसा फलन बनाएँ जो किसी तत्व का सबसे बड़ा सूचकांक देता है जो \nयह उससे तुरंत पहले के तत्व से बड़ा या बराबर नहीं है। यदि \nऐसा कोई तत्व मौजूद नहीं है तो वापसी-1। दिए गए सरणी में शामिल नहीं होगा \nडुप्लिकेट मान। \n\nउदाहरण के लिएः \nकैन अरेंज ([1,2,4, 3,5]) = 3 \nकैन अरेंज ([1,2,3]) =-1", "natural_language": "Hindi"}
{"task_id": "python/63", "entry_point": "largest_smallest_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "language": "python", "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "description": "एक फलन बनाएँ जो एक टुपल (ए, बी) देता है, जहाँ'ए'है \nऋणात्मक पूर्णांकों में सबसे बड़ा, और'बी'सबसे छोटा है \nएक सूची में सकारात्मक पूर्णांक। \nयदि कोई ऋणात्मक या धनात्मक पूर्णांक नहीं हैं, तो उन्हें शून्य के रूप में वापस करें। \n\nउदाहरण के लिएः \nसबसे बड़ा _ सबसे छोटा _ पूर्णांक ([2,4,1,3,5,7]) = = (कोई नहीं, 1) \nसबसे बड़ा _ सबसे छोटा _ पूर्णांक ([]) = = (कोई नहीं, कोई नहीं) \nसबसे बड़ा _ सबसे छोटा _ पूर्णांक ([0]) = = (कोई नहीं, कोई नहीं)", "natural_language": "Hindi"}
{"task_id": "python/64", "entry_point": "special_factorial", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n", "language": "python", "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "description": "ब्राजीलियाई भाज्य को इस प्रकार परिभाषित किया गया हैः \nब्राज़ीलियाई _ फैक्टोरियल (एन) = एन! * (एन-1)! * (एन-2)! *... * 1! \nजहाँ n> 0 \n\nउदाहरण के लिएः \n>>> स्पेशल _ फैक्टोरियल (4) \n288 \n\nफ़ंक्शन को इनपुट के रूप में एक पूर्णांक प्राप्त होगा और विशेष वापस करना चाहिए \nइस पूर्णांक का भाज्य।", "natural_language": "Hindi"}
{"task_id": "python/65", "entry_point": "words_in_sentence", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n", "language": "python", "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n", "description": "आपको एक वाक्य का प्रतिनिधित्व करने वाली एक स्ट्रिंग दी जाती है, \nवाक्य में कुछ शब्द हैं जो एक स्थान द्वारा अलग किए गए हैं, \nऔर आपको एक स्ट्रिंग वापस करनी होगी जिसमें मूल वाक्य के शब्द शामिल हैं, \nजिनकी लंबाई अभाज्य संख्याएँ हैं, \nनई स्ट्रिंग में शब्दों का क्रम मूल के समान होना चाहिए। \n\nउदाहरण 1: \nइनपुटः वाक्य = \"यह एक परीक्षण है\" \nआउटपुटः \"है\" \n\nउदाहरण 2: \nइनपुटः वाक्य = \"चलो तैरने के लिए चलते हैं\" \nआउटपुटः \"के लिए जाएँ\" \n\nअड़चनेंः \n* 1 <= लेन (वाक्य) <= 100 \n* वाक्य में केवल अक्षर होते हैं", "natural_language": "Hindi"}
{"task_id": "python/66", "entry_point": "simplify", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n", "language": "python", "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n", "description": "आपका काम एक ऐसे कार्य को लागू करना है जो अभिव्यक्ति को सरल बनाएगा। \nx * n. फलन सही बताता है यदि x * n एक पूर्ण संख्या का मूल्यांकन करता है और गलत \nअन्यथा। x और n दोनों, एक अंश के स्ट्रिंग प्रतिनिधित्व हैं, और निम्नलिखित प्रारूप हैं, \n<अंश> <भाजक> जहाँ अंश और भाजक दोनों सकारात्मक पूर्ण संख्याएँ हैं। \n\nआप मान सकते हैं कि x, और n वैध अंश हैं, और विभाजक के रूप में शून्य नहीं हैं। \n\nसरलीकरण (\"1/5\", \"5/1\") = सही \nसरलीकरण (\"1/6\", \"2/1\") = गलत \nसरलीकरण (\"7/10\", \"10/2\") = गलत", "natural_language": "Hindi"}
{"task_id": "python/67", "entry_point": "order_by_points", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n", "description": "एक प्रकार्य लिखें जो पूर्णांकों की दी गई सूची को क्रमबद्ध करता है। \nउनके अंकों के योग के अनुसार आरोही क्रम में। \nनोटः यदि कई वस्तुएँ हैं जिनके अंकों का योग समान है, \nमूल सूची में उनके सूचकांक के आधार पर उन्हें ऑर्डर करें। \n\nउदाहरण के लिएः \n>>> ऑर्डर _ बाय _ पॉइंट्स ([1,11,-1,11,-12]) = = [-1,11,1,-12,11] \n>>> ऑर्डर _ बाय _ पॉइंट्स ([]) = = []", "natural_language": "Hindi"}
{"task_id": "python/68", "entry_point": "specialFilter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n", "language": "python", "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n", "description": "एक प्रकार्य लिखें जो इनपुट और रिटर्न के रूप में संख्याओं की एक सरणी लेता है। \nसरणी में तत्वों की संख्या जो 10 से अधिक है और दोनों \nएक संख्या के पहले और अंतिम अंक विषम (1,3,5,7,9) होते हैं। \nउदाहरण के लिएः \nविशेष फ़िल्टर ([15,-73,14,-15]) => 1 \nविशेष फ़िल्टर ([33,-2,-3,45,21,109]) => 2", "natural_language": "Hindi"}
{"task_id": "python/69", "entry_point": "get_max_triples", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n", "language": "python", "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n", "description": "आपको एक सकारात्मक पूर्णांक n दिया जाता है। आपको n लंबाई का एक पूर्णांक सरणी a बनाना होगा। \nप्रत्येक i (1 ≤ i ≤ n) के लिए, a [i] = i * i-i + 1 का मान। \na के तीन गुना (a [i], a [j], a [k]) की संख्या वापस करें जहाँ i <j <k, \nऔर a [i] + a [j] + a [k] 3 का गुणज है। \n\nउदाहरणः \nइनपुटः एन = 5 \nआउटपुटः 1 \nव्याख्याः \na = [1,3,7,13,21] \nएकमात्र वैध ट्रिपल (1,7,13) है।", "natural_language": "Hindi"}
{"task_id": "python/70", "entry_point": "bf", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n", "language": "python", "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n", "description": "हमारे सौर मंडल में आठ ग्रह हैंः सूर्य के सबसे करीब \nबुध है, अगला शुक्र है, फिर पृथ्वी, मंगल, बृहस्पति, शनि, \nयूरेनस, नेपच्यून। \nएक कार्य लिखें जो दो ग्रहों के नाम ग्रह 1 और ग्रह 2 के रूप में लेता है। \nफ़ंक्शन को सभी ग्रहों वाले एक टुपल को वापस करना चाहिए जिनकी कक्षाएँ हैं \nग्रह 1 की कक्षा और ग्रह 2 की कक्षा के बीच स्थित, द्वारा क्रमबद्ध \nसूर्य की निकटता। \nयदि प्लैनेट1 या प्लैनेट2 है तो फ़ंक्शन को एक खाली टुपल वापस करना चाहिए। \nग्रहों के नाम सही नहीं हैं। \nउदाहरण \nbf (\"बृहस्पति\", \"नेपच्यून\") = => (\"शनि\", \"यूरेनस\") \nbf (\"पृथ्वी\", \"बुध\") = => (\"शुक्र\") \nbf (\"बुध\", \"यूरेनस\") = => (\"शुक्र\", \"पृथ्वी\", \"मंगल\", \"बृहस्पति\", \"शनि\")", "natural_language": "Hindi"}
{"task_id": "python/71", "entry_point": "x_or_y", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n", "language": "python", "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n", "description": "एक सरल प्रोग्राम जिसे x का मान वापस करना चाहिए यदि n है \nएक अभाज्य संख्या और अन्यथा y का मान वापस करना चाहिए। \n\nउदाहरण के लिएः \nx _ या _ y (7,34,12) = = 34 के लिए \nx _ या _ y (15,8,5) = = 5 के लिए", "natural_language": "Hindi"}
{"task_id": "python/72", "entry_point": "double_the_difference", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n", "description": "संख्याओं की सूची दिए जाने पर, संख्याओं के वर्गों का योग वापस करें। \nविषम सूची में. उन संख्याओं को नजरअंदाज करें जो ऋणात्मक हैं या पूर्णांक नहीं हैं। \n\nडबल _ द _ डिफरेंस ([1,3,2,0]) = = 1 + 9 + 0 + 0 = 10 \nडबल _ द _ डिफरेंस ([-1,0]) = = 0 \nडबल _ द _ डिफरेंस ([9,-2]) = = 81 \nडबल _ द _ डिफरेंस ([0]) = = 0 \n\nयदि इनपुट सूची खाली है, तो 0 वापस करें।", "natural_language": "Hindi"}
{"task_id": "python/73", "entry_point": "Strongest_Extension", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n\n", "language": "python", "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n", "description": "आपको एक वर्ग का नाम (एक स्ट्रिंग) और एक्सटेंशन की एक सूची दी जाएगी। \nइन विस्तारों का उपयोग कक्षा में अतिरिक्त वर्गों को लोड करने के लिए किया जाना है। \nविस्तार की ताकत इस प्रकार हैः मान लीजिए कि CAP बड़े अक्षर की संख्या है। \nविस्तार के नाम में अक्षर, और एस. एम. को छोटे अक्षरों की संख्या होने दें \nविस्तार के नाम में, ताकत सीएपी-एसएम अंश द्वारा दी जाती है। \nआपको सबसे मजबूत एक्सटेंशन ढूंढना चाहिए और इसमें एक स्ट्रिंग वापस करनी चाहिए। \nप्रारूपः ClassName.StrongestExtensionName। \nयदि एक ही ताकत के साथ दो या दो से अधिक विस्तार हैं, तो आपको करना चाहिए \nसूची में सबसे पहले आने वाले को चुनें। \nउदाहरण के लिए, यदि आपको वर्ग और सूची के रूप में \"स्लाइस\" दिए गए हैं \nविस्तारः ['SERVINGSliCes','चीज़','स्टुफ़ेड'] तो आपको करना चाहिए \nरिटर्न'Slices.SErviNGSliCes'क्योंकि'SERVINGSliCes'सबसे मजबूत एक्सटेंशन है \n(इसकी ताकत-1 है)। \nउदाहरणः \nसबसे मजबूत _ विस्तार के लिए ('माय _ क्लास', ['एए','बी','सीसी']) = ='my_class.AA'", "natural_language": "Hindi"}
{"task_id": "python/74", "entry_point": "cycpattern_check", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n", "language": "python", "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n", "description": "आपको 2 शब्द दिए गए हैं। आपको सही लौटाने की आवश्यकता है यदि दूसरा शब्द या इसका कोई भी आवर्तन पहले शब्द में एक सबस्ट्रिंग है। \nसाइकपेटर्न _ चेक (\"ए. बी. सी. डी\"., \"ए. बी. डी\".) => गलत \nसाइकपेटर्न _ चेक (\"हैलो\", \"ईल\") => सही \nसाइकपेटर्न _ चेक (\"व्हासअप\", \"psus\") => गलत \nसाइकपेटर्न _ चेक (\"अबाब\", \"बा\") => सही \nसाइकपेटर्न _ चेक (\"ई. एफ. ई. एफ\"., \"ई. ई. एफ. एफ\".) => गलत \nसाइकपेटर्न _ चेक (\"हिमेन्स\", \"सिमेन\") => सही", "natural_language": "Hindi"}
{"task_id": "python/75", "entry_point": "int_to_mini_roman", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n", "description": "एक सकारात्मक पूर्णांक दिए जाने पर, एक स्ट्रिंग के रूप में इसके रोमन अंक के समतुल्य प्राप्त करें, \nऔर इसे छोटे अक्षर में वापस कर दें। \nप्रतिबंधः 1 <= संख्या <= 1000 \n\nउदाहरण के लिएः \n>>> इंट _ टू _ मिनी _ रोमन (19) = ='xix'\n>>> इंट _ टू _ मिनी _ रोमन (152) = ='क्लाई'\n>> इंट _ टू _ मिनी _ रोमन (426) = ='cdxxvi'", "natural_language": "Hindi"}
{"task_id": "python/76", "entry_point": "right_angle_triangle", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n", "language": "python", "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n", "description": "त्रिभुज की तीनों भुजाओं की लंबाई को देखते हुए. सही लौटें यदि तीनों \nभुजाएँ एक समकोण त्रिभुज बनाती हैं, अन्यथा गलत। \nसमकोण त्रिभुज वह त्रिभुज है जिसमें एक कोण समकोण या समकोण होता है। \n90 डिग्री। \nउदाहरणः \nसमकोण त्रिभुज (3,4,5) = = सही \nसमकोण त्रिभुज (1,2,3) = = गलत", "natural_language": "Hindi"}
{"task_id": "python/77", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n", "language": "python", "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n", "description": "आपको एक स्ट्रिंग s दी जाती है। \nयदि एस [आई] एक अक्षर है, तो इसके मामले को निचले से ऊपरी या इसके विपरीत करें, \nअन्यथा इसे वैसे ही रखें जैसे वह है। \nयदि स्ट्रिंग में कोई अक्षर नहीं हैं, तो स्ट्रिंग को उलट दें। \nफ़ंक्शन को परिणामी स्ट्रिंग वापस करनी चाहिए। \nउदाहरण \nहल करें (\"1234\") = \"4321\" \nहल करें (\"एबी\") = \"एबी\" \nहल करें (\"#a @C\") = \"#A @c\"", "natural_language": "Hindi"}
{"task_id": "python/78", "entry_point": "string_to_md5", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n", "description": "स्ट्रिंग'टेक्स्ट'को देखते हुए, इसके md5 हैश समकक्ष स्ट्रिंग को वापस करें। \nयदि'पाठ'एक खाली स्ट्रिंग है, तो शून्य वापस करें। \n\n>> स्ट्रिंग _ से _ md5 ('हैलो वर्ल्ड') = ='3e25960a79dbc69b674cd4ec67a72c62'", "natural_language": "Hindi"}
{"task_id": "python/79", "entry_point": "generate_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n", "description": "दो धनात्मक पूर्णांक a और b दिए जाने पर, a के बीच के सम अंकों को वापस करें। \nऔर बी, आरोही क्रम में। \n\nउदाहरण के लिएः \nपूर्णांक उत्पन्न करें (2,8) => [2,4,6,8] \nपूर्णांक उत्पन्न करें (8,2) => [2,4,6,8] \nपूर्णांक उत्पन्न करें (10,14) => []", "natural_language": "Hindi"}
